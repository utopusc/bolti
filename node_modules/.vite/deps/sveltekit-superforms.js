import {
  SchemaError,
  SuperFormError,
  assertSchema,
  clone,
  comparePaths,
  defaultValues,
  flattenErrors,
  mapErrors,
  mergeDefaults,
  mergePath,
  pathExists,
  replaceInvalidDefaults,
  schemaInfo,
  schemaShape,
  setPaths,
  shapeFromObject,
  splitPath,
  traversePath,
  traversePaths,
  updateErrors
} from "./chunk-Y5VDOUQP.js";
import {
  parse,
  stringify
} from "./chunk-G2MPMC3M.js";
import "./chunk-SA3VOP2B.js";
import {
  derived,
  readable,
  readonly,
  writable
} from "./chunk-PCTSVBTO.js";
import "./chunk-X7HCJ7ZS.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_store_value,
  get_svelte_dataset,
  globals,
  group_outros,
  handle_promise,
  init,
  insert_hydration_dev,
  listen_dev,
  noop,
  onDestroy,
  prevent_default,
  safe_not_equal,
  set_data_dev,
  space,
  subscribe,
  svg_element,
  text,
  tick,
  toggle_class,
  transition_in,
  transition_out,
  update_await_block_branch,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-L3FAA3FO.js";
import "./chunk-EKIRE5YT.js";
import "./chunk-MTI3AIJG.js";

// node_modules/sveltekit-superforms/dist/client/SuperDebug.svelte
import { browser } from "$app/environment";
import { page } from "$app/stores";
var { Error: Error_1 } = globals;
var file = "node_modules/sveltekit-superforms/dist/client/SuperDebug.svelte";
function get_if_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = (
    /*styleInit*/
    child_ctx[13] = true
  );
  child_ctx[27] = constants_0;
  return child_ctx;
}
function create_if_block_5(ctx) {
  let style;
  let textContent = ".super-debug--absolute {\n			position: absolute;\n		}\n\n		.super-debug--top-0 {\n			top: 0;\n		}\n\n		.super-debug--inset-x-0 {\n			left: 0px;\n			right: 0px;\n		}\n\n		.super-debug--hidden {\n			height: 0;\n			overflow: hidden;\n		}\n\n		.super-debug--hidden:not(.super-debug--with-label) {\n			height: 1.5em;\n		}\n\n		.super-debug--rotated {\n			transform: rotate(180deg);\n		}\n\n		.super-debug {\n			--_sd-bg-color: var(--sd-bg-color, var(--sd-vscode-bg-color, rgb(30, 41, 59)));\n			position: relative;\n			background-color: var(--_sd-bg-color);\n			border-radius: 0.5rem;\n			overflow: hidden;\n		}\n\n		.super-debug--pre {\n			overflow-x: auto;\n		}\n\n		.super-debug--collapse {\n			display: block;\n			width: 100%;\n			color: rgba(255, 255, 255, 0.25);\n			background-color: rgba(255, 255, 255, 0.15);\n			padding: 5px 0;\n			display: flex;\n			justify-content: center;\n			border-color: transparent;\n			margin: 0;\n			padding: 3px 0;\n		}\n\n		.super-debug--collapse:focus {\n			color: #fafafa;\n			background-color: rgba(255, 255, 255, 0.25);\n		}\n\n		.super-debug--collapse:is(:hover) {\n			color: rgba(255, 255, 255, 0.35);\n			background-color: rgba(255, 255, 255, 0.25);\n		}\n\n		.super-debug--status {\n			display: flex;\n			padding: 1em;\n			padding-bottom: 0;\n			justify-content: space-between;\n			font-family: Inconsolata, Monaco, Consolas, 'Lucida Console', 'Courier New', Courier,\n				monospace;\n		}\n\n		.super-debug--right-status {\n			display: flex;\n			gap: 0.55em;\n		}\n\n		.super-debug--copy {\n			margin: 0;\n			padding: 0;\n			padding-top: 2px;\n			background-color: transparent;\n			border: 0;\n			color: #666;\n			cursor: pointer;\n		}\n\n		.super-debug--copy:hover {\n			background-color: transparent;\n			color: #666;\n		}\n\n		.super-debug--copy:focus {\n			background-color: transparent;\n			color: #666;\n		}\n\n		.super-debug--label {\n			color: var(--sd-label-color, var(--sd-vscode-label-color, white));\n		}\n\n		.super-debug--promise-loading {\n			color: var(--sd-promise-loading-color, var(--sd-vscode-promise-loading-color, #999));\n		}\n\n		.super-debug--promise-rejected {\n			color: var(--sd-promise-rejected-color, var(--sd-vscode-promise-rejected-color, #ff475d));\n		}\n\n		.super-debug pre {\n			color: var(--sd-code-default, var(--sd-vscode-code-default, #999));\n			background-color: var(--_sd-bg-color);\n			font-size: 1em;\n			margin-bottom: 0;\n			padding: 1em 0 1em 1em;\n		}\n\n		.super-debug--info {\n			color: var(--sd-info, var(--sd-vscode-info, rgb(85, 85, 255)));\n		}\n\n		.super-debug--success {\n			color: var(--sd-success, var(--sd-vscode-success, #2cd212));\n		}\n\n		.super-debug--redirect {\n			color: var(--sd-redirect, var(--sd-vscode-redirect, #03cae5));\n		}\n\n		.super-debug--error {\n			color: var(--sd-error, var(--sd-vscode-error, #ff475d));\n		}\n\n		.super-debug--code .key {\n			color: var(--sd-code-key, var(--sd-vscode-code-key, #eab308));\n		}\n\n		.super-debug--code .string {\n			color: var(--sd-code-string, var(--sd-vscode-code-string, #6ec687));\n		}\n\n		.super-debug--code .date {\n			color: var(--sd-code-date, var(--sd-vscode-code-date, #f06962));\n		}\n\n		.super-debug--code .boolean {\n			color: var(--sd-code-boolean, var(--sd-vscode-code-boolean, #79b8ff));\n		}\n\n		.super-debug--code .number {\n			color: var(--sd-code-number, var(--sd-vscode-code-number, #af77e9));\n		}\n\n		.super-debug--code .bigint {\n			color: var(--sd-code-bigint, var(--sd-vscode-code-bigint, #af77e9));\n		}\n\n		.super-debug--code .null {\n			color: var(--sd-code-null, var(--sd-vscode-code-null, #238afe));\n		}\n\n		.super-debug--code .nan {\n			color: var(--sd-code-nan, var(--sd-vscode-code-nan, #af77e9));\n		}\n\n		.super-debug--code .undefined {\n			color: var(--sd-code-undefined, var(--sd-vscode-code-undefined, #238afe));\n		}\n\n		.super-debug--code .function {\n			color: var(--sd-code-function, var(--sd-vscode-code-function, #f06962));\n		}\n\n		.super-debug--code .symbol {\n			color: var(--sd-code-symbol, var(--sd-vscode-code-symbol, #4de0c5));\n		}\n\n		.super-debug--code .error {\n			color: var(--sd-code-error, var(--sd-vscode-code-error, #ff475d));\n		}\n\n		.super-debug pre::-webkit-scrollbar {\n			width: var(--sd-sb-width, var(--sd-vscode-sb-width, 1rem));\n			height: var(--sd-sb-height, var(--sd-vscode-sb-height, 1rem));\n		}\n\n		.super-debug pre::-webkit-scrollbar-track {\n			border-radius: 12px;\n			background-color: var(\n				--sd-sb-track-color,\n				var(--sd-vscode-sb-track-color, hsl(0, 0%, 40%, 0.2))\n			);\n		}\n		.super-debug:is(:focus-within, :hover) pre::-webkit-scrollbar-track {\n			border-radius: 12px;\n			background-color: var(\n				--sd-sb-track-color-focus,\n				var(--sd-vscode-sb-track-color-focus, hsl(0, 0%, 50%, 0.2))\n			);\n		}\n\n		.super-debug pre::-webkit-scrollbar-thumb {\n			border-radius: 12px;\n			background-color: var(\n				--sd-sb-thumb-color,\n				var(--sd-vscode-sb-thumb-color, hsl(217, 50%, 50%, 0.5))\n			);\n		}\n		.super-debug:is(:focus-within, :hover) pre::-webkit-scrollbar-thumb {\n			border-radius: 12px;\n			background-color: var(\n				--sd-sb-thumb-color-focus,\n				var(--sd-vscode-sb-thumb-color-focus, hsl(217, 50%, 50%))\n			);\n		}";
  const block = {
    c: function create() {
      style = element("style");
      style.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      style = claim_element(nodes, "STYLE", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(style) !== "svelte-iwb968") style.textContent = textContent;
      this.h();
    },
    h: function hydrate() {
      add_location(style, file, 436, 1, 11180);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, style, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(style);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(436:0) {#if !styleInit}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div3;
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let button;
  let t2;
  let div2_class_value;
  let t3;
  let pre;
  let code;
  let t4;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (!/*copied*/
    ctx2[8]) return create_if_block_4;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*status*/
    ctx[3] && create_if_block_3(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  let if_block2 = (
    /*collapsible*/
    ctx[7] && create_if_block_1(ctx)
  );
  const block = {
    c: function create() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(
        /*label*/
        ctx[4]
      );
      t1 = space();
      div1 = element("div");
      button = element("button");
      if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      pre = element("pre");
      code = element("code");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      t4 = space();
      if (if_block2) if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, style: true, dir: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*label*/
        ctx[4]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      button = claim_element(div1_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      if_block0.l(button_nodes);
      button_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block1) if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t3 = claim_space(div3_nodes);
      pre = claim_element(div3_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      code = claim_element(pre_nodes, "CODE", { class: true });
      var code_nodes = children(code);
      if (default_slot_or_fallback) default_slot_or_fallback.l(code_nodes);
      code_nodes.forEach(detach_dev);
      pre_nodes.forEach(detach_dev);
      t4 = claim_space(div3_nodes);
      if (if_block2) if_block2.l(div3_nodes);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "super-debug--label");
      add_location(div0, file, 668, 3, 16619);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "super-debug--copy");
      add_location(button, file, 670, 4, 16712);
      attr_dev(div1, "class", "super-debug--right-status");
      add_location(div1, file, 669, 3, 16668);
      attr_dev(div2, "class", div2_class_value = "super-debug--status " + /*label*/
      (ctx[4] === "" ? "super-debug--absolute super-debug--inset-x-0 super-debug--top-0" : ""));
      add_location(div2, file, 663, 2, 16480);
      attr_dev(code, "class", "super-debug--code");
      add_location(code, file, 722, 19, 18369);
      attr_dev(pre, "class", "super-debug--pre");
      toggle_class(
        pre,
        "super-debug--with-label",
        /*label*/
        ctx[4]
      );
      toggle_class(
        pre,
        "super-debug--hidden",
        /*collapsed*/
        ctx[1]
      );
      add_location(pre, file, 718, 2, 18235);
      attr_dev(div3, "class", "super-debug");
      attr_dev(
        div3,
        "style",
        /*themeStyle*/
        ctx[10]
      );
      attr_dev(div3, "dir", "ltr");
      toggle_class(
        div3,
        "super-debug--collapsible",
        /*collapsible*/
        ctx[7]
      );
      add_location(div3, file, 657, 1, 16368);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, button);
      if_block0.m(button, null);
      append_hydration_dev(div1, t2);
      if (if_block1) if_block1.m(div1, null);
      append_hydration_dev(div3, t3);
      append_hydration_dev(div3, pre);
      append_hydration_dev(pre, code);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(code, null);
      }
      ctx[23](pre);
      append_hydration_dev(div3, t4);
      if (if_block2) if_block2.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*copyContent*/
          ctx[15],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*label*/
      16) set_data_dev(
        t0,
        /*label*/
        ctx2[4]
      );
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(button, null);
        }
      }
      if (
        /*status*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_3(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*label*/
      16 && div2_class_value !== (div2_class_value = "super-debug--status " + /*label*/
      (ctx2[4] === "" ? "super-debug--absolute super-debug--inset-x-0 super-debug--top-0" : ""))) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*$debugData, raw, promise*/
        4192)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*label*/
      16) {
        toggle_class(
          pre,
          "super-debug--with-label",
          /*label*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*collapsed*/
      2) {
        toggle_class(
          pre,
          "super-debug--hidden",
          /*collapsed*/
          ctx2[1]
        );
      }
      if (
        /*collapsible*/
        ctx2[7]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1(ctx2);
          if_block2.c();
          if_block2.m(div3, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty & /*themeStyle*/
      1024) {
        attr_dev(
          div3,
          "style",
          /*themeStyle*/
          ctx2[10]
        );
      }
      if (!current || dirty & /*collapsible*/
      128) {
        toggle_class(
          div3,
          "super-debug--collapsible",
          /*collapsible*/
          ctx2[7]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      if_block0.d();
      if (if_block1) if_block1.d();
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      ctx[23](null);
      if (if_block2) if_block2.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(657:0) {#if display}",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let svg;
  let g;
  let path0;
  let rect;
  let path1;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      g = svg_element("g");
      path0 = svg_element("path");
      rect = svg_element("rect");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      g = claim_svg_element(svg_nodes, "g", {
        fill: true,
        stroke: true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        "stroke-width": true
      });
      var g_nodes = children(g);
      path0 = claim_svg_element(g_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      rect = claim_svg_element(g_nodes, "rect", {
        width: true,
        height: true,
        x: true,
        y: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      path1 = claim_svg_element(g_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      g_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M15 12v6m-3-3h6");
      add_location(path0, file, 694, 9, 17612);
      attr_dev(rect, "width", "14");
      attr_dev(rect, "height", "14");
      attr_dev(rect, "x", "8");
      attr_dev(rect, "y", "8");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file, 694, 37, 17640);
      attr_dev(path1, "d", "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2");
      add_location(path1, file, 701, 10, 17759);
      attr_dev(g, "fill", "none");
      attr_dev(g, "stroke", "currentColor");
      attr_dev(g, "stroke-linecap", "round");
      attr_dev(g, "stroke-linejoin", "round");
      attr_dev(g, "stroke-width", "2");
      add_location(g, file, 688, 8, 17462);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "1em");
      attr_dev(svg, "height", "1em");
      attr_dev(svg, "viewBox", "0 0 24 24");
      add_location(svg, file, 687, 6, 17369);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, g);
      append_hydration_dev(g, path0);
      append_hydration_dev(g, rect);
      append_hydration_dev(g, path1);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(687:5) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let svg;
  let g;
  let path0;
  let path1;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      g = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      g = claim_svg_element(svg_nodes, "g", {
        fill: true,
        stroke: true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        "stroke-width": true
      });
      var g_nodes = children(g);
      path0 = claim_svg_element(g_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(g_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      g_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M7 9.667A2.667 2.667 0 0 1 9.667 7h8.666A2.667 2.667 0 0 1 21 9.667v8.666A2.667 2.667 0 0 1 18.333 21H9.667A2.667 2.667 0 0 1 7 18.333z");
      add_location(path0, file, 679, 9, 17052);
      attr_dev(path1, "d", "M4.012 16.737A2.005 2.005 0 0 1 3 15V5c0-1.1.9-2 2-2h10c.75 0 1.158.385 1.5 1");
      add_location(path1, file, 681, 10, 17217);
      attr_dev(g, "fill", "none");
      attr_dev(g, "stroke", "currentColor");
      attr_dev(g, "stroke-linecap", "round");
      attr_dev(g, "stroke-linejoin", "round");
      attr_dev(g, "stroke-width", "2");
      add_location(g, file, 673, 8, 16902);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "1em");
      attr_dev(svg, "height", "1em");
      attr_dev(svg, "viewBox", "0 0 24 24");
      add_location(svg, file, 672, 6, 16809);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, g);
      append_hydration_dev(g, path0);
      append_hydration_dev(g, path1);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(672:5) {#if !copied}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let div;
  let t_value = (
    /*$page*/
    ctx[11].status + ""
  );
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(
        div,
        "super-debug--info",
        /*$page*/
        ctx[11].status < 200
      );
      toggle_class(
        div,
        "super-debug--success",
        /*$page*/
        ctx[11].status >= 200 && /*$page*/
        ctx[11].status < 300
      );
      toggle_class(
        div,
        "super-debug--redirect",
        /*$page*/
        ctx[11].status >= 300 && /*$page*/
        ctx[11].status < 400
      );
      toggle_class(
        div,
        "super-debug--error",
        /*$page*/
        ctx[11].status >= 400
      );
      add_location(div, file, 707, 5, 17900);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$page*/
      2048 && t_value !== (t_value = /*$page*/
      ctx2[11].status + "")) set_data_dev(t, t_value);
      if (dirty & /*$page*/
      2048) {
        toggle_class(
          div,
          "super-debug--info",
          /*$page*/
          ctx2[11].status < 200
        );
      }
      if (dirty & /*$page*/
      2048) {
        toggle_class(
          div,
          "super-debug--success",
          /*$page*/
          ctx2[11].status >= 200 && /*$page*/
          ctx2[11].status < 300
        );
      }
      if (dirty & /*$page*/
      2048) {
        toggle_class(
          div,
          "super-debug--redirect",
          /*$page*/
          ctx2[11].status >= 300 && /*$page*/
          ctx2[11].status < 400
        );
      }
      if (dirty & /*$page*/
      2048) {
        toggle_class(
          div,
          "super-debug--error",
          /*$page*/
          ctx2[11].status >= 400
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(707:4) {#if status}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let html_tag;
  let raw_1_value = (
    /*syntaxHighlight*/
    ctx[16](
      /*$debugData*/
      ctx[12]
    ) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_1_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$debugData*/
      4096 && raw_1_value !== (raw_1_value = /*syntaxHighlight*/
      ctx2[16](
        /*$debugData*/
        ctx2[12]
      ) + "")) html_tag.p(raw_1_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(729:47) {:else}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let await_block_anchor;
  let promise_1;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 25,
    error: 26
  };
  handle_promise(promise_1 = /*$debugData*/
  ctx[12], info);
  const block = {
    c: function create() {
      await_block_anchor = empty();
      info.block.c();
    },
    l: function claim(nodes) {
      await_block_anchor = empty();
      info.block.l(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & /*$debugData*/
      4096 && promise_1 !== (promise_1 = /*$debugData*/
      ctx[12]) && handle_promise(promise_1, info)) {
      } else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(await_block_anchor);
      }
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(725:6) {#if assertPromise($debugData, raw, promise)}",
    ctx
  });
  return block;
}
function create_catch_block(ctx) {
  let span;
  let textContent = "Rejected:";
  let t1;
  let html_tag;
  let raw_1_value = (
    /*syntaxHighlight*/
    ctx[16](
      /*error*/
      ctx[26]
    ) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      span = element("span");
      span.textContent = textContent;
      t1 = text(" ");
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-1dplpxh") span.textContent = textContent;
      t1 = claim_text(nodes, " ");
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "super-debug--promise-rejected");
      add_location(span, file, 727, 23, 18670);
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      insert_hydration_dev(target, t1, anchor);
      html_tag.m(raw_1_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$debugData*/
      4096 && raw_1_value !== (raw_1_value = /*syntaxHighlight*/
      ctx2[16](
        /*error*/
        ctx2[26]
      ) + "")) html_tag.p(raw_1_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
        detach_dev(t1);
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_catch_block.name,
    type: "catch",
    source: "(728:9) {:catch error}",
    ctx
  });
  return block;
}
function create_then_block(ctx) {
  let html_tag;
  let raw_1_value = (
    /*syntaxHighlight*/
    ctx[16](assertStore(
      /*result*/
      ctx[25],
      /*raw*/
      ctx[6]
    ) ? get_store_value(
      /*result*/
      ctx[25]
    ) : (
      /*result*/
      ctx[25]
    )) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_1_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$debugData, raw*/
      4160 && raw_1_value !== (raw_1_value = /*syntaxHighlight*/
      ctx2[16](assertStore(
        /*result*/
        ctx2[25],
        /*raw*/
        ctx2[6]
      ) ? get_store_value(
        /*result*/
        ctx2[25]
      ) : (
        /*result*/
        ctx2[25]
      )) + "")) html_tag.p(raw_1_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_then_block.name,
    type: "then",
    source: "(726:66) {:then result}",
    ctx
  });
  return block;
}
function create_pending_block(ctx) {
  let div;
  let textContent = "Loading data...";
  const block = {
    c: function create() {
      div = element("div");
      div.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(div) !== "svelte-phqra4") div.textContent = textContent;
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "super-debug--promise-loading");
      add_location(div, file, 724, 70, 18482);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_pending_block.name,
    type: "pending",
    source: '(725:70) <div         class=\\"super-debug--promise-loading\\">Loading data...</div>{:then result}',
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let show_if;
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (dirty & /*$debugData, raw, promise*/
    4192) show_if = null;
    if (show_if == null) show_if = !!assertPromise(
      /*$debugData*/
      ctx2[12],
      /*raw*/
      ctx2[6],
      /*promise*/
      ctx2[5]
    );
    if (show_if) return create_if_block_2;
    return create_else_block;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(725:6) {#if assertPromise($debugData, raw, promise)}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let button;
  let svg;
  let path;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M4.08 11.92L12 4l7.92 7.92l-1.42 1.41l-5.5-5.5V22h-2V7.83l-5.5 5.5l-1.42-1.41M12 4h10V2H2v2h10Z");
      add_location(path, file, 745, 6, 19174);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "20");
      attr_dev(svg, "height", "20");
      attr_dev(svg, "viewBox", "0 0 24 24");
      toggle_class(
        svg,
        "super-debug--rotated",
        /*collapsed*/
        ctx[1]
      );
      add_location(svg, file, 739, 4, 19021);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "super-debug--collapse");
      add_location(button, file, 734, 3, 18892);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, path);
      if (!mounted) {
        dispose = listen_dev(button, "click", prevent_default(
          /*click_handler*/
          ctx[24]
        ), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*collapsed*/
      2) {
        toggle_class(
          svg,
          "super-debug--rotated",
          /*collapsed*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(734:2) {#if collapsible}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = !/*styleInit*/
  ctx[13] && create_if_block_5(get_if_ctx(ctx));
  let if_block1 = (
    /*display*/
    ctx[2] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*display*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*display*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function makeError() {
  return new DOMException("The request is not allowed", "NotAllowedError");
}
async function copyClipboardApi(text2) {
  if (!navigator.clipboard) {
    throw makeError();
  }
  return navigator.clipboard.writeText(text2);
}
async function copyExecCommand(text2) {
  const span = document.createElement("span");
  span.textContent = text2;
  span.style.whiteSpace = "pre";
  span.style.webkitUserSelect = "auto";
  span.style.userSelect = "all";
  document.body.appendChild(span);
  const selection = window.getSelection();
  const range = window.document.createRange();
  selection == null ? void 0 : selection.removeAllRanges();
  range.selectNode(span);
  selection == null ? void 0 : selection.addRange(range);
  let success = false;
  try {
    success = window.document.execCommand("copy");
  } finally {
    selection == null ? void 0 : selection.removeAllRanges();
    window.document.body.removeChild(span);
  }
  if (!success) throw makeError();
}
async function clipboardCopy(text2) {
  try {
    await copyClipboardApi(text2);
  } catch (err) {
    try {
      await copyExecCommand(text2);
    } catch (err2) {
      throw err2 || err || makeError();
    }
  }
}
function fileToJSON(file2) {
  return {
    name: file2.name,
    size: file2.size,
    type: file2.type,
    lastModified: new Date(file2.lastModified)
  };
}
function assertPromise(data, raw, promise) {
  if (raw) {
    return false;
  }
  return promise || typeof data === "object" && data !== null && "then" in data && typeof data["then"] === "function";
}
function assertStore(data, raw) {
  if (raw) {
    return false;
  }
  return typeof data === "object" && data !== null && "subscribe" in data && typeof data["subscribe"] === "function";
}
function instance($$self, $$props, $$invalidate) {
  let themeStyle;
  let debugData;
  let $page;
  let $debugData, $$unsubscribe_debugData = noop, $$subscribe_debugData = () => ($$unsubscribe_debugData(), $$unsubscribe_debugData = subscribe(debugData, ($$value) => $$invalidate(12, $debugData = $$value)), debugData);
  validate_store(page, "page");
  component_subscribe($$self, page, ($$value) => $$invalidate(11, $page = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_debugData());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SuperDebug", slots, ["default"]);
  let styleInit = false;
  let { data } = $$props;
  let { display = true } = $$props;
  let { status = true } = $$props;
  let { label = "" } = $$props;
  let { stringTruncate = 120 } = $$props;
  let { ref = void 0 } = $$props;
  let { promise = false } = $$props;
  let { raw = false } = $$props;
  let { functions = false } = $$props;
  let { theme = "default" } = $$props;
  let { collapsible = false } = $$props;
  let { collapsed = false } = $$props;
  if (browser && collapsible) setCollapse();
  function setCollapse(status2 = void 0) {
    let data2;
    const route = $page.route.id ?? "";
    try {
      if (sessionStorage.SuperDebug) {
        data2 = JSON.parse(sessionStorage.SuperDebug);
      }
      data2 = {
        collapsed: data2 && data2.collapsed ? data2.collapsed : {}
      };
      data2.collapsed[route] = status2 === void 0 ? data2.collapsed[route] ?? collapsed : status2;
    } catch {
      data2 = { collapsed: { [route]: collapsed } };
    }
    if (status2 !== void 0) {
      sessionStorage.SuperDebug = JSON.stringify(data2);
    }
    $$invalidate(1, collapsed = data2.collapsed[route]);
  }
  let copied;
  async function copyContent(e) {
    if (!e.target) return;
    const parent = (
      /** @type {HTMLElement} */
      e.target.closest(".super-debug")
    );
    if (!parent) return;
    const codeEl = (
      /** @type {HTMLPreElement} */
      parent.querySelector(".super-debug--code")
    );
    if (!codeEl) return;
    clearTimeout(copied);
    await clipboardCopy(codeEl.innerText);
    $$invalidate(8, copied = setTimeout(() => $$invalidate(8, copied = void 0), 900));
  }
  function syntaxHighlight(json2) {
    switch (typeof json2) {
      case "function": {
        return `<span class="function">[function ${json2.name ?? "unnamed"}]</span>`;
      }
      case "symbol": {
        return `<span class="symbol">${json2.toString()}</span>`;
      }
    }
    const encodedString = JSON.stringify(
      json2,
      function(key, value) {
        if (value === void 0) {
          return "#}#undefined";
        }
        if (typeof this === "object" && this[key] instanceof Date) {
          return "#}D#" + (isNaN(this[key]) ? "Invalid Date" : value);
        }
        if (typeof value === "number") {
          if (value == Number.POSITIVE_INFINITY) return "#}#Inf";
          if (value == Number.NEGATIVE_INFINITY) return "#}#-Inf";
          if (isNaN(value)) return "#}#NaN";
        }
        if (typeof value === "bigint") {
          return "#}BI#" + value;
        }
        if (typeof value === "function" && functions) {
          return `#}F#[function ${value.name}]`;
        }
        if (value instanceof Error) {
          return `#}E#${value.name}: ${value.message || value.cause || "(No error message)"}`;
        }
        if (value instanceof Set) {
          return Array.from(value);
        }
        if (value instanceof Map) {
          return Array.from(value.entries());
        }
        if (browser && typeof this === "object" && this[key] instanceof File) {
          return fileToJSON(this[key]);
        }
        if (browser && typeof this === "object" && this[key] instanceof FileList) {
          const list = this[key];
          const output = [];
          for (let i = 0; i < list.length; i++) {
            const file2 = list.item(i);
            if (file2) output.push(fileToJSON(file2));
          }
          return output;
        }
        return value;
      },
      2
    ).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return encodedString.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)/g, function(match) {
      let cls = "number";
      if (/^"/.test(match)) {
        if (/:$/.test(match)) {
          cls = "key";
          match = match.slice(1, -2) + ":";
        } else {
          cls = "string";
          match = stringTruncate > 0 && match.length > stringTruncate ? match.slice(0, stringTruncate / 2) + `[..${match.length - stringTruncate}/${match.length}..]` + match.slice(-stringTruncate / 2) : match;
          if (match == '"#}#undefined"') {
            cls = "undefined";
            match = "undefined";
          } else if (match.startsWith('"#}D#')) {
            cls = "date";
            match = match.slice(5, -1);
          } else if (match == '"#}#NaN"') {
            cls = "nan";
            match = "NaN";
          } else if (match == '"#}#Inf"') {
            cls = "nan";
            match = "Infinity";
          } else if (match == '"#}#-Inf"') {
            cls = "nan";
            match = "-Infinity";
          } else if (match.startsWith('"#}BI#')) {
            cls = "bigint";
            match = match.slice(6, -1) + "n";
          } else if (match.startsWith('"#}F#')) {
            cls = "function";
            match = match.slice(5, -1);
          } else if (match.startsWith('"#}E#')) {
            cls = "error";
            match = match.slice(5, -1);
          }
        }
      } else if (/true|false/.test(match)) {
        cls = "boolean";
      } else if (/null/.test(match)) {
        cls = "null";
      }
      return '<span class="' + cls + '">' + match + "</span>";
    });
  }
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<SuperDebug> was created without expected prop 'data'");
    }
  });
  const writable_props = [
    "data",
    "display",
    "status",
    "label",
    "stringTruncate",
    "ref",
    "promise",
    "raw",
    "functions",
    "theme",
    "collapsible",
    "collapsed"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<SuperDebug> was created with unknown prop '${key}'`);
  });
  function pre_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const click_handler = () => setCollapse(!collapsed);
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(17, data = $$props2.data);
    if ("display" in $$props2) $$invalidate(2, display = $$props2.display);
    if ("status" in $$props2) $$invalidate(3, status = $$props2.status);
    if ("label" in $$props2) $$invalidate(4, label = $$props2.label);
    if ("stringTruncate" in $$props2) $$invalidate(18, stringTruncate = $$props2.stringTruncate);
    if ("ref" in $$props2) $$invalidate(0, ref = $$props2.ref);
    if ("promise" in $$props2) $$invalidate(5, promise = $$props2.promise);
    if ("raw" in $$props2) $$invalidate(6, raw = $$props2.raw);
    if ("functions" in $$props2) $$invalidate(19, functions = $$props2.functions);
    if ("theme" in $$props2) $$invalidate(20, theme = $$props2.theme);
    if ("collapsible" in $$props2) $$invalidate(7, collapsible = $$props2.collapsible);
    if ("collapsed" in $$props2) $$invalidate(1, collapsed = $$props2.collapsed);
    if ("$$scope" in $$props2) $$invalidate(21, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    makeError,
    copyClipboardApi,
    copyExecCommand,
    clipboardCopy,
    browser,
    page,
    readable,
    get: get_store_value,
    styleInit,
    data,
    display,
    status,
    label,
    stringTruncate,
    ref,
    promise,
    raw,
    functions,
    theme,
    collapsible,
    collapsed,
    setCollapse,
    copied,
    copyContent,
    fileToJSON,
    syntaxHighlight,
    assertPromise,
    assertStore,
    debugData,
    themeStyle,
    $page,
    $debugData
  });
  $$self.$inject_state = ($$props2) => {
    if ("styleInit" in $$props2) $$invalidate(13, styleInit = $$props2.styleInit);
    if ("data" in $$props2) $$invalidate(17, data = $$props2.data);
    if ("display" in $$props2) $$invalidate(2, display = $$props2.display);
    if ("status" in $$props2) $$invalidate(3, status = $$props2.status);
    if ("label" in $$props2) $$invalidate(4, label = $$props2.label);
    if ("stringTruncate" in $$props2) $$invalidate(18, stringTruncate = $$props2.stringTruncate);
    if ("ref" in $$props2) $$invalidate(0, ref = $$props2.ref);
    if ("promise" in $$props2) $$invalidate(5, promise = $$props2.promise);
    if ("raw" in $$props2) $$invalidate(6, raw = $$props2.raw);
    if ("functions" in $$props2) $$invalidate(19, functions = $$props2.functions);
    if ("theme" in $$props2) $$invalidate(20, theme = $$props2.theme);
    if ("collapsible" in $$props2) $$invalidate(7, collapsible = $$props2.collapsible);
    if ("collapsed" in $$props2) $$invalidate(1, collapsed = $$props2.collapsed);
    if ("copied" in $$props2) $$invalidate(8, copied = $$props2.copied);
    if ("debugData" in $$props2) $$subscribe_debugData($$invalidate(9, debugData = $$props2.debugData));
    if ("themeStyle" in $$props2) $$invalidate(10, themeStyle = $$props2.themeStyle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*theme*/
    1048576) {
      $: $$invalidate(10, themeStyle = theme === "vscode" ? `
      --sd-vscode-bg-color: #1f1f1f;
      --sd-vscode-label-color: #cccccc;
      --sd-vscode-code-default: #8c8a89;
      --sd-vscode-code-key: #9cdcfe;
      --sd-vscode-code-string: #ce9171;
      --sd-vscode-code-number: #b5c180;
      --sd-vscode-code-boolean: #4a9cd6;
      --sd-vscode-code-null: #4a9cd6;
      --sd-vscode-code-undefined: #4a9cd6;
      --sd-vscode-code-nan: #4a9cd6;
      --sd-vscode-code-symbol: #4de0c5;
      --sd-vscode-sb-thumb-color: #35373a;
      --sd-vscode-sb-thumb-color-focus: #4b4d50;
    ` : void 0);
    }
    if ($$self.$$.dirty & /*data, raw*/
    131136) {
      $: $$subscribe_debugData($$invalidate(9, debugData = assertStore(data, raw) ? data : readable(data)));
    }
  };
  return [
    ref,
    collapsed,
    display,
    status,
    label,
    promise,
    raw,
    collapsible,
    copied,
    debugData,
    themeStyle,
    $page,
    $debugData,
    styleInit,
    setCollapse,
    copyContent,
    syntaxHighlight,
    data,
    stringTruncate,
    functions,
    theme,
    $$scope,
    slots,
    pre_binding,
    click_handler
  ];
}
var SuperDebug = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      data: 17,
      display: 2,
      status: 3,
      label: 4,
      stringTruncate: 18,
      ref: 0,
      promise: 5,
      raw: 6,
      functions: 19,
      theme: 20,
      collapsible: 7,
      collapsed: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SuperDebug",
      options,
      id: create_fragment.name
    });
  }
  get data() {
    throw new Error_1("<SuperDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error_1("<SuperDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get display() {
    throw new Error_1("<SuperDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set display(value) {
    throw new Error_1("<SuperDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get status() {
    throw new Error_1("<SuperDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set status(value) {
    throw new Error_1("<SuperDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error_1("<SuperDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error_1("<SuperDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stringTruncate() {
    throw new Error_1("<SuperDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stringTruncate(value) {
    throw new Error_1("<SuperDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error_1("<SuperDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error_1("<SuperDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get promise() {
    throw new Error_1("<SuperDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set promise(value) {
    throw new Error_1("<SuperDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raw() {
    throw new Error_1("<SuperDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raw(value) {
    throw new Error_1("<SuperDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get functions() {
    throw new Error_1("<SuperDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set functions(value) {
    throw new Error_1("<SuperDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error_1("<SuperDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error_1("<SuperDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapsible() {
    throw new Error_1("<SuperDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collapsible(value) {
    throw new Error_1("<SuperDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapsed() {
    throw new Error_1("<SuperDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collapsed(value) {
    throw new Error_1("<SuperDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SuperDebug_default = SuperDebug;

// node_modules/sveltekit-superforms/dist/client/superForm.js
import { navigating, page as page2 } from "$app/stores";
import { browser as browser4 } from "$app/environment";
import { beforeNavigate, goto, invalidateAll } from "$app/navigation";

// node_modules/sveltekit-superforms/dist/client/flash.js
import { browser as browser2 } from "$app/environment";
function cancelFlash(options) {
  if (!options.flashMessage || !browser2)
    return;
  if (!shouldSyncFlash(options))
    return;
  document.cookie = `flash=; Max-Age=0; Path=${options.flashMessage.cookiePath ?? "/"};`;
}
function shouldSyncFlash(options) {
  if (!options.flashMessage || !browser2)
    return false;
  return options.syncFlashMessage;
}

// node_modules/sveltekit-superforms/dist/client/superForm.js
import { applyAction, deserialize, enhance as kitEnhance } from "$app/forms";

// node_modules/sveltekit-superforms/dist/client/customValidity.js
var noCustomValidityDataAttribute = "noCustomValidity";
async function updateCustomValidity(validityEl, errors) {
  if ("setCustomValidity" in validityEl) {
    validityEl.setCustomValidity("");
  }
  if (noCustomValidityDataAttribute in validityEl.dataset)
    return;
  setCustomValidity(validityEl, errors);
}
function setCustomValidityForm(formElement, errors) {
  for (const el of formElement.querySelectorAll("input,select,textarea,button")) {
    if ("dataset" in el && noCustomValidityDataAttribute in el.dataset || !el.name) {
      continue;
    }
    const path = traversePath(errors, splitPath(el.name));
    const error = path && typeof path.value === "object" && "_errors" in path.value ? path.value._errors : path == null ? void 0 : path.value;
    setCustomValidity(el, error);
    if (error)
      return;
  }
}
function setCustomValidity(el, errors) {
  const message2 = errors && errors.length ? errors.join("\n") : "";
  el.setCustomValidity(message2);
  if (message2)
    el.reportValidity();
}

// node_modules/sveltekit-superforms/dist/client/elements.js
var isElementInViewport = (el, topOffset = 0) => {
  const rect = el.getBoundingClientRect();
  return rect.top >= topOffset && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
};
var scrollToAndCenter = (el, offset = 1.125, behavior = "smooth") => {
  const elementRect = el.getBoundingClientRect();
  const absoluteElementTop = elementRect.top + window.pageYOffset;
  const top = absoluteElementTop - window.innerHeight / (2 * offset);
  window.scrollTo({ left: 0, top, behavior });
};
var immediateInputTypes = ["checkbox", "radio", "range", "file"];
function inputInfo(el) {
  const immediate = !!el && (el instanceof HTMLSelectElement || el instanceof HTMLInputElement && immediateInputTypes.includes(el.type));
  const multiple = !!el && el instanceof HTMLSelectElement && el.multiple;
  const file2 = !!el && el instanceof HTMLInputElement && el.type == "file";
  return { immediate, multiple, file: file2 };
}

// node_modules/sveltekit-superforms/dist/client/form.js
var FetchStatus;
(function(FetchStatus2) {
  FetchStatus2[FetchStatus2["Idle"] = 0] = "Idle";
  FetchStatus2[FetchStatus2["Submitting"] = 1] = "Submitting";
  FetchStatus2[FetchStatus2["Delayed"] = 2] = "Delayed";
  FetchStatus2[FetchStatus2["Timeout"] = 3] = "Timeout";
})(FetchStatus || (FetchStatus = {}));
var activeTimers = /* @__PURE__ */ new Set();
function Form(formElement, timers, options) {
  let state = FetchStatus.Idle;
  let delayedTimeout, timeoutTimeout;
  const Timers = activeTimers;
  function Timers_start() {
    Timers_clear();
    Timers_setState(state != FetchStatus.Delayed ? FetchStatus.Submitting : FetchStatus.Delayed);
    delayedTimeout = window.setTimeout(() => {
      if (delayedTimeout && state == FetchStatus.Submitting)
        Timers_setState(FetchStatus.Delayed);
    }, options.delayMs);
    timeoutTimeout = window.setTimeout(() => {
      if (timeoutTimeout && state == FetchStatus.Delayed)
        Timers_setState(FetchStatus.Timeout);
    }, options.timeoutMs);
    Timers.add(Timers_clear);
  }
  function Timers_clear() {
    clearTimeout(delayedTimeout);
    clearTimeout(timeoutTimeout);
    delayedTimeout = timeoutTimeout = 0;
    Timers.delete(Timers_clear);
    Timers_setState(FetchStatus.Idle);
  }
  function Timers_clearAll() {
    Timers.forEach((t) => t());
    Timers.clear();
  }
  function Timers_setState(s) {
    state = s;
    timers.submitting.set(state >= FetchStatus.Submitting);
    timers.delayed.set(state >= FetchStatus.Delayed);
    timers.timeout.set(state >= FetchStatus.Timeout);
  }
  const ErrorTextEvents = formElement;
  function ErrorTextEvents__selectText(e) {
    const target = e.target;
    if (options.selectErrorText)
      target.select();
  }
  function ErrorTextEvents_addErrorTextListeners() {
    if (!options.selectErrorText)
      return;
    ErrorTextEvents.querySelectorAll("input").forEach((el) => {
      el.addEventListener("invalid", ErrorTextEvents__selectText);
    });
  }
  function ErrorTextEvents_removeErrorTextListeners() {
    if (!options.selectErrorText)
      return;
    ErrorTextEvents.querySelectorAll("input").forEach((el) => el.removeEventListener("invalid", ErrorTextEvents__selectText));
  }
  const Form2 = formElement;
  {
    ErrorTextEvents_addErrorTextListeners();
    const completed = (opts) => {
      if (!opts.clearAll)
        Timers_clear();
      else
        Timers_clearAll();
      if (!opts.cancelled)
        setTimeout(() => scrollToFirstError(Form2, options), 1);
    };
    onDestroy(() => {
      ErrorTextEvents_removeErrorTextListeners();
      completed({ cancelled: true });
    });
    return {
      submitting() {
        Timers_start();
      },
      completed,
      scrollToFirstError() {
        setTimeout(() => scrollToFirstError(Form2, options), 1);
      },
      isSubmitting: () => state === FetchStatus.Submitting || state === FetchStatus.Delayed
    };
  }
}
var scrollToFirstError = async (Form2, options) => {
  if (options.scrollToError == "off")
    return;
  const selector = options.errorSelector;
  if (!selector)
    return;
  await tick();
  let el;
  el = Form2.querySelector(selector);
  if (!el)
    return;
  el = el.querySelector(selector) ?? el;
  const nav = options.stickyNavbar ? document.querySelector(options.stickyNavbar) : null;
  if (typeof options.scrollToError != "string") {
    el.scrollIntoView(options.scrollToError);
  } else if (!isElementInViewport(el, (nav == null ? void 0 : nav.offsetHeight) ?? 0)) {
    scrollToAndCenter(el, void 0, options.scrollToError);
  }
  function Form_shouldAutoFocus(userAgent) {
    if (typeof options.autoFocusOnError === "boolean")
      return options.autoFocusOnError;
    else
      return !/iPhone|iPad|iPod|Android/i.test(userAgent);
  }
  if (!Form_shouldAutoFocus(navigator.userAgent))
    return;
  let focusEl;
  focusEl = el;
  if (!["INPUT", "SELECT", "BUTTON", "TEXTAREA"].includes(focusEl.tagName)) {
    focusEl = focusEl.querySelector('input:not([type="hidden"]):not(.flatpickr-input), select, textarea');
  }
  if (focusEl) {
    try {
      focusEl.focus({ preventScroll: true });
      if (options.selectErrorText && focusEl.tagName == "INPUT") {
        focusEl.select();
      }
    } catch (err) {
    }
  }
};

// node_modules/sveltekit-superforms/dist/client/proxies.js
import { browser as browser3 } from "$app/environment";
var defaultOptions = {
  trueStringValue: "true",
  dateFormat: "iso"
};
function booleanProxy(form, path, options) {
  return _stringProxy(form, path, "boolean", {
    ...defaultOptions,
    ...options
  });
}
function intProxy(form, path, options) {
  return _stringProxy(form, path, "int", {
    ...defaultOptions,
    ...options
  });
}
function numberProxy(form, path, options) {
  return _stringProxy(form, path, "number", {
    ...defaultOptions,
    ...options
  });
}
function dateProxy(form, path, options) {
  return _stringProxy(form, path, "date", {
    ...defaultOptions,
    dateFormat: (options == null ? void 0 : options.format) ?? "iso",
    empty: options == null ? void 0 : options.empty
  });
}
function stringProxy(form, path, options) {
  return _stringProxy(form, path, "string", {
    ...defaultOptions,
    ...options
  });
}
function fileFieldProxy(form, path, options) {
  const fileField = fileProxy(form, path, options);
  const formField = formFieldProxy(form, path, options);
  return { ...formField, value: fileField };
}
function fileProxy(form, path, options) {
  const formFile = fieldProxy(form, path, options);
  const fileProxy2 = writable(browser3 ? new DataTransfer().files : {});
  let initialized = false;
  let initialValue;
  formFile.subscribe((file2) => {
    if (!browser3)
      return;
    if (!initialized) {
      initialValue = (options == null ? void 0 : options.empty) ? options.empty === "undefined" ? void 0 : null : file2;
      initialized = true;
    }
    const dt = new DataTransfer();
    if (file2 instanceof File)
      dt.items.add(file2);
    fileProxy2.set(dt.files);
  });
  const fileStore = {
    subscribe(run) {
      return fileProxy2.subscribe(run);
    },
    set(file2) {
      if (!browser3)
        return;
      if (!file2) {
        const dt = new DataTransfer();
        fileProxy2.set(dt.files);
        formFile.set(file2);
      } else if (file2 instanceof File) {
        const dt = new DataTransfer();
        dt.items.add(file2);
        fileProxy2.set(dt.files);
        formFile.set(file2);
      } else if (file2 instanceof FileList) {
        fileProxy2.set(file2);
        if (file2.length > 0)
          formFile.set(file2.item(0));
        else
          formFile.set(initialValue);
      }
    },
    update() {
      throw new SuperFormError("You cannot update a fileProxy, only set it.");
    }
  };
  return fileStore;
}
function filesFieldProxy(form, path, options) {
  const filesStore = filesProxy(form, path, options);
  const arrayField = arrayProxy(form, path, options);
  return { ...arrayField, values: filesStore };
}
function filesProxy(form, path, options) {
  const formFiles = fieldProxy(form, path, options);
  const filesProxy2 = writable(browser3 ? new DataTransfer().files : {});
  formFiles.subscribe((files) => {
    if (!browser3)
      return;
    const dt = new DataTransfer();
    if (Array.isArray(files)) {
      if (files.length && files.every((f) => !f)) {
        formFiles.set([]);
        return;
      }
      files.filter((f) => f instanceof File).forEach((file2) => dt.items.add(file2));
    }
    filesProxy2.set(dt.files);
  });
  const filesStore = {
    subscribe(run) {
      return filesProxy2.subscribe(run);
    },
    set(files) {
      if (!browser3)
        return;
      if (!(files instanceof FileList)) {
        const dt = new DataTransfer();
        if (Array.isArray(files))
          files.forEach((file2) => {
            if (file2 instanceof File)
              dt.items.add(file2);
          });
        filesProxy2.set(dt.files);
        formFiles.set(files);
      } else {
        const output = [];
        for (let i = 0; i < files.length; i++) {
          const file2 = files.item(i);
          if (file2)
            output.push(file2);
        }
        filesProxy2.set(files);
        formFiles.set(output);
      }
    },
    update(updater) {
      filesStore.set(updater(get_store_value(formFiles)));
    }
  };
  return filesStore;
}
function _stringProxy(form, path, type, options) {
  function toValue(value) {
    if (!value && options.empty !== void 0) {
      return options.empty === "null" ? null : options.empty === "zero" ? 0 : void 0;
    }
    if (typeof value === "number") {
      value = value.toString();
    }
    if (typeof value !== "string") {
      value = "";
    }
    const stringValue = value;
    if (type == "string")
      return stringValue;
    else if (type == "boolean")
      return !!stringValue;
    else if (type == "date")
      return new Date(stringValue);
    const numberToConvert = options.delimiter ? stringValue.replace(options.delimiter, ".") : stringValue;
    let num;
    if (numberToConvert === "" && options.empty == "zero")
      num = 0;
    else if (type == "number")
      num = parseFloat(numberToConvert);
    else
      num = parseInt(numberToConvert, 10);
    return num;
  }
  const isSuper = isSuperForm(form, options);
  const realProxy = isSuper ? superFieldProxy(form, path, { taint: options.taint }) : fieldProxy(form, path);
  let updatedValue = null;
  let initialized = false;
  const proxy = derived(realProxy, (value) => {
    if (!initialized) {
      initialized = true;
      if (options.initiallyEmptyIfZero && !value)
        return "";
    }
    if (updatedValue !== null) {
      const current = updatedValue;
      updatedValue = null;
      return current;
    }
    if (value === void 0 || value === null)
      return "";
    if (type == "string") {
      return value;
    } else if (type == "int" || type == "number") {
      if (value === "") {
        realProxy.set(0, isSuper ? { taint: false } : void 0);
      }
      if (typeof value === "number" && isNaN(value))
        return "";
      return String(value);
    } else if (type == "date") {
      const date = value;
      if (isNaN(date))
        return "";
      switch (options.dateFormat) {
        case "iso":
          return date.toISOString();
        case "date":
          return date.toISOString().slice(0, 10);
        case "datetime":
          return date.toISOString().slice(0, 16);
        case "time":
          return date.toISOString().slice(11, 16);
        case "date-utc":
          return UTCDate(date);
        case "datetime-utc":
          return UTCDate(date) + "T" + UTCTime(date);
        case "time-utc":
          return UTCTime(date);
        case "date-local":
          return localDate(date);
        case "datetime-local":
          return localDate(date) + "T" + localTime(date);
        case "time-local":
          return localTime(date);
      }
    } else {
      return value ? options.trueStringValue : "";
    }
  });
  return {
    subscribe: proxy.subscribe,
    set(val) {
      updatedValue = val;
      const newValue = toValue(updatedValue);
      realProxy.set(newValue);
    },
    update(updater) {
      realProxy.update((f) => {
        updatedValue = updater(String(f));
        const newValue = toValue(updatedValue);
        return newValue;
      });
    }
  };
}
function arrayProxy(superForm2, path, options) {
  const formErrors = fieldProxy(superForm2.errors, `${path}`);
  const onlyFieldErrors = derived(formErrors, ($errors) => {
    const output = [];
    for (const key in $errors) {
      if (key == "_errors")
        continue;
      output[key] = $errors[key];
    }
    return output;
  });
  function updateArrayErrors(errors, value) {
    for (const key in errors) {
      if (key == "_errors")
        continue;
      errors[key] = void 0;
    }
    if (value !== void 0) {
      for (const key in value) {
        errors[key] = value[key];
      }
    }
    return errors;
  }
  const fieldErrors = {
    subscribe: onlyFieldErrors.subscribe,
    update(upd) {
      formErrors.update(($errors) => (
        // @ts-expect-error Type is correct
        updateArrayErrors($errors, upd($errors))
      ));
    },
    set(value) {
      formErrors.update(($errors) => updateArrayErrors($errors, value));
    }
  };
  const values = superFieldProxy(superForm2, path, options);
  let lastLength = Array.isArray(get_store_value(values)) ? get_store_value(values).length : 0;
  values.subscribe(($values) => {
    const currentLength = Array.isArray($values) ? $values.length : 0;
    if (currentLength < lastLength) {
      superForm2.errors.update(($errors) => {
        const node = pathExists($errors, splitPath(path));
        if (!node)
          return $errors;
        for (const key in node.value) {
          if (Number(key) < currentLength)
            continue;
          delete node.value[key];
        }
        return $errors;
      }, { force: true });
    }
    lastLength = currentLength;
  });
  return {
    path,
    values,
    errors: fieldProxy(superForm2.errors, `${path}._errors`),
    valueErrors: fieldErrors
  };
}
function formFieldProxy(superForm2, path, options) {
  const path2 = splitPath(path);
  const constraintsPath = path2.filter((p) => /\D/.test(String(p))).join(".");
  const taintedProxy = derived(superForm2.tainted, ($tainted) => {
    if (!$tainted)
      return $tainted;
    const taintedPath = traversePath($tainted, path2);
    return taintedPath ? taintedPath.value : void 0;
  });
  const tainted = {
    subscribe: taintedProxy.subscribe,
    update(upd) {
      superForm2.tainted.update(($tainted) => {
        if (!$tainted)
          $tainted = {};
        const output = traversePath($tainted, path2, (path3) => {
          if (!path3.value)
            path3.parent[path3.key] = {};
          return path3.parent[path3.key];
        });
        if (output)
          output.parent[output.key] = upd(output.value);
        return $tainted;
      });
    },
    set(value) {
      superForm2.tainted.update(($tainted) => {
        if (!$tainted)
          $tainted = {};
        const output = traversePath($tainted, path2, (path3) => {
          if (!path3.value)
            path3.parent[path3.key] = {};
          return path3.parent[path3.key];
        });
        if (output)
          output.parent[output.key] = value;
        return $tainted;
      });
    }
  };
  return {
    path,
    value: superFieldProxy(superForm2, path, options),
    errors: fieldProxy(superForm2.errors, path),
    constraints: fieldProxy(superForm2.constraints, constraintsPath),
    tainted
  };
}
function updateProxyField(obj, path, updater) {
  const output = traversePath(obj, path, ({ parent, key, value }) => {
    if (value === void 0)
      parent[key] = /\D/.test(key) ? {} : [];
    return parent[key];
  });
  if (output) {
    const newValue = updater(output.value);
    output.parent[output.key] = newValue;
  }
  return obj;
}
function superFieldProxy(superForm2, path, baseOptions) {
  const form = superForm2.form;
  const path2 = splitPath(path);
  const proxy = derived(form, ($form) => {
    const data = traversePath($form, path2);
    return data == null ? void 0 : data.value;
  });
  return {
    subscribe(...params) {
      const unsub = proxy.subscribe(...params);
      return () => unsub();
    },
    update(upd, options) {
      form.update((data) => updateProxyField(data, path2, upd), options ?? baseOptions);
    },
    set(value, options) {
      form.update((data) => updateProxyField(data, path2, () => value), options ?? baseOptions);
    }
  };
}
function isSuperForm(form, options) {
  const isSuperForm2 = "form" in form;
  if (!isSuperForm2 && (options == null ? void 0 : options.taint) !== void 0) {
    throw new SuperFormError("If options.taint is set, the whole superForm object must be used as a proxy.");
  }
  return isSuperForm2;
}
function fieldProxy(form, path, options) {
  const path2 = splitPath(path);
  if (isSuperForm(form, options)) {
    return superFieldProxy(form, path, options);
  }
  const proxy = derived(form, ($form) => {
    const data = traversePath($form, path2);
    return data == null ? void 0 : data.value;
  });
  return {
    subscribe(...params) {
      const unsub = proxy.subscribe(...params);
      return () => unsub();
    },
    update(upd) {
      form.update((data) => updateProxyField(data, path2, upd));
    },
    set(value) {
      form.update((data) => updateProxyField(data, path2, () => value));
    }
  };
}
function localDate(date) {
  return date.getFullYear() + "-" + String(date.getMonth() + 1).padStart(2, "0") + "-" + String(date.getDate()).padStart(2, "0");
}
function localTime(date) {
  return String(date.getHours()).padStart(2, "0") + ":" + String(date.getMinutes()).padStart(2, "0");
}
function UTCDate(date) {
  return date.getUTCFullYear() + "-" + String(date.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date.getUTCDate()).padStart(2, "0");
}
function UTCTime(date) {
  return String(date.getUTCHours()).padStart(2, "0") + ":" + String(date.getUTCMinutes()).padStart(2, "0");
}

// node_modules/sveltekit-superforms/dist/client/superForm.js
var formIds = /* @__PURE__ */ new WeakMap();
var initialForms = /* @__PURE__ */ new WeakMap();
var defaultOnError = (event) => {
  console.warn("Unhandled error caught by Superforms, use onError event to handle it:", event.result.error);
};
var defaultFormOptions = {
  applyAction: true,
  invalidateAll: true,
  resetForm: true,
  autoFocusOnError: "detect",
  scrollToError: "smooth",
  errorSelector: '[aria-invalid="true"],[data-invalid]',
  selectErrorText: false,
  stickyNavbar: void 0,
  taintedMessage: false,
  onSubmit: void 0,
  onResult: void 0,
  onUpdate: void 0,
  onUpdated: void 0,
  onError: defaultOnError,
  dataType: "form",
  validators: void 0,
  customValidity: false,
  clearOnSubmit: "message",
  delayMs: 500,
  timeoutMs: 8e3,
  multipleSubmits: "prevent",
  SPA: void 0,
  validationMethod: "auto"
};
function multipleFormIdError(id) {
  return `Duplicate form id's found: "${id}". Multiple forms will receive the same data. Use the id option to differentiate between them, or if this is intended, set the warnings.duplicateId option to false in superForm to disable this warning. More information: https://superforms.rocks/concepts/multiple-forms`;
}
var LEGACY_MODE = false;
try {
  if (SUPERFORMS_LEGACY)
    LEGACY_MODE = true;
} catch {
}
var STORYBOOK_MODE = false;
try {
  if (globalThis.STORIES)
    STORYBOOK_MODE = true;
} catch {
}
function superForm(form, formOptions) {
  var _a;
  let initialForm;
  let options = formOptions ?? {};
  let initialValidator = void 0;
  {
    if (options.legacy ?? LEGACY_MODE) {
      if (options.resetForm === void 0)
        options.resetForm = false;
      if (options.taintedMessage === void 0)
        options.taintedMessage = true;
    }
    if (STORYBOOK_MODE) {
      if (options.applyAction === void 0)
        options.applyAction = false;
    }
    if (typeof options.SPA === "string") {
      if (options.invalidateAll === void 0)
        options.invalidateAll = false;
      if (options.applyAction === void 0)
        options.applyAction = false;
    }
    initialValidator = options.validators;
    options = {
      ...defaultFormOptions,
      ...options
    };
    if ((options.SPA === true || typeof options.SPA === "object") && options.validators === void 0) {
      console.warn("No validators set for superForm in SPA mode. Add a validation adapter to the validators option, or set it to false to disable this warning.");
    }
    if (!form) {
      throw new SuperFormError("No form data sent to superForm. Make sure the output from superValidate is used (usually data.form) and that it's not null or undefined. Alternatively, an object with default values for the form can also be used, but then constraints won't be available.");
    }
    if (Context_isValidationObject(form) === false) {
      form = {
        id: options.id ?? Math.random().toString(36).slice(2, 10),
        valid: false,
        posted: false,
        errors: {},
        data: form,
        shape: shapeFromObject(form)
      };
    }
    form = form;
    const _initialFormId = form.id = options.id ?? form.id;
    const _currentPage = get_store_value(page2) ?? (STORYBOOK_MODE ? {} : void 0);
    if (browser4 && ((_a = options.warnings) == null ? void 0 : _a.duplicateId) !== false) {
      if (!formIds.has(_currentPage)) {
        formIds.set(_currentPage, /* @__PURE__ */ new Set([_initialFormId]));
      } else {
        const currentForms = formIds.get(_currentPage);
        if (currentForms == null ? void 0 : currentForms.has(_initialFormId)) {
          console.warn(multipleFormIdError(_initialFormId));
        } else {
          currentForms == null ? void 0 : currentForms.add(_initialFormId);
        }
      }
    }
    if (!initialForms.has(form)) {
      initialForms.set(form, form);
    }
    initialForm = initialForms.get(form);
    if (!browser4 && _currentPage.form && typeof _currentPage.form === "object") {
      const postedData = _currentPage.form;
      for (const postedForm of Context_findValidationForms(postedData).reverse()) {
        if (postedForm.id == _initialFormId && !initialForms.has(postedForm)) {
          initialForms.set(postedData, postedData);
          const pageDataForm = form;
          form = postedForm;
          form.constraints = pageDataForm.constraints;
          form.shape = pageDataForm.shape;
          if (form.valid && options.resetForm && (options.resetForm === true || options.resetForm())) {
            form = clone(pageDataForm);
            form.message = clone(postedForm.message);
          }
          break;
        }
      }
    } else {
      form = clone(initialForm);
    }
    onDestroy(() => {
      var _a2;
      Unsubscriptions_unsubscribe();
      NextChange_clear();
      EnhancedForm_destroy();
      for (const events of Object.values(formEvents)) {
        events.length = 0;
      }
      (_a2 = formIds.get(_currentPage)) == null ? void 0 : _a2.delete(_initialFormId);
    });
    if (options.dataType !== "json") {
      const checkForNestedData = (key, value) => {
        if (!value || typeof value !== "object")
          return;
        if (Array.isArray(value)) {
          if (value.length > 0)
            checkForNestedData(key, value[0]);
        } else if (!(value instanceof Date) && !(value instanceof File) && (!browser4 || !(value instanceof FileList))) {
          throw new SuperFormError(`Object found in form field "${key}". Set the dataType option to "json" and add use:enhance to use nested data structures. More information: https://superforms.rocks/concepts/nested-data`);
        }
      };
      for (const [key, value] of Object.entries(form.data)) {
        checkForNestedData(key, value);
      }
    }
  }
  const __data = {
    formId: form.id,
    form: clone(form.data),
    constraints: form.constraints ?? {},
    posted: form.posted,
    errors: clone(form.errors),
    message: clone(form.message),
    tainted: void 0,
    valid: form.valid,
    submitting: false,
    shape: form.shape
  };
  const Data = __data;
  const FormId = writable(options.id ?? form.id);
  const Context = {};
  function Context_findValidationForms(data) {
    const forms = Object.values(data).filter((v) => Context_isValidationObject(v) !== false);
    return forms;
  }
  function Context_isValidationObject(object) {
    if (!object || typeof object !== "object")
      return false;
    if (!("valid" in object && "errors" in object && typeof object.valid === "boolean")) {
      return false;
    }
    return "id" in object && typeof object.id === "string" ? object.id : false;
  }
  const _formData = writable(form.data);
  const Form2 = {
    subscribe: _formData.subscribe,
    set: (value, options2 = {}) => {
      const newData = clone(value);
      Tainted_update(newData, options2.taint ?? true);
      return _formData.set(newData);
    },
    update: (updater, options2 = {}) => {
      return _formData.update((value) => {
        const newData = updater(value);
        Tainted_update(newData, options2.taint ?? true);
        return newData;
      });
    }
  };
  function Form_isSPA() {
    return options.SPA === true || typeof options.SPA === "object";
  }
  async function Form_validate(opts = {}) {
    const dataToValidate = opts.formData ?? Data.form;
    let errors = {};
    let status;
    const validator = opts.adapter ?? options.validators;
    if (typeof validator == "object") {
      if (validator != initialValidator && !("jsonSchema" in validator)) {
        throw new SuperFormError('Client validation adapter found in options.validators. A full adapter must be used when changing validators dynamically, for example "zod" instead of "zodClient".');
      }
      status = await validator.validate(dataToValidate);
      if (!status.success) {
        errors = mapErrors(status.issues, validator.shape ?? Data.shape ?? {});
      } else if (opts.recheckValidData !== false) {
        return Form_validate({ ...opts, recheckValidData: false });
      }
    } else {
      status = { success: true, data: {} };
    }
    const data = { ...Data.form, ...dataToValidate, ...status.success ? status.data : {} };
    return {
      valid: status.success,
      posted: false,
      errors,
      data,
      constraints: Data.constraints,
      message: void 0,
      id: Data.formId,
      shape: Data.shape
    };
  }
  function Form__changeEvent(event) {
    if (!options.onChange || !event.paths.length || event.type == "blur")
      return;
    let changeEvent;
    const paths = event.paths.map(mergePath);
    if (event.type && event.paths.length == 1 && event.formElement && event.target instanceof Element) {
      changeEvent = {
        path: paths[0],
        paths,
        formElement: event.formElement,
        target: event.target,
        set(path, value, options2) {
          fieldProxy({ form: Form2 }, path, options2).set(value);
        },
        get(path) {
          return get_store_value(fieldProxy(Form2, path));
        }
      };
    } else {
      changeEvent = {
        paths,
        target: void 0,
        set(path, value, options2) {
          fieldProxy({ form: Form2 }, path, options2).set(value);
        },
        get(path) {
          return get_store_value(fieldProxy(Form2, path));
        }
      };
    }
    options.onChange(changeEvent);
  }
  async function Form_clientValidation(event, force = false, adapter) {
    if (event) {
      if (options.validators == "clear") {
        Errors.update(($errors) => {
          setPaths($errors, event.paths, void 0);
          return $errors;
        });
      }
      setTimeout(() => Form__changeEvent(event));
    }
    let skipValidation = false;
    if (!force) {
      if (options.validationMethod == "onsubmit" || options.validationMethod == "submit-only") {
        skipValidation = true;
      } else if (options.validationMethod == "onblur" && (event == null ? void 0 : event.type) == "input")
        skipValidation = true;
      else if (options.validationMethod == "oninput" && (event == null ? void 0 : event.type) == "blur")
        skipValidation = true;
    }
    if (skipValidation || !event || !options.validators || options.validators == "clear") {
      if (event == null ? void 0 : event.paths) {
        const formElement = (event == null ? void 0 : event.formElement) ?? EnhancedForm_get();
        if (formElement)
          Form__clearCustomValidity(formElement);
      }
      return;
    }
    const result = await Form_validate({ adapter });
    if (result.valid && (event.immediate || event.type != "input")) {
      Form2.set(result.data, { taint: "ignore" });
    }
    await tick();
    Form__displayNewErrors(result.errors, event, force);
    return result;
  }
  function Form__clearCustomValidity(formElement) {
    const validity = /* @__PURE__ */ new Map();
    if (options.customValidity && formElement) {
      for (const el of formElement.querySelectorAll(`[name]`)) {
        if (typeof el.name !== "string" || !el.name.length)
          continue;
        const message2 = "validationMessage" in el ? String(el.validationMessage) : "";
        validity.set(el.name, { el, message: message2 });
        updateCustomValidity(el, void 0);
      }
    }
    return validity;
  }
  async function Form__displayNewErrors(errors, event, force) {
    const { type, immediate, multiple, paths } = event;
    const previous = Data.errors;
    const output = {};
    let validity = /* @__PURE__ */ new Map();
    const formElement = event.formElement ?? EnhancedForm_get();
    if (formElement)
      validity = Form__clearCustomValidity(formElement);
    traversePaths(errors, (error) => {
      if (!Array.isArray(error.value))
        return;
      const currentPath = [...error.path];
      if (currentPath[currentPath.length - 1] == "_errors") {
        currentPath.pop();
      }
      const joinedPath = currentPath.join(".");
      function addError() {
        setPaths(output, [error.path], error.value);
        if (options.customValidity && isEventError && validity.has(joinedPath)) {
          const { el, message: message2 } = validity.get(joinedPath);
          if (message2 != error.value) {
            setTimeout(() => updateCustomValidity(el, error.value));
            validity.clear();
          }
        }
      }
      if (force)
        return addError();
      const lastPath = error.path[error.path.length - 1];
      const isObjectError = lastPath == "_errors";
      const isEventError = error.value && paths.some((path) => {
        return isObjectError ? currentPath && path && currentPath.length > 0 && currentPath[0] == path[0] : joinedPath == path.join(".");
      });
      if (isEventError && options.validationMethod == "oninput")
        return addError();
      if (immediate && !multiple && isEventError)
        return addError();
      if (multiple) {
        const errorPath = pathExists(get_store_value(Errors), error.path.slice(0, -1));
        if ((errorPath == null ? void 0 : errorPath.value) && typeof (errorPath == null ? void 0 : errorPath.value) == "object") {
          for (const errors2 of Object.values(errorPath.value)) {
            if (Array.isArray(errors2)) {
              return addError();
            }
          }
        }
      }
      const previousError = pathExists(previous, error.path);
      if (previousError && previousError.key in previousError.parent) {
        return addError();
      }
      if (isObjectError) {
        if (options.validationMethod == "oninput" || type == "blur" && Tainted_hasBeenTainted(mergePath(error.path.slice(0, -1)))) {
          return addError();
        }
      } else {
        if (type == "blur" && isEventError) {
          return addError();
        }
      }
    });
    Errors.set(output);
  }
  function Form_set(data, options2 = {}) {
    if (options2.keepFiles) {
      traversePaths(Data.form, (info) => {
        if ((!browser4 || !(info.parent instanceof FileList)) && (info.value instanceof File || browser4 && info.value instanceof FileList)) {
          const dataPath = pathExists(data, info.path);
          if (!dataPath || !(dataPath.key in dataPath.parent)) {
            setPaths(data, [info.path], info.value);
          }
        }
      });
    }
    return Form2.set(data, options2);
  }
  function Form_shouldReset(validForm, successActionResult) {
    return validForm && successActionResult && options.resetForm && (options.resetForm === true || options.resetForm());
  }
  async function Form_updateFromValidation(form2, successResult) {
    if (form2.valid && successResult && Form_shouldReset(form2.valid, successResult)) {
      Form_reset({ message: form2.message, posted: true });
    } else {
      rebind({
        form: form2,
        untaint: successResult,
        keepFiles: true,
        // Check if the form data should be used for updating, or if the invalidateAll load function should be used:
        skipFormData: options.invalidateAll == "force"
      });
    }
    if (formEvents.onUpdated.length) {
      await tick();
    }
    for (const event of formEvents.onUpdated) {
      event({ form: form2 });
    }
  }
  function Form_reset(opts = {}) {
    if (opts.newState)
      initialForm.data = { ...initialForm.data, ...opts.newState };
    const resetData = clone(initialForm);
    resetData.data = { ...resetData.data, ...opts.data };
    if (opts.id !== void 0)
      resetData.id = opts.id;
    rebind({
      form: resetData,
      untaint: true,
      message: opts.message,
      keepFiles: false,
      posted: opts.posted,
      resetted: true
    });
  }
  async function Form_updateFromActionResult(result) {
    if (result.type == "error") {
      throw new SuperFormError(`ActionResult of type "${result.type}" cannot be passed to update function.`);
    }
    if (result.type == "redirect") {
      if (Form_shouldReset(true, true))
        Form_reset({ posted: true });
      return;
    }
    if (typeof result.data !== "object") {
      throw new SuperFormError("Non-object validation data returned from ActionResult.");
    }
    const forms = Context_findValidationForms(result.data);
    if (!forms.length) {
      throw new SuperFormError("No form data returned from ActionResult. Make sure you return { form } in the form actions.");
    }
    for (const newForm of forms) {
      if (newForm.id !== Data.formId)
        continue;
      await Form_updateFromValidation(newForm, result.status >= 200 && result.status < 300);
    }
  }
  const Message = writable(__data.message);
  const Constraints = writable(__data.constraints);
  const Posted = writable(__data.posted);
  const Shape = writable(__data.shape);
  const _errors = writable(form.errors);
  const Errors = {
    subscribe: _errors.subscribe,
    set(value, options2) {
      return _errors.set(updateErrors(value, Data.errors, options2 == null ? void 0 : options2.force));
    },
    update(updater, options2) {
      return _errors.update((value) => {
        return updateErrors(updater(value), Data.errors, options2 == null ? void 0 : options2.force);
      });
    },
    /**
     * To work with client-side validation, errors cannot be deleted but must
     * be set to undefined, to know where they existed before (tainted+error check in oninput)
     */
    clear: () => Errors.set({})
  };
  let NextChange = null;
  function NextChange_setHtmlEvent(event) {
    var _a2;
    if (NextChange && event && Object.keys(event).length == 1 && ((_a2 = event.paths) == null ? void 0 : _a2.length) && NextChange.target && NextChange.target instanceof HTMLInputElement && NextChange.target.type.toLowerCase() == "file") {
      NextChange.paths = event.paths;
    } else {
      NextChange = event;
    }
    setTimeout(() => {
      Form_clientValidation(NextChange);
    }, 0);
  }
  function NextChange_additionalEventInformation(event, immediate, multiple, formElement, target) {
    if (NextChange === null) {
      NextChange = { paths: [] };
    }
    NextChange.type = event;
    NextChange.immediate = immediate;
    NextChange.multiple = multiple;
    NextChange.formElement = formElement;
    NextChange.target = target;
  }
  function NextChange_paths() {
    return (NextChange == null ? void 0 : NextChange.paths) ?? [];
  }
  function NextChange_clear() {
    NextChange = null;
  }
  const Tainted = {
    defaultMessage: "Leave page? Changes that you made may not be saved.",
    state: writable(),
    message: options.taintedMessage,
    clean: clone(form.data),
    // Important to clone form.data, so it's not comparing the same object,
    forceRedirection: false
  };
  function Tainted_isEnabled() {
    return options.taintedMessage && !Data.submitting && !Tainted.forceRedirection && Tainted_isTainted();
  }
  function Tainted_checkUnload(e) {
    if (!Tainted_isEnabled())
      return;
    e.preventDefault();
    e.returnValue = "";
    const { taintedMessage } = options;
    const isTaintedFunction = typeof taintedMessage === "function";
    const confirmationMessage = isTaintedFunction || taintedMessage === true ? Tainted.defaultMessage : taintedMessage;
    (e || window.event).returnValue = confirmationMessage || Tainted.defaultMessage;
    return confirmationMessage;
  }
  async function Tainted_beforeNav(nav) {
    if (!Tainted_isEnabled())
      return;
    const { taintedMessage } = options;
    const isTaintedFunction = typeof taintedMessage === "function";
    if (isTaintedFunction)
      nav.cancel();
    if (nav.type === "leave") {
      return;
    }
    const message2 = isTaintedFunction || taintedMessage === true ? Tainted.defaultMessage : taintedMessage;
    let shouldRedirect;
    try {
      shouldRedirect = isTaintedFunction ? await taintedMessage() : window.confirm(message2 || Tainted.defaultMessage);
    } catch {
      shouldRedirect = false;
    }
    if (shouldRedirect && nav.to) {
      try {
        Tainted.forceRedirection = true;
        await goto(nav.to.url, { ...nav.to.params });
        return;
      } finally {
        Tainted.forceRedirection = false;
      }
    } else if (!shouldRedirect && !isTaintedFunction) {
      nav.cancel();
    }
  }
  function Tainted_enable() {
    options.taintedMessage = Tainted.message;
  }
  function Tainted_currentState() {
    return Tainted.state;
  }
  function Tainted_hasBeenTainted(path) {
    if (!Data.tainted)
      return false;
    if (!path)
      return !!Data.tainted;
    const field = pathExists(Data.tainted, splitPath(path));
    return !!field && field.key in field.parent;
  }
  function Tainted_isTainted(path) {
    if (!arguments.length)
      return Tainted__isObjectTainted(Data.tainted);
    if (typeof path === "boolean")
      return path;
    if (typeof path === "object")
      return Tainted__isObjectTainted(path);
    if (!Data.tainted || path === void 0)
      return false;
    const field = pathExists(Data.tainted, splitPath(path));
    return Tainted__isObjectTainted(field == null ? void 0 : field.value);
  }
  function Tainted__isObjectTainted(obj) {
    if (!obj)
      return false;
    if (typeof obj === "object") {
      for (const obj2 of Object.values(obj)) {
        if (Tainted__isObjectTainted(obj2))
          return true;
      }
    }
    return obj === true;
  }
  function Tainted_update(newData, taintOptions) {
    if (taintOptions == "ignore")
      return;
    const paths = comparePaths(newData, Data.form);
    const newTainted = comparePaths(newData, Tainted.clean).map((path) => path.join());
    if (paths.length) {
      if (taintOptions == "untaint-all" || taintOptions == "untaint-form") {
        Tainted.state.set(void 0);
      } else {
        Tainted.state.update((currentlyTainted) => {
          if (!currentlyTainted)
            currentlyTainted = {};
          setPaths(currentlyTainted, paths, (path, data) => {
            if (!newTainted.includes(path.join()))
              return void 0;
            const currentValue = traversePath(newData, path);
            const cleanPath = traversePath(Tainted.clean, path);
            return currentValue && cleanPath && currentValue.value === cleanPath.value ? void 0 : taintOptions === true ? true : taintOptions === "untaint" ? void 0 : data.value;
          });
          return currentlyTainted;
        });
      }
    }
    NextChange_setHtmlEvent({ paths });
  }
  function Tainted_set(tainted, newClean) {
    Tainted.state.set(tainted);
    if (newClean)
      Tainted.clean = newClean;
  }
  const Submitting = writable(false);
  const Delayed = writable(false);
  const Timeout = writable(false);
  const Unsubscriptions = [
    // eslint-disable-next-line dci-lint/private-role-access
    Tainted.state.subscribe((tainted) => __data.tainted = clone(tainted)),
    // eslint-disable-next-line dci-lint/private-role-access
    Form2.subscribe((form2) => __data.form = clone(form2)),
    // eslint-disable-next-line dci-lint/private-role-access
    Errors.subscribe((errors) => __data.errors = clone(errors)),
    FormId.subscribe((id) => __data.formId = id),
    Constraints.subscribe((constraints) => __data.constraints = constraints),
    Posted.subscribe((posted) => __data.posted = posted),
    Message.subscribe((message2) => __data.message = message2),
    Submitting.subscribe((submitting) => __data.submitting = submitting),
    Shape.subscribe((shape) => __data.shape = shape)
  ];
  function Unsubscriptions_add(func) {
    Unsubscriptions.push(func);
  }
  function Unsubscriptions_unsubscribe() {
    Unsubscriptions.forEach((unsub) => unsub());
  }
  let EnhancedForm;
  function EnhancedForm_get() {
    return EnhancedForm;
  }
  function EnhancedForm_createFromSPA(action) {
    EnhancedForm = document.createElement("form");
    EnhancedForm.method = "POST";
    EnhancedForm.action = action;
    superFormEnhance(EnhancedForm);
    document.body.appendChild(EnhancedForm);
  }
  function EnhancedForm_setAction(action) {
    if (EnhancedForm)
      EnhancedForm.action = action;
  }
  function EnhancedForm_destroy() {
    if (EnhancedForm == null ? void 0 : EnhancedForm.parentElement) {
      EnhancedForm.remove();
    }
    EnhancedForm = void 0;
  }
  const AllErrors = derived(Errors, ($errors) => $errors ? flattenErrors($errors) : []);
  options.taintedMessage = void 0;
  function rebind(opts) {
    const form2 = opts.form;
    const message2 = opts.message ?? form2.message;
    if (opts.untaint || opts.resetted) {
      Tainted_set(typeof opts.untaint === "boolean" ? void 0 : opts.untaint, form2.data);
    }
    if (opts.skipFormData !== true) {
      Form_set(form2.data, {
        taint: "ignore",
        keepFiles: opts.keepFiles
      });
    }
    Message.set(message2);
    if (opts.resetted)
      Errors.update(() => ({}), { force: true });
    else
      Errors.set(form2.errors);
    FormId.set(form2.id);
    Posted.set(opts.posted ?? form2.posted);
    if (form2.constraints)
      Constraints.set(form2.constraints);
    if (form2.shape)
      Shape.set(form2.shape);
    __data.valid = form2.valid;
    if (options.flashMessage && shouldSyncFlash(options)) {
      const flash = options.flashMessage.module.getFlash(page2);
      if (message2 && get_store_value(flash) === void 0) {
        flash.set(message2);
      }
    }
  }
  const formEvents = {
    onSubmit: options.onSubmit ? [options.onSubmit] : [],
    onResult: options.onResult ? [options.onResult] : [],
    onUpdate: options.onUpdate ? [options.onUpdate] : [],
    onUpdated: options.onUpdated ? [options.onUpdated] : [],
    onError: options.onError ? [options.onError] : []
  };
  if (browser4) {
    window.addEventListener("beforeunload", Tainted_checkUnload);
    onDestroy(() => {
      window.removeEventListener("beforeunload", Tainted_checkUnload);
    });
    beforeNavigate(Tainted_beforeNav);
    Unsubscriptions_add(page2.subscribe(async (pageUpdate) => {
      if (STORYBOOK_MODE && pageUpdate === void 0) {
        pageUpdate = { status: 200 };
      }
      const successResult = pageUpdate.status >= 200 && pageUpdate.status < 300;
      if (options.applyAction && pageUpdate.form && typeof pageUpdate.form === "object") {
        const actionData = pageUpdate.form;
        if (actionData.type == "error")
          return;
        for (const newForm of Context_findValidationForms(actionData)) {
          const isInitial = initialForms.has(newForm);
          if (newForm.id !== Data.formId || isInitial) {
            continue;
          }
          initialForms.set(newForm, newForm);
          await Form_updateFromValidation(newForm, successResult);
        }
      } else if (pageUpdate.data && typeof pageUpdate.data === "object") {
        for (const newForm of Context_findValidationForms(pageUpdate.data)) {
          const isInitial = initialForms.has(newForm);
          if (newForm.id !== Data.formId || isInitial) {
            continue;
          }
          if (options.invalidateAll === "force") {
            initialForm.data = newForm.data;
          }
          const resetStatus = Form_shouldReset(true, true);
          rebind({
            form: newForm,
            untaint: successResult,
            keepFiles: !resetStatus,
            resetted: resetStatus
          });
        }
      }
    }));
    if (typeof options.SPA === "string") {
      EnhancedForm_createFromSPA(options.SPA);
    }
  }
  function superFormEnhance(FormElement, events) {
    if (options.SPA !== void 0 && FormElement.method == "get")
      FormElement.method = "post";
    if (typeof options.SPA === "string") {
      if (options.SPA.length && FormElement.action == document.location.href) {
        FormElement.action = options.SPA;
      }
    } else {
      EnhancedForm = FormElement;
    }
    if (events) {
      if (events.onError) {
        if (options.onError === "apply") {
          throw new SuperFormError('options.onError is set to "apply", cannot add any onError events.');
        } else if (events.onError === "apply") {
          throw new SuperFormError('Cannot add "apply" as onError event in use:enhance.');
        }
        formEvents.onError.push(events.onError);
      }
      if (events.onResult)
        formEvents.onResult.push(events.onResult);
      if (events.onSubmit)
        formEvents.onSubmit.push(events.onSubmit);
      if (events.onUpdate)
        formEvents.onUpdate.push(events.onUpdate);
      if (events.onUpdated)
        formEvents.onUpdated.push(events.onUpdated);
    }
    Tainted_enable();
    let lastInputChange;
    async function onInput(e) {
      const info = inputInfo(e.target);
      if (info.immediate && !info.file)
        await new Promise((r) => setTimeout(r, 0));
      lastInputChange = NextChange_paths();
      NextChange_additionalEventInformation("input", info.immediate, info.multiple, FormElement, e.target ?? void 0);
    }
    async function onBlur(e) {
      if (Data.submitting)
        return;
      if (!lastInputChange || NextChange_paths() != lastInputChange) {
        return;
      }
      const info = inputInfo(e.target);
      if (info.immediate && !info.file)
        await new Promise((r) => setTimeout(r, 0));
      Form_clientValidation({
        paths: lastInputChange,
        immediate: info.multiple,
        multiple: info.multiple,
        type: "blur",
        formElement: FormElement,
        target: e.target ?? void 0
      });
      lastInputChange = void 0;
    }
    FormElement.addEventListener("focusout", onBlur);
    FormElement.addEventListener("input", onInput);
    onDestroy(() => {
      FormElement.removeEventListener("focusout", onBlur);
      FormElement.removeEventListener("input", onInput);
    });
    const htmlForm = Form(FormElement, { submitting: Submitting, delayed: Delayed, timeout: Timeout }, options);
    let currentRequest;
    let customRequest = void 0;
    return kitEnhance(FormElement, async (submitParams) => {
      let jsonData = void 0;
      let validationAdapter = options.validators;
      const submit = {
        ...submitParams,
        jsonData(data) {
          if (options.dataType !== "json") {
            throw new SuperFormError("options.dataType must be set to 'json' to use jsonData.");
          }
          jsonData = data;
        },
        validators(adapter) {
          validationAdapter = adapter;
        },
        customRequest(request) {
          customRequest = request;
        }
      };
      const _submitCancel = submit.cancel;
      let cancelled = false;
      function clientValidationResult(validation) {
        var _a2;
        const validationResult = { ...validation, posted: true };
        const status = validationResult.valid ? 200 : (typeof options.SPA === "boolean" || typeof options.SPA === "string" ? void 0 : (_a2 = options.SPA) == null ? void 0 : _a2.failStatus) ?? 400;
        const data = { form: validationResult };
        const result = validationResult.valid ? { type: "success", status, data } : { type: "failure", status, data };
        setTimeout(() => validationResponse({ result }), 0);
      }
      function clearOnSubmit() {
        switch (options.clearOnSubmit) {
          case "errors-and-message":
            Errors.clear();
            Message.set(void 0);
            break;
          case "errors":
            Errors.clear();
            break;
          case "message":
            Message.set(void 0);
            break;
        }
      }
      function cancel(opts = {
        resetTimers: true
      }) {
        cancelled = true;
        if (opts.resetTimers && htmlForm.isSubmitting()) {
          htmlForm.completed({ cancelled });
        }
        return _submitCancel();
      }
      submit.cancel = cancel;
      if (htmlForm.isSubmitting() && options.multipleSubmits == "prevent") {
        cancel({ resetTimers: false });
      } else {
        if (htmlForm.isSubmitting() && options.multipleSubmits == "abort") {
          if (currentRequest)
            currentRequest.abort();
        }
        htmlForm.submitting();
        currentRequest = submit.controller;
        for (const event of formEvents.onSubmit) {
          await event(submit);
        }
      }
      if (cancelled && options.flashMessage)
        cancelFlash(options);
      if (!cancelled) {
        const noValidate = !Form_isSPA() && (FormElement.noValidate || (submit.submitter instanceof HTMLButtonElement || submit.submitter instanceof HTMLInputElement) && submit.submitter.formNoValidate);
        let validation = void 0;
        const validateForm = async () => {
          return await Form_validate({ adapter: validationAdapter });
        };
        clearOnSubmit();
        if (!noValidate) {
          validation = await validateForm();
          if (!validation.valid) {
            cancel({ resetTimers: false });
            clientValidationResult(validation);
          }
        }
        if (!cancelled) {
          if (options.flashMessage && (options.clearOnSubmit == "errors-and-message" || options.clearOnSubmit == "message") && shouldSyncFlash(options)) {
            options.flashMessage.module.getFlash(page2).set(void 0);
          }
          const submitData = "formData" in submit ? submit.formData : submit.data;
          lastInputChange = void 0;
          if (Form_isSPA()) {
            if (!validation)
              validation = await validateForm();
            cancel({ resetTimers: false });
            clientValidationResult(validation);
          } else if (options.dataType === "json") {
            if (!validation)
              validation = await validateForm();
            const postData = clone(jsonData ?? validation.data);
            traversePaths(postData, (data) => {
              if (data.value instanceof File) {
                const key = "__superform_file_" + mergePath(data.path);
                submitData.append(key, data.value);
                return data.set(void 0);
              } else if (Array.isArray(data.value) && data.value.length && data.value.every((v) => v instanceof File)) {
                const key = "__superform_files_" + mergePath(data.path);
                for (const file2 of data.value) {
                  submitData.append(key, file2);
                }
                return data.set(void 0);
              }
            });
            Object.keys(postData).forEach((key) => {
              if (typeof submitData.get(key) === "string") {
                submitData.delete(key);
              }
            });
            const chunks = chunkSubstr(stringify(postData), options.jsonChunkSize ?? 5e5);
            for (const chunk of chunks) {
              submitData.append("__superform_json", chunk);
            }
          }
          if (!submitData.has("__superform_id")) {
            const id = Data.formId;
            if (id !== void 0)
              submitData.set("__superform_id", id);
          }
          if (typeof options.SPA === "string") {
            EnhancedForm_setAction(options.SPA);
          }
        }
      }
      function chunkSubstr(str, size) {
        const numChunks = Math.ceil(str.length / size);
        const chunks = new Array(numChunks);
        for (let i = 0, o = 0; i < numChunks; ++i, o += size) {
          chunks[i] = str.substring(o, o + size);
        }
        return chunks;
      }
      async function validationResponse(event) {
        var _a2;
        let cancelled2 = false;
        currentRequest = null;
        let result = "type" in event.result && "status" in event.result ? event.result : {
          type: "error",
          status: parseInt(String(event.result.status)) || 500,
          error: event.result.error instanceof Error ? event.result.error : event.result
        };
        const cancel2 = () => cancelled2 = true;
        const data = {
          result,
          formEl: FormElement,
          formElement: FormElement,
          cancel: cancel2
        };
        const unsubCheckforNav = STORYBOOK_MODE || !Form_isSPA() ? () => {
        } : navigating.subscribe(($nav) => {
          var _a3, _b;
          if (!$nav || ((_a3 = $nav.from) == null ? void 0 : _a3.route.id) === ((_b = $nav.to) == null ? void 0 : _b.route.id))
            return;
          cancel2();
        });
        for (const event2 of formEvents.onResult) {
          await event2(data);
        }
        result = data.result;
        if (!cancelled2) {
          if ((result.type === "success" || result.type == "failure") && result.data) {
            const forms = Context_findValidationForms(result.data);
            if (!forms.length) {
              throw new SuperFormError("No form data returned from ActionResult. Make sure you return { form } in the form actions.");
            }
            for (const newForm of forms) {
              if (newForm.id !== Data.formId)
                continue;
              const data2 = {
                form: newForm,
                formEl: FormElement,
                formElement: FormElement,
                cancel: () => cancelled2 = true,
                result
              };
              for (const event2 of formEvents.onUpdate) {
                await event2(data2);
              }
              result = data2.result;
              if (!cancelled2) {
                if (options.customValidity) {
                  setCustomValidityForm(FormElement, data2.form.errors);
                }
                if (Form_shouldReset(data2.form.valid, result.type == "success")) {
                  data2.formElement.querySelectorAll('input[type="file"]').forEach((e) => e.value = "");
                }
              }
            }
          }
          if (!cancelled2) {
            if (result.type !== "error") {
              if (result.type === "success" && options.invalidateAll) {
                await invalidateAll();
              }
              if (options.applyAction) {
                await applyAction(result);
              } else {
                await Form_updateFromActionResult(result);
              }
            } else {
              if (options.applyAction) {
                if (options.onError == "apply") {
                  await applyAction(result);
                } else {
                  const failResult = {
                    type: "failure",
                    status: Math.floor(result.status || 500),
                    data: result
                  };
                  await applyAction(failResult);
                }
              }
              if (options.onError !== "apply") {
                const data2 = { result, message: Message };
                for (const onErrorEvent of formEvents.onError) {
                  if (onErrorEvent !== "apply" && (onErrorEvent != defaultOnError || !((_a2 = options.flashMessage) == null ? void 0 : _a2.onError))) {
                    await onErrorEvent(data2);
                  }
                }
              }
            }
            if (options.flashMessage) {
              if (result.type == "error" && options.flashMessage.onError) {
                await options.flashMessage.onError({
                  result,
                  flashMessage: options.flashMessage.module.getFlash(page2)
                });
              }
            }
          }
        }
        if (cancelled2 && options.flashMessage) {
          cancelFlash(options);
        }
        if (cancelled2 || result.type != "redirect") {
          htmlForm.completed({ cancelled: cancelled2 });
        } else if (STORYBOOK_MODE) {
          htmlForm.completed({ cancelled: cancelled2, clearAll: true });
        } else {
          const unsub = navigating.subscribe(($nav) => {
            if ($nav)
              return;
            setTimeout(() => {
              try {
                if (unsub)
                  unsub();
              } catch {
              }
            });
            if (htmlForm.isSubmitting()) {
              htmlForm.completed({ cancelled: cancelled2, clearAll: true });
            }
          });
        }
        unsubCheckforNav();
      }
      if (customRequest) {
        if (!cancelled)
          _submitCancel();
        const response = await customRequest(submitParams);
        const result = response instanceof Response ? deserialize(await response.text()) : deserialize(response.responseText);
        if (result.type === "error")
          result.status = response.status;
        validationResponse({ result });
      }
      return validationResponse;
    });
  }
  function removeFiles2(formData) {
    const paths = [];
    traversePaths(formData, (data2) => {
      if (data2.value instanceof File) {
        paths.push(data2.path);
        return "skip";
      } else if (Array.isArray(data2.value) && data2.value.length && data2.value.every((d) => d instanceof File)) {
        paths.push(data2.path);
        return "skip";
      }
    });
    if (!paths.length)
      return { data: formData, paths };
    const data = clone(formData);
    setPaths(data, paths, (path) => {
      var _a2;
      return (_a2 = pathExists(initialForm.data, path)) == null ? void 0 : _a2.value;
    });
    return { data, paths };
  }
  return {
    form: Form2,
    formId: FormId,
    errors: Errors,
    message: Message,
    constraints: Constraints,
    tainted: Tainted_currentState(),
    submitting: readonly(Submitting),
    delayed: readonly(Delayed),
    timeout: readonly(Timeout),
    options,
    capture() {
      const { data, paths } = removeFiles2(Data.form);
      let tainted = Data.tainted;
      if (paths.length) {
        tainted = clone(tainted) ?? {};
        setPaths(tainted, paths, false);
      }
      return {
        valid: Data.valid,
        posted: Data.posted,
        errors: Data.errors,
        data,
        constraints: Data.constraints,
        message: Data.message,
        id: Data.formId,
        tainted,
        shape: Data.shape
      };
    },
    restore: (snapshot) => {
      rebind({ form: snapshot, untaint: snapshot.tainted ?? true });
    },
    async validate(path, opts = {}) {
      if (!options.validators) {
        throw new SuperFormError("options.validators must be set to use the validate method.");
      }
      if (opts.update === void 0)
        opts.update = true;
      if (opts.taint === void 0)
        opts.taint = false;
      if (typeof opts.errors == "string")
        opts.errors = [opts.errors];
      let data;
      const splittedPath = splitPath(path);
      if ("value" in opts) {
        if (opts.update === true || opts.update === "value") {
          Form2.update(($form) => {
            setPaths($form, [splittedPath], opts.value);
            return $form;
          }, { taint: opts.taint });
          data = Data.form;
        } else {
          data = clone(Data.form);
          setPaths(data, [splittedPath], opts.value);
        }
      } else {
        data = Data.form;
      }
      const result = await Form_validate({ formData: data });
      const error = pathExists(result.errors, splittedPath);
      if (error && error.value && opts.errors) {
        error.value = opts.errors;
      }
      if (opts.update === true || opts.update == "errors") {
        Errors.update(($errors) => {
          setPaths($errors, [splittedPath], error == null ? void 0 : error.value);
          return $errors;
        });
      }
      return error == null ? void 0 : error.value;
    },
    async validateForm(opts = {}) {
      if (!options.validators && !opts.schema) {
        throw new SuperFormError("options.validators or the schema option must be set to use the validateForm method.");
      }
      const result = opts.update ? await Form_clientValidation({ paths: [] }, true, opts.schema) : Form_validate({ adapter: opts.schema });
      const enhancedForm = EnhancedForm_get();
      if (opts.update && enhancedForm) {
        setTimeout(() => {
          if (!enhancedForm)
            return;
          scrollToFirstError(enhancedForm, {
            ...options,
            scrollToError: opts.focusOnError === false ? "off" : options.scrollToError
          });
        }, 1);
      }
      return result || Form_validate({ adapter: opts.schema });
    },
    allErrors: AllErrors,
    posted: Posted,
    reset(options2) {
      return Form_reset({
        message: (options2 == null ? void 0 : options2.keepMessage) ? Data.message : void 0,
        data: options2 == null ? void 0 : options2.data,
        id: options2 == null ? void 0 : options2.id,
        newState: options2 == null ? void 0 : options2.newState
      });
    },
    submit(submitter) {
      const form2 = EnhancedForm_get() ? EnhancedForm_get() : submitter && submitter instanceof HTMLElement ? submitter.closest("form") : void 0;
      if (!form2) {
        throw new SuperFormError("use:enhance must be added to the form to use submit, or pass a HTMLElement inside the form (or the form itself) as an argument.");
      }
      if (!form2.requestSubmit) {
        return form2.submit();
      }
      const isSubmitButton = submitter && (submitter instanceof HTMLButtonElement && submitter.type == "submit" || submitter instanceof HTMLInputElement && ["submit", "image"].includes(submitter.type));
      form2.requestSubmit(isSubmitButton ? submitter : void 0);
    },
    isTainted: Tainted_isTainted,
    enhance: superFormEnhance
  };
}

// node_modules/sveltekit-superforms/dist/defaults.js
function defaults(data, adapter, options) {
  if (data && "superFormValidationLibrary" in data) {
    options = adapter;
    adapter = data;
    data = null;
  }
  const validator = adapter;
  const optionDefaults = (options == null ? void 0 : options.defaults) ?? validator.defaults;
  return {
    id: (options == null ? void 0 : options.id) ?? validator.id ?? "",
    valid: false,
    posted: false,
    errors: {},
    data: { ...optionDefaults, ...data },
    constraints: validator.constraints,
    shape: validator.shape
  };
}
function defaultValues2(adapter) {
  return adapter.defaults;
}

// node_modules/sveltekit-superforms/dist/actionResult.js
import { json } from "@sveltejs/kit";
function actionResult(type, data, options) {
  function cookieData() {
    var _a, _b, _c, _d;
    if (typeof options === "number" || !(options == null ? void 0 : options.message))
      return "";
    const extra = [
      `Path=${((_a = options == null ? void 0 : options.cookieOptions) == null ? void 0 : _a.path) || "/"}`,
      `Max-Age=${((_b = options == null ? void 0 : options.cookieOptions) == null ? void 0 : _b.maxAge) || 120}`,
      `SameSite=${((_c = options == null ? void 0 : options.cookieOptions) == null ? void 0 : _c.sameSite) ?? "Strict"}`
    ];
    if ((_d = options == null ? void 0 : options.cookieOptions) == null ? void 0 : _d.secure) {
      extra.push(`Secure`);
    }
    return `flash=${encodeURIComponent(JSON.stringify(options.message))}; ` + extra.join("; ");
  }
  const status = options && typeof options !== "number" ? options.status : options;
  const result = (struct) => {
    return json({ type, ...struct }, {
      status: struct.status,
      headers: typeof options === "object" && options.message ? {
        "Set-Cookie": cookieData()
      } : void 0
    });
  };
  if (type == "error") {
    return result({
      status: status || 500,
      error: typeof data === "string" ? { message: data } : data
    });
  } else if (type == "redirect") {
    return result({
      status: status || 303,
      location: data
    });
  } else if (type == "failure") {
    return result({
      status: status || 400,
      data: stringify(data)
    });
  } else {
    return result({ status: status || 200, data: stringify(data) });
  }
}

// node_modules/sveltekit-superforms/dist/superValidate.js
import { fail as kitFail } from "@sveltejs/kit";

// node_modules/sveltekit-superforms/dist/formData.js
var legacyMode = false;
try {
  if (SUPERFORMS_LEGACY)
    legacyMode = true;
} catch {
}
var unionError = 'FormData parsing failed: Unions are only supported when the dataType option for superForm is set to "json".';
async function parseRequest(data, schemaData, options) {
  let parsed;
  if (data instanceof FormData) {
    parsed = parseFormData(data, schemaData, options);
  } else if (data instanceof URL || data instanceof URLSearchParams) {
    parsed = parseSearchParams(data, schemaData, options);
  } else if (data instanceof Request) {
    parsed = await tryParseFormData(data, schemaData, options);
  } else if (
    // RequestEvent
    data && typeof data === "object" && "request" in data && data.request instanceof Request
  ) {
    parsed = await tryParseFormData(data.request, schemaData, options);
  } else {
    parsed = {
      id: void 0,
      data,
      posted: false
    };
  }
  return parsed;
}
async function tryParseFormData(request, schemaData, options) {
  let formData = void 0;
  try {
    formData = await request.formData();
  } catch (e) {
    if (e instanceof TypeError && e.message.includes("already been consumed")) {
      throw e;
    }
    return { id: void 0, data: void 0, posted: false };
  }
  return parseFormData(formData, schemaData, options);
}
function parseSearchParams(data, schemaData, options) {
  if (data instanceof URL)
    data = data.searchParams;
  const convert = new FormData();
  for (const [key, value] of data.entries()) {
    convert.append(key, value);
  }
  const output = parseFormData(convert, schemaData, options);
  output.posted = false;
  return output;
}
function parseFormData(formData, schemaData, options) {
  var _a;
  function tryParseSuperJson() {
    if (formData.has("__superform_json")) {
      try {
        const output = parse(formData.getAll("__superform_json").join("") ?? "");
        if (typeof output === "object") {
          const filePaths = Array.from(formData.keys());
          for (const path of filePaths.filter((path2) => path2.startsWith("__superform_file_"))) {
            const realPath = splitPath(path.substring(17));
            setPaths(output, [realPath], formData.get(path));
          }
          for (const path of filePaths.filter((path2) => path2.startsWith("__superform_files_"))) {
            const realPath = splitPath(path.substring(18));
            const allFiles = formData.getAll(path);
            setPaths(output, [realPath], Array.from(allFiles));
          }
          return output;
        }
      } catch {
      }
    }
    return null;
  }
  const data = tryParseSuperJson();
  const id = (_a = formData.get("__superform_id")) == null ? void 0 : _a.toString();
  return data ? { id, data, posted: true } : {
    id,
    data: _parseFormData(formData, schemaData, options),
    posted: true
  };
}
function _parseFormData(formData, schema, options) {
  var _a, _b, _c, _d;
  const output = {};
  let schemaKeys;
  if (options == null ? void 0 : options.strict) {
    schemaKeys = new Set([...formData.keys()].filter((key) => !key.startsWith("__superform_")));
  } else {
    let unionKeys = [];
    if (schema.anyOf) {
      const info = schemaInfo(schema, false, []);
      if ((_a = info.union) == null ? void 0 : _a.some((s) => s.type !== "object")) {
        throw new SchemaError("All form types must be an object if schema is a union.");
      }
      unionKeys = ((_b = info.union) == null ? void 0 : _b.flatMap((s) => Object.keys(s.properties ?? {}))) ?? [];
    }
    schemaKeys = new Set([
      ...unionKeys,
      ...Object.keys(schema.properties ?? {}),
      ...schema.additionalProperties ? formData.keys() : []
    ].filter((key) => !key.startsWith("__superform_")));
  }
  function parseSingleEntry(key, entry, info) {
    if ((options == null ? void 0 : options.preprocessed) && options.preprocessed.includes(key)) {
      return entry;
    }
    if (entry && typeof entry !== "string") {
      const allowFiles = legacyMode ? (options == null ? void 0 : options.allowFiles) === true : (options == null ? void 0 : options.allowFiles) !== false;
      return !allowFiles ? void 0 : entry.size ? entry : info.isNullable ? null : void 0;
    }
    if (info.types.length > 1) {
      throw new SchemaError(unionError, key);
    }
    const [type] = info.types;
    return parseFormDataEntry(key, entry, type ?? "any", info);
  }
  const defaultPropertyType = typeof schema.additionalProperties == "object" ? schema.additionalProperties : { type: "string" };
  for (const key of schemaKeys) {
    const property = schema.properties ? schema.properties[key] : defaultPropertyType;
    assertSchema(property, key);
    const info = schemaInfo(property ?? defaultPropertyType, !((_c = schema.required) == null ? void 0 : _c.includes(key)), [
      key
    ]);
    if (!info)
      continue;
    if (!info.types.includes("boolean") && !schema.additionalProperties && !formData.has(key)) {
      continue;
    }
    const entries = formData.getAll(key);
    if (info.union && info.union.length > 1) {
      throw new SchemaError(unionError, key);
    }
    if (info.types.includes("array") || info.types.includes("set")) {
      const items = property.items ?? (((_d = info.union) == null ? void 0 : _d.length) == 1 ? info.union[0] : void 0);
      if (!items || typeof items == "boolean" || Array.isArray(items) && items.length != 1) {
        throw new SchemaError('Arrays must have a single "items" property that defines its type.', key);
      }
      const arrayType = Array.isArray(items) ? items[0] : items;
      assertSchema(arrayType, key);
      const arrayInfo = schemaInfo(arrayType, info.isOptional, [key]);
      if (!arrayInfo)
        continue;
      const isFileArray = entries.length && entries.some((e) => e && typeof e !== "string");
      const arrayData = entries.map((e) => parseSingleEntry(key, e, arrayInfo));
      if (isFileArray && arrayData.every((file2) => !file2))
        arrayData.length = 0;
      output[key] = info.types.includes("set") ? new Set(arrayData) : arrayData;
    } else {
      output[key] = parseSingleEntry(key, entries[entries.length - 1], info);
    }
  }
  return output;
}
function parseFormDataEntry(key, value, type, info) {
  if (!value) {
    if (type == "boolean" && info.isOptional && info.schema.default === true) {
      return false;
    }
    const defaultValue = defaultValues(info.schema, info.isOptional, [key]);
    if (info.schema.enum && defaultValue !== null && defaultValue !== void 0) {
      return value;
    }
    if (defaultValue !== void 0)
      return defaultValue;
    if (info.isNullable)
      return null;
    if (info.isOptional)
      return void 0;
  }
  function typeError() {
    throw new SchemaError(type[0].toUpperCase() + type.slice(1) + ` type found. Set the dataType option to "json" and add use:enhance on the client to use nested data structures. More information: https://superforms.rocks/concepts/nested-data`, key);
  }
  switch (type) {
    case "string":
    case "any":
      return value;
    case "integer":
      return parseInt(value ?? "", 10);
    case "number":
      return parseFloat(value ?? "");
    case "boolean":
      return Boolean(value == "false" ? "" : value).valueOf();
    case "unix-time": {
      const date = new Date(value ?? "");
      return !isNaN(date) ? date : void 0;
    }
    case "bigint":
      return BigInt(value ?? ".");
    case "symbol":
      return Symbol(String(value));
    case "set":
    case "array":
    case "object":
      return typeError();
    default:
      throw new SuperFormError("Unsupported schema type for FormData: " + type);
  }
}

// node_modules/sveltekit-superforms/dist/superValidate.js
async function superValidate(data, adapter, options) {
  if (data && "superFormValidationLibrary" in data) {
    options = adapter;
    adapter = data;
    data = void 0;
  }
  const validator = adapter;
  const defaults2 = (options == null ? void 0 : options.defaults) ?? validator.defaults;
  const jsonSchema = validator.jsonSchema;
  const parsed = await parseRequest(data, jsonSchema, options);
  const addErrors = (options == null ? void 0 : options.errors) ?? ((options == null ? void 0 : options.strict) ? true : !!parsed.data);
  const parsedData = (options == null ? void 0 : options.strict) ? parsed.data ?? {} : mergeDefaults(parsed.data, defaults2);
  let status;
  if (!!parsed.data || addErrors) {
    status = await validator.validate(parsedData);
  } else {
    status = { success: false, issues: [] };
  }
  const valid = status.success;
  const errors = valid || !addErrors ? {} : mapErrors(status.issues, validator.shape);
  const dataWithDefaults = valid ? status.data : replaceInvalidDefaults((options == null ? void 0 : options.strict) ? mergeDefaults(parsedData, defaults2) : parsedData, defaults2, jsonSchema, status.issues, options == null ? void 0 : options.preprocessed);
  let outputData;
  if (jsonSchema.additionalProperties === false) {
    outputData = {};
    for (const key of Object.keys(jsonSchema.properties ?? {})) {
      if (key in dataWithDefaults)
        outputData[key] = dataWithDefaults[key];
    }
  } else {
    outputData = dataWithDefaults;
  }
  const output = {
    id: parsed.id ?? (options == null ? void 0 : options.id) ?? validator.id,
    valid,
    posted: parsed.posted,
    errors,
    data: outputData
  };
  if (!parsed.posted) {
    output.constraints = validator.constraints;
    if (Object.keys(validator.shape).length) {
      output.shape = validator.shape;
    }
  }
  return output;
}
function message(form, message2, options) {
  if ((options == null ? void 0 : options.status) && options.status >= 400) {
    form.valid = false;
  }
  form.message = message2;
  const remove = (options == null ? void 0 : options.removeFiles) !== false;
  const output = remove ? withFiles({ form }) : { form };
  return form.valid ? output : kitFail((options == null ? void 0 : options.status) ?? 400, output);
}
var setMessage = message;
function setError(form, path, error, options) {
  if (error == void 0 || typeof error !== "string" && !Array.isArray(error)) {
    options = error;
    error = path;
    path = "";
  }
  if (options === void 0)
    options = {};
  const errArr = Array.isArray(error) ? error : [error];
  if (!form.errors)
    form.errors = {};
  if (path === null || path === "") {
    if (!form.errors._errors)
      form.errors._errors = [];
    form.errors._errors = options.overwrite ? errArr : form.errors._errors.concat(errArr);
  } else {
    const realPath = splitPath(path);
    const leaf = traversePath(form.errors, realPath, ({ parent, key, value }) => {
      if (value === void 0)
        parent[key] = {};
      return parent[key];
    });
    if (leaf) {
      leaf.parent[leaf.key] = Array.isArray(leaf.value) && !options.overwrite ? leaf.value.concat(errArr) : errArr;
    }
  }
  form.valid = false;
  const output = options.removeFiles === false ? { form } : withFiles({ form });
  return kitFail(options.status ?? 400, output);
}
function withFiles(obj) {
  if (typeof obj !== "object")
    return obj;
  for (const key in obj) {
    const value = obj[key];
    if (value instanceof File)
      delete obj[key];
    else if (value && typeof value === "object")
      withFiles(value);
  }
  return obj;
}
var removeFiles = withFiles;
function fail(status, data) {
  function checkForm(data2) {
    return !!data2 && typeof data2 === "object" && "valid" in data2 && "data" in data2 && "id" in data2;
  }
  function checkObj(data2) {
    if (data2 && typeof data2 === "object") {
      for (const key in data2) {
        const v = data2[key];
        if (checkForm(v)) {
          v.valid = false;
          removeFiles(v);
        } else if (v && typeof v === "object") {
          checkObj(v);
        }
      }
    }
    return data2;
  }
  return kitFail(status, checkObj(data));
}

// node_modules/sveltekit-superforms/dist/index.js
var dist_default = SuperDebug_default;
export {
  SchemaError,
  SuperFormError,
  actionResult,
  arrayProxy,
  booleanProxy,
  dateProxy,
  dist_default as default,
  defaultValues2 as defaultValues,
  defaults,
  fail,
  fieldProxy,
  fileFieldProxy,
  fileProxy,
  filesFieldProxy,
  filesProxy,
  formFieldProxy,
  intProxy,
  message,
  numberProxy,
  removeFiles,
  schemaShape,
  setError,
  setMessage,
  splitPath,
  stringProxy,
  superForm,
  superValidate,
  withFiles
};
//# sourceMappingURL=sveltekit-superforms.js.map
