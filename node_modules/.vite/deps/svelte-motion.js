import {
  animate,
  anticipate,
  backIn,
  backInOut,
  backOut,
  bounceIn,
  bounceInOut,
  bounceOut,
  circIn,
  circInOut,
  circOut,
  clamp,
  cubicBezier,
  distance,
  easeIn,
  easeInOut,
  easeOut,
  inertia,
  interpolate,
  linear,
  mix,
  mixColor,
  pipe,
  progress,
  velocityPerSecond,
  wrap
} from "./chunk-6WSLV3CL.js";
import {
  cancelSync,
  es_default,
  flushSync,
  getFrameData
} from "./chunk-F3MIBQYA.js";
import {
  __read,
  __rest,
  __spreadArray
} from "./chunk-AO6O5TPT.js";
import {
  invariant,
  warning
} from "./chunk-DPJLTTUP.js";
import {
  alpha,
  color,
  complex,
  degrees,
  filter,
  number,
  percent,
  progressPercentage,
  px,
  scale,
  vh,
  vw
} from "./chunk-NXTUI3FV.js";
import "./chunk-SA3VOP2B.js";
import {
  derived,
  readable,
  writable
} from "./chunk-PCTSVBTO.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  afterUpdate,
  assign,
  beforeUpdate,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  safe_not_equal,
  setContext,
  set_attributes,
  set_dynamic_element_data,
  space,
  tick,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_dynamic_element,
  validate_each_keys,
  validate_slots,
  validate_store,
  validate_void_dynamic_element
} from "./chunk-L3FAA3FO.js";
import "./chunk-EKIRE5YT.js";
import {
  __require
} from "./chunk-MTI3AIJG.js";

// node_modules/svelte-motion/src/components/AnimateSharedLayout/types.js
var Presence;
(function(Presence2) {
  Presence2[Presence2["Entering"] = 0] = "Entering";
  Presence2[Presence2["Present"] = 1] = "Present";
  Presence2[Presence2["Exiting"] = 2] = "Exiting";
})(Presence || (Presence = {}));
var VisibilityAction2;
(function(VisibilityAction3) {
  VisibilityAction3[VisibilityAction3["Hide"] = 0] = "Hide";
  VisibilityAction3[VisibilityAction3["Show"] = 1] = "Show";
})(VisibilityAction2 || (VisibilityAction2 = {}));

// node_modules/svelte-motion/src/utils/fix-process-env.js
var fix = () => {
  try {
    if (!process.env) {
      process.env = {};
    }
    return true;
    ;
  } catch (e) {
  }
  if (!window || window.process && window.process.env) {
    return false;
  }
  if (!window.process) {
    window.process = {};
  }
  window.process.env = {};
  return true;
};
var fixed = fix();

// node_modules/svelte-motion/src/utils/array.js
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  var index = arr.indexOf(item);
  index > -1 && arr.splice(index, 1);
}

// node_modules/svelte-motion/src/utils/subscription-manager.js
var SubscriptionManager = (
  /** @class */
  function() {
    function SubscriptionManager2() {
      this.subscriptions = [];
    }
    SubscriptionManager2.prototype.add = function(handler) {
      var _this = this;
      addUniqueItem(this.subscriptions, handler);
      return function() {
        return removeItem(_this.subscriptions, handler);
      };
    };
    SubscriptionManager2.prototype.notify = function(a, b, c) {
      var numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a, b, c);
      } else {
        for (var i = 0; i < numSubscriptions; i++) {
          var handler = this.subscriptions[i];
          handler && handler(a, b, c);
        }
      }
    };
    SubscriptionManager2.prototype.getSize = function() {
      return this.subscriptions.length;
    };
    SubscriptionManager2.prototype.clear = function() {
      this.subscriptions.length = 0;
    };
    return SubscriptionManager2;
  }()
);

// node_modules/svelte-motion/src/value/index.js
var isFloat = function(value) {
  return !isNaN(parseFloat(value));
};
var MotionValue = (
  /** @class */
  function() {
    function MotionValue2(init2, startStopNotifier) {
      var _this = this;
      this.timeDelta = 0;
      this.lastUpdated = 0;
      this.updateSubscribers = new SubscriptionManager();
      this.velocityUpdateSubscribers = new SubscriptionManager();
      this.renderSubscribers = new SubscriptionManager();
      this.canTrackVelocity = false;
      this.updateAndNotify = function(v, render) {
        if (render === void 0) {
          render = true;
        }
        _this.prev = _this.current;
        _this.current = v;
        var _a = getFrameData(), delta2 = _a.delta, timestamp = _a.timestamp;
        if (_this.lastUpdated !== timestamp) {
          _this.timeDelta = delta2;
          _this.lastUpdated = timestamp;
          es_default.postRender(_this.scheduleVelocityCheck);
        }
        if (_this.prev !== _this.current) {
          _this.updateSubscribers.notify(_this.current);
        }
        if (_this.velocityUpdateSubscribers.getSize()) {
          _this.velocityUpdateSubscribers.notify(_this.getVelocity());
        }
        if (render) {
          _this.renderSubscribers.notify(_this.current);
        }
      };
      this.scheduleVelocityCheck = function() {
        return es_default.postRender(_this.velocityCheck);
      };
      this.velocityCheck = function(_a) {
        var timestamp = _a.timestamp;
        if (timestamp !== _this.lastUpdated) {
          _this.prev = _this.current;
          _this.velocityUpdateSubscribers.notify(_this.getVelocity());
        }
      };
      this.hasAnimated = false;
      this.prev = this.current = init2;
      this.canTrackVelocity = isFloat(this.current);
      this.onSubscription = () => {
      };
      this.onUnsubscription = () => {
      };
      if (startStopNotifier) {
        this.onSubscription = () => {
          if (this.updateSubscribers.getSize() + this.velocityUpdateSubscribers.getSize() + this.renderSubscribers.getSize() === 0) {
            const unsub = startStopNotifier();
            this.onUnsubscription = () => {
            };
            if (unsub) {
              this.onUnsubscription = () => {
                if (this.updateSubscribers.getSize() + this.velocityUpdateSubscribers.getSize() + this.renderSubscribers.getSize() === 0) {
                  unsub();
                }
              };
            }
          }
        };
      }
    }
    MotionValue2.prototype.onChange = function(subscription) {
      this.onSubscription();
      const unsub = this.updateSubscribers.add(subscription);
      return () => {
        unsub();
        this.onUnsubscription();
      };
    };
    MotionValue2.prototype.subscribe = function(subscription) {
      return this.onChange(subscription);
    };
    MotionValue2.prototype.clearListeners = function() {
      this.updateSubscribers.clear();
      this.onUnsubscription();
    };
    MotionValue2.prototype.onRenderRequest = function(subscription) {
      this.onSubscription();
      subscription(this.get());
      const unsub = this.renderSubscribers.add(subscription);
      return () => {
        unsub();
        this.onUnsubscription();
      };
    };
    MotionValue2.prototype.attach = function(passiveEffect) {
      this.passiveEffect = passiveEffect;
    };
    MotionValue2.prototype.set = function(v, render) {
      if (render === void 0) {
        render = true;
      }
      if (!render || !this.passiveEffect) {
        this.updateAndNotify(v, render);
      } else {
        this.passiveEffect(v, this.updateAndNotify);
      }
    };
    MotionValue2.prototype.update = function(v) {
      this.set(v(this.get()));
    };
    MotionValue2.prototype.get = function() {
      this.onSubscription();
      const curr = this.current;
      this.onUnsubscription();
      return curr;
    };
    MotionValue2.prototype.getPrevious = function() {
      return this.prev;
    };
    MotionValue2.prototype.getVelocity = function() {
      this.onSubscription();
      const vel = this.canTrackVelocity ? (
        // These casts could be avoided if parseFloat would be typed better
        velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
      ) : 0;
      this.onUnsubscription();
      return vel;
    };
    MotionValue2.prototype.start = function(animation) {
      var _this = this;
      this.stop();
      return new Promise(function(resolve) {
        _this.hasAnimated = true;
        _this.stopAnimation = animation(resolve);
      }).then(function() {
        return _this.clearAnimation();
      });
    };
    MotionValue2.prototype.stop = function() {
      if (this.stopAnimation)
        this.stopAnimation();
      this.clearAnimation();
    };
    MotionValue2.prototype.isAnimating = function() {
      return !!this.stopAnimation;
    };
    MotionValue2.prototype.clearAnimation = function() {
      this.stopAnimation = null;
    };
    MotionValue2.prototype.destroy = function() {
      this.updateSubscribers.clear();
      this.renderSubscribers.clear();
      this.stop();
      this.onUnsubscription();
    };
    return MotionValue2;
  }()
);
function motionValue(init2, startStopNotifier) {
  return new MotionValue(init2, startStopNotifier);
}

// node_modules/svelte-motion/src/context/DOMcontext.js
var getDomContext = (name, el) => {
  if (!el || !window) {
    return void 0;
  }
  let par = el;
  while (par = par.parentNode) {
    if (par.motionDomContext && par.motionDomContext.has(name)) {
      return par.motionDomContext.get(name);
    }
  }
  return void 0;
};
var setDomContext = (name, el, value) => {
  if (el && window) {
    if (!el.motionDomContext) {
      el.motionDomContext = /* @__PURE__ */ new Map();
    }
    el.motionDomContext.set(name, value);
  }
};

// node_modules/svelte-motion/src/context/MotionConfigContext.js
var MotionConfigContext = (c) => getDomContext("MotionConfig", c) || writable({
  transformPagePoint: function(p) {
    return p;
  },
  isStatic: false
});

// node_modules/svelte-motion/src/context/ScaleCorrectionProvider.svelte
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var ScaleCorrectionContext = (isCustom) => getDomContext("ScaleCorrection", isCustom) || writable([]);
var ScaleCorrectionParentContext = () => writable([]);
var provideScaleCorrection = (isCustom) => {
  const fromParent = getContext(ScaleCorrectionContext) || ScaleCorrectionContext(isCustom);
  const ctx = ScaleCorrectionContext();
  setContext(ScaleCorrectionContext, ctx);
  setDomContext("ScaleCorrection", isCustom, ctx);
  setContext(ScaleCorrectionParentContext, fromParent);
};
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScaleCorrectionProvider", slots, ["default"]);
  let { isCustom } = $$props;
  provideScaleCorrection(isCustom);
  $$self.$$.on_mount.push(function() {
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<ScaleCorrectionProvider> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ScaleCorrectionProvider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("isCustom" in $$props2) $$invalidate(0, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    writable,
    getContext,
    setContext,
    getDomContext,
    setDomContext,
    ScaleCorrectionContext,
    ScaleCorrectionParentContext,
    provideScaleCorrection,
    isCustom
  });
  $$self.$inject_state = ($$props2) => {
    if ("isCustom" in $$props2) $$invalidate(0, isCustom = $$props2.isCustom);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [isCustom, $$scope, slots];
}
var ScaleCorrectionProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { isCustom: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScaleCorrectionProvider",
      options,
      id: create_fragment.name
    });
  }
  get isCustom() {
    throw new Error("<ScaleCorrectionProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<ScaleCorrectionProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScaleCorrectionProvider_default = ScaleCorrectionProvider;

// node_modules/svelte-motion/src/components/MotionConfig/MotionConfigScaleCorrection.js
var scaleCorrection = () => {
  const scaleCorrectionContext = getContext(ScaleCorrectionContext);
  const scaleCorrectionParentContext = getContext(
    ScaleCorrectionParentContext
  );
  const afterU = (nc = false) => {
    const scc = get_store_value(scaleCorrectionContext);
    scc.forEach((v, i) => {
      var _a;
      (_a = v.afterU) == null ? void 0 : _a.call(v, true);
    });
  };
  const updater = () => {
    get_store_value(scaleCorrectionContext).forEach((v) => {
      var _a;
      (_a = v.updater) == null ? void 0 : _a.call(v, true);
    });
  };
  scaleCorrectionParentContext.update(
    (v) => v.concat([
      {
        updater,
        afterU
      }
    ])
  );
  return {
    update: updater
  };
};

// node_modules/svelte-motion/src/components/MotionConfig/MotionConfig.svelte
function create_fragment2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let transitionDependency;
  let $mcc;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MotionConfig", slots, ["default"]);
  let { transformPagePoint = void 0, isStatic = void 0, transition = void 0, isCustom = false } = $$props;
  const mcc = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  validate_store(mcc, "mcc");
  component_subscribe($$self, mcc, (value) => $$invalidate(7, $mcc = value));
  let config = {
    ...get_store_value(mcc),
    ...{ transformPagePoint, isStatic, transition }
  };
  provideScaleCorrection();
  let context = writable(config);
  setContext(MotionConfigContext, context);
  setDomContext("Motion", isCustom, context);
  const memo = () => config;
  const scaleCorrector = scaleCorrection();
  const writable_props = ["transformPagePoint", "isStatic", "transition", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<MotionConfig> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("transformPagePoint" in $$props2) $$invalidate(1, transformPagePoint = $$props2.transformPagePoint);
    if ("isStatic" in $$props2) $$invalidate(2, isStatic = $$props2.isStatic);
    if ("transition" in $$props2) $$invalidate(3, transition = $$props2.transition);
    if ("isCustom" in $$props2) $$invalidate(4, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2) $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    writable,
    get: get_store_value,
    setDomContext,
    MotionConfigContext,
    provideScaleCorrection,
    scaleCorrection,
    transformPagePoint,
    isStatic,
    transition,
    isCustom,
    mcc,
    config,
    context,
    memo,
    scaleCorrector,
    transitionDependency,
    $mcc
  });
  $$self.$inject_state = ($$props2) => {
    if ("transformPagePoint" in $$props2) $$invalidate(1, transformPagePoint = $$props2.transformPagePoint);
    if ("isStatic" in $$props2) $$invalidate(2, isStatic = $$props2.isStatic);
    if ("transition" in $$props2) $$invalidate(3, transition = $$props2.transition);
    if ("isCustom" in $$props2) $$invalidate(4, isCustom = $$props2.isCustom);
    if ("config" in $$props2) $$invalidate(5, config = $$props2.config);
    if ("context" in $$props2) $$invalidate(10, context = $$props2.context);
    if ("transitionDependency" in $$props2) $$invalidate(6, transitionDependency = $$props2.transitionDependency);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$mcc, transformPagePoint, isStatic, transition*/
    142) {
      $: $$invalidate(5, config = {
        ...$mcc,
        ...{ transformPagePoint, isStatic, transition }
      });
    }
    if ($$self.$$.dirty & /*config*/
    32) {
      $: $$invalidate(6, transitionDependency = typeof config.transition === "object" ? config.transition.toString() : "");
    }
    if ($$self.$$.dirty & /*transitionDependency, config*/
    96) {
      $: {
        context.set(memo(transitionDependency, config.transformPagePoint));
        scaleCorrector.update();
      }
    }
  };
  return [
    mcc,
    transformPagePoint,
    isStatic,
    transition,
    isCustom,
    config,
    transitionDependency,
    $mcc,
    $$scope,
    slots
  ];
}
var MotionConfig = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      transformPagePoint: 1,
      isStatic: 2,
      transition: 3,
      isCustom: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MotionConfig",
      options,
      id: create_fragment2.name
    });
  }
  get transformPagePoint() {
    throw new Error("<MotionConfig>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transformPagePoint(value) {
    throw new Error("<MotionConfig>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<MotionConfig>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<MotionConfig>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<MotionConfig>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<MotionConfig>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<MotionConfig>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<MotionConfig>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MotionConfig_default = MotionConfig;

// node_modules/svelte-motion/src/utils/time-conversion.js
var secondsToMilliseconds = function(seconds) {
  return seconds * 1e3;
};

// node_modules/svelte-motion/src/animation/utils/easing.js
var easingLookup = {
  linear,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate,
  bounceIn,
  bounceInOut,
  bounceOut
};
var easingDefinitionToFunction = function(definition) {
  if (Array.isArray(definition)) {
    var _a = __read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    return easingLookup[definition];
  }
  return definition;
};
var isEasingArray = function(ease) {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};

// node_modules/svelte-motion/src/animation/utils/is-animatable.js
var isAnimatable = function(key, value) {
  if (key === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  complex.test(value) && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};

// node_modules/svelte-motion/src/animation/utils/is-keyframes-target.js
var isKeyframesTarget = function(v) {
  return Array.isArray(v);
};

// node_modules/svelte-motion/src/animation/utils/default-transitions.js
var underDampedSpring = function() {
  return {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restDelta: 0.5,
    restSpeed: 10
  };
};
var criticallyDampedSpring = function(to) {
  return {
    type: "spring",
    stiffness: 550,
    damping: to === 0 ? 2 * Math.sqrt(550) : 30,
    restDelta: 0.01,
    restSpeed: 10
  };
};
var linearTween = function() {
  return {
    type: "keyframes",
    ease: "linear",
    duration: 0.3
  };
};
var keyframes = function(values) {
  return {
    type: "keyframes",
    duration: 0.8,
    values
  };
};
var defaultTransitions = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: criticallyDampedSpring,
  scaleY: criticallyDampedSpring,
  scale: criticallyDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: criticallyDampedSpring
};
var getDefaultTransition = function(valueKey, to) {
  var transitionFactory;
  if (isKeyframesTarget(to)) {
    transitionFactory = keyframes;
  } else {
    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;
  }
  return Object.assign({ to }, transitionFactory(to));
};

// node_modules/svelte-motion/src/render/dom/value-types/type-int.js
var int = Object.assign(Object.assign({}, number), { transform: Math.round });

// node_modules/svelte-motion/src/render/dom/value-types/number.js
var numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};

// node_modules/svelte-motion/src/render/dom/value-types/defaults.js
var defaultValueTypes = Object.assign(Object.assign({}, numberValueTypes), {
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
});
var getDefaultValueType = function(key) {
  return defaultValueTypes[key];
};

// node_modules/svelte-motion/src/render/dom/value-types/animatable-none.js
function getAnimatableNone(key, value) {
  var _a;
  var defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);
}

// node_modules/svelte-motion/src/animation/utils/transitions.js
function isTransitionDefined(_a) {
  _a.when;
  _a.delay;
  _a.delayChildren;
  _a.staggerChildren;
  _a.staggerDirection;
  _a.repeat;
  _a.repeatType;
  _a.repeatDelay;
  _a.from;
  var transition = __rest(_a, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from"]);
  return !!Object.keys(transition).length;
}
var legacyRepeatWarning = false;
function convertTransitionToAnimationOptions(_a) {
  var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = __rest(_a, ["ease", "times", "yoyo", "flip", "loop"]);
  var options = Object.assign({}, transition);
  if (times)
    options["offset"] = times;
  if (transition.duration)
    options["duration"] = secondsToMilliseconds(transition.duration);
  if (transition.repeatDelay)
    options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);
  if (ease) {
    options["ease"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  }
  if (transition.type === "tween")
    options.type = "keyframes";
  if (yoyo || loop || flip) {
    warning(!legacyRepeatWarning, "yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.");
    legacyRepeatWarning = true;
    if (yoyo) {
      options.repeatType = "reverse";
    } else if (loop) {
      options.repeatType = "loop";
    } else if (flip) {
      options.repeatType = "mirror";
    }
    options.repeat = loop || yoyo || flip || transition.repeat;
  }
  if (transition.type !== "spring")
    options.type = "keyframes";
  return options;
}
function getDelayFromTransition(transition, key) {
  var _a;
  var valueTransition = getValueTransition(transition, key) || {};
  return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;
}
function hydrateKeyframes(options) {
  if (Array.isArray(options.to) && options.to[0] === null) {
    options.to = __spreadArray([], __read(options.to));
    options.to[0] = options.from;
  }
  return options;
}
function getPopmotionAnimationOptions(transition, options, key) {
  var _a;
  if (Array.isArray(options.to)) {
    (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;
  }
  hydrateKeyframes(options);
  if (!isTransitionDefined(transition)) {
    transition = Object.assign(Object.assign({}, transition), getDefaultTransition(key, options.to));
  }
  return Object.assign(Object.assign({}, options), convertTransitionToAnimationOptions(transition));
}
function getAnimation(key, value, target, transition, onComplete) {
  var _a;
  var valueTransition = getValueTransition(transition, key);
  var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();
  var isTargetAnimatable = isAnimatable(key, target);
  if (origin === "none" && isTargetAnimatable && typeof target === "string") {
    origin = getAnimatableNone(key, target);
  } else if (isZero(origin) && typeof target === "string") {
    origin = getZeroUnit(target);
  } else if (!Array.isArray(target) && isZero(target) && typeof origin === "string") {
    target = getZeroUnit(origin);
  }
  var isOriginAnimatable = isAnimatable(key, origin);
  warning(isOriginAnimatable === isTargetAnimatable, "You are trying to animate " + key + ' from "' + origin + '" to "' + target + '". ' + origin + " is not an animatable value - to enable this animation set " + origin + " to a value animatable to " + target + " via the `style` property.");
  function start() {
    var options = {
      from: origin,
      to: target,
      velocity: value.getVelocity(),
      onComplete,
      onUpdate: function(v) {
        return value.set(v);
      }
    };
    return valueTransition.type === "inertia" || valueTransition.type === "decay" ? inertia(Object.assign(Object.assign({}, options), valueTransition)) : animate(Object.assign(Object.assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function(v) {
      var _a2;
      options.onUpdate(v);
      (_a2 = valueTransition.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition, v);
    }, onComplete: function() {
      var _a2;
      options.onComplete();
      (_a2 = valueTransition.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition);
    } }));
  }
  function set() {
    var _a2;
    value.set(target);
    onComplete();
    (_a2 = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition);
    return { stop: function() {
    } };
  }
  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;
}
function isZero(value) {
  return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
}
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType === "number" ? 0 : getAnimatableNone("", potentialUnitType);
}
function getValueTransition(transition, key) {
  return transition[key] || transition["default"] || transition;
}
function startAnimation(key, value, target, transition) {
  if (transition === void 0) {
    transition = {};
  }
  return value.start(function(onComplete) {
    var delayTimer;
    var controls;
    var animation = getAnimation(key, value, target, transition, onComplete);
    var delay = getDelayFromTransition(transition, key);
    var start = function() {
      return controls = animation();
    };
    if (delay) {
      delayTimer = setTimeout(start, secondsToMilliseconds(delay));
    } else {
      start();
    }
    return function() {
      clearTimeout(delayTimer);
      controls === null || controls === void 0 ? void 0 : controls.stop();
    };
  });
}

// node_modules/svelte-motion/src/utils/is-numerical-string.js
var isNumericalString = function(v) {
  return /^\-?\d*\.?\d+$/.test(v);
};

// node_modules/svelte-motion/src/utils/resolve-value.js
var isCustomValue = function(v) {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
var resolveFinalValueInKeyframes = function(v) {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
};

// node_modules/svelte-motion/src/render/dom/value-types/test.js
var testValueType = function(v) {
  return function(type) {
    return type.test(v);
  };
};

// node_modules/svelte-motion/src/render/dom/value-types/type-auto.js
var auto = {
  test: function(v) {
    return v === "auto";
  },
  parse: function(v) {
    return v;
  }
};

// node_modules/svelte-motion/src/render/dom/value-types/dimensions.js
var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
var findDimensionValueType = function(v) {
  return dimensionValueTypes.find(testValueType(v));
};

// node_modules/svelte-motion/src/render/dom/value-types/find.js
var valueTypes = __spreadArray(__spreadArray([], __read(dimensionValueTypes)), [color, complex]);
var findValueType = function(v) {
  return valueTypes.find(testValueType(v));
};

// node_modules/svelte-motion/src/render/utils/variants.js
function isVariantLabels(v) {
  return Array.isArray(v);
}
function isVariantLabel(v) {
  return typeof v === "string" || isVariantLabels(v);
}
function getCurrent(visualElement2) {
  var current = {};
  visualElement2.forEachValue(function(value, key) {
    return current[key] = value.get();
  });
  return current;
}
function getVelocity(visualElement2) {
  var velocity = {};
  visualElement2.forEachValue(function(value, key) {
    return velocity[key] = value.getVelocity();
  });
  return velocity;
}
function resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {
  var _a;
  if (currentValues === void 0) {
    currentValues = {};
  }
  if (currentVelocity === void 0) {
    currentVelocity = {};
  }
  if (typeof definition === "string") {
    definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];
  }
  return typeof definition === "function" ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity) : definition;
}
function resolveVariant(visualElement2, definition, custom) {
  var props = visualElement2.getProps();
  return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement2), getVelocity(visualElement2));
}
function checkIfControllingVariants(props) {
  var _a;
  return typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === "function" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);
}
function checkIfVariantNode(props) {
  return Boolean(checkIfControllingVariants(props) || props.variants);
}

// node_modules/svelte-motion/src/render/utils/setters.js
function setMotionValue(visualElement2, key, value) {
  if (visualElement2.hasValue(key)) {
    visualElement2.getValue(key).set(value);
  } else {
    visualElement2.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement2, definition) {
  var resolved = resolveVariant(visualElement2, definition);
  var _a = resolved ? visualElement2.makeTargetAnimatable(resolved, false) : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b;
  _a.transition;
  var target = __rest(_a, ["transitionEnd", "transition"]);
  target = Object.assign(Object.assign({}, target), transitionEnd);
  for (var key in target) {
    var value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement2, key, value);
  }
}
function setVariants(visualElement2, variantLabels) {
  var reversedLabels = __spreadArray([], __read(variantLabels)).reverse();
  reversedLabels.forEach(function(key) {
    var _a;
    var variant = visualElement2.getVariant(key);
    variant && setTarget(visualElement2, variant);
    (_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
      setVariants(child, variantLabels);
    });
  });
}
function setValues(visualElement2, definition) {
  if (Array.isArray(definition)) {
    return setVariants(visualElement2, definition);
  } else if (typeof definition === "string") {
    return setVariants(visualElement2, [definition]);
  } else {
    setTarget(visualElement2, definition);
  }
}
function checkTargetForNewValues(visualElement2, target, origin) {
  var _a, _b, _c;
  var _d;
  var newValueKeys = Object.keys(target).filter(function(key2) {
    return !visualElement2.hasValue(key2);
  });
  var numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (var i = 0; i < numNewValues; i++) {
    var key = newValueKeys[i];
    var targetValue = target[key];
    var value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement2.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && isNumericalString(value)) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone(key, targetValue);
    }
    visualElement2.addValue(key, motionValue(value));
    (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;
    visualElement2.setBaseTarget(key, value);
  }
}
function getOriginFromTransition(key, transition) {
  if (!transition)
    return;
  var valueTransition = transition[key] || transition["default"] || transition;
  return valueTransition.from;
}
function getOrigin(target, transition, visualElement2) {
  var _a, _b;
  var origin = {};
  for (var key in target) {
    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement2.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();
  }
  return origin;
}

// node_modules/svelte-motion/src/render/utils/animation.js
function animateVisualElement(visualElement2, definition, options) {
  if (options === void 0) {
    options = {};
  }
  visualElement2.notifyAnimationStart();
  var animation;
  if (Array.isArray(definition)) {
    var animations2 = definition.map(function(variant) {
      return animateVariant(visualElement2, variant, options);
    });
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement2, definition, options);
  } else {
    var resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement2, definition, options.custom) : definition;
    animation = animateTarget(visualElement2, resolvedDefinition, options);
  }
  return animation.then(function() {
    return visualElement2.notifyAnimationComplete(definition);
  });
}
function animateVariant(visualElement2, variant, options) {
  var _a;
  if (options === void 0) {
    options = {};
  }
  var resolved = resolveVariant(visualElement2, variant, options.custom);
  var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement2.getDefaultTransition() || {} : _b;
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  var getAnimation2 = resolved ? function() {
    return animateTarget(visualElement2, resolved, options);
  } : function() {
    return Promise.resolve();
  };
  var getChildAnimations = ((_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function(forwardDelay) {
    if (forwardDelay === void 0) {
      forwardDelay = 0;
    }
    var _a2 = transition.delayChildren, delayChildren = _a2 === void 0 ? 0 : _a2, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;
    return animateChildren(visualElement2, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : function() {
    return Promise.resolve();
  };
  var when = transition.when;
  if (when) {
    var _c = __read(when === "beforeChildren" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2], 2), first = _c[0], last = _c[1];
    return first().then(last);
  } else {
    return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);
  }
}
function animateTarget(visualElement2, definition, _a) {
  var _b;
  var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;
  var _e = visualElement2.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement2.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = __rest(_e, ["transition", "transitionEnd"]);
  if (transitionOverride)
    transition = transitionOverride;
  var animations2 = [];
  var animationTypeState = type && ((_b = visualElement2.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);
  for (var key in target) {
    var value = visualElement2.getValue(key);
    var valueTarget = target[key];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    var animation = startAnimation(key, value, valueTarget, Object.assign({ delay }, transition));
    animations2.push(animation);
  }
  return Promise.all(animations2).then(function() {
    transitionEnd && setTarget(visualElement2, transitionEnd);
  });
}
function animateChildren(visualElement2, variant, delayChildren, staggerChildren, staggerDirection, options) {
  if (delayChildren === void 0) {
    delayChildren = 0;
  }
  if (staggerChildren === void 0) {
    staggerChildren = 0;
  }
  if (staggerDirection === void 0) {
    staggerDirection = 1;
  }
  var animations2 = [];
  var maxStaggerDuration = (visualElement2.variantChildren.size - 1) * staggerChildren;
  var generateStaggerDuration = staggerDirection === 1 ? function(i) {
    if (i === void 0) {
      i = 0;
    }
    return i * staggerChildren;
  } : function(i) {
    if (i === void 0) {
      i = 0;
    }
    return maxStaggerDuration - i * staggerChildren;
  };
  Array.from(visualElement2.variantChildren).sort(sortByTreeOrder).forEach(function(child, i) {
    animations2.push(animateVariant(child, variant, Object.assign(Object.assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function() {
      return child.notifyAnimationComplete(variant);
    }));
  });
  return Promise.all(animations2);
}
function stopAnimation(visualElement2) {
  visualElement2.forEachValue(function(value) {
    return value.stop();
  });
}
function sortByTreeOrder(a, b) {
  return a.sortNodePosition(b);
}
function shouldBlockAnimation(_a, key) {
  var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;
  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}

// node_modules/svelte-motion/src/animation/animation-controls.js
function animationControls(startStopNotifier) {
  var hasMounted = false;
  var pendingAnimations = [];
  var subscribers = /* @__PURE__ */ new Set();
  var stopNotification;
  var controls = {
    subscribe: function(visualElement2) {
      if (subscribers.size === 0) {
        stopNotification = startStopNotifier == null ? void 0 : startStopNotifier();
      }
      subscribers.add(visualElement2);
      return function() {
        subscribers.delete(visualElement2);
        if (subscribers.size === 0) {
          stopNotification == null ? void 0 : stopNotification();
        }
      };
    },
    start: function(definition, transitionOverride) {
      if (hasMounted) {
        var animations_1 = [];
        subscribers.forEach(function(visualElement2) {
          animations_1.push(animateVisualElement(visualElement2, definition, {
            transitionOverride
          }));
        });
        return Promise.all(animations_1);
      } else {
        return new Promise(function(resolve) {
          pendingAnimations.push({
            animation: [definition, transitionOverride],
            resolve
          });
        });
      }
    },
    set: function(definition) {
      return subscribers.forEach(function(visualElement2) {
        setValues(visualElement2, definition);
      });
    },
    stop: function() {
      subscribers.forEach(function(visualElement2) {
        stopAnimation(visualElement2);
      });
    },
    mount: function() {
      hasMounted = true;
      pendingAnimations.forEach(function(_a) {
        var animation = _a.animation, resolve = _a.resolve;
        controls.start.apply(controls, __spreadArray([], __read(animation))).then(resolve);
      });
      return function() {
        hasMounted = false;
        controls.stop();
      };
    }
  };
  return controls;
}

// node_modules/svelte-motion/src/render/dom/projection/scale-correction.js
var valueScaleCorrection = {};
function addScaleCorrection(correctors) {
  for (var key in correctors) {
    valueScaleCorrection[key] = correctors[key];
  }
}

// node_modules/svelte-motion/src/utils/each-axis.js
function eachAxis(handler) {
  return [handler("x"), handler("y")];
}

// node_modules/svelte-motion/src/utils/noop.js
function noop2(any) {
  return any;
}

// node_modules/svelte-motion/src/utils/geometry/index.js
function convertBoundingBoxToAxisBox(_a) {
  var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertAxisBoxToBoundingBox(_a) {
  var x = _a.x, y = _a.y;
  return {
    top: y.min,
    bottom: y.max,
    left: x.min,
    right: x.max
  };
}
function transformBoundingBox(_a, transformPoint2) {
  var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;
  if (transformPoint2 === void 0) {
    transformPoint2 = noop2;
  }
  var topLeft = transformPoint2({ x: left, y: top });
  var bottomRight = transformPoint2({ x: right, y: bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function axisBox() {
  return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };
}
function copyAxisBox(box) {
  return {
    x: Object.assign({}, box.x),
    y: Object.assign({}, box.y)
  };
}
var zeroDelta = {
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
};
function delta() {
  return {
    x: Object.assign({}, zeroDelta),
    y: Object.assign({}, zeroDelta)
  };
}

// node_modules/svelte-motion/src/render/utils/is-draggable.js
function isDraggable(visualElement2) {
  var _a = visualElement2.getProps(), drag2 = _a.drag, _dragX = _a._dragX;
  return drag2 && !_dragX;
}

// node_modules/svelte-motion/src/utils/geometry/delta-apply.js
function resetAxis(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function resetBox(box, originBox) {
  resetAxis(box.x, originBox.x);
  resetAxis(box.y, originBox.y);
}
function scalePoint(point, scale2, originPoint) {
  var distanceFromOrigin = point - originPoint;
  var scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate, scale2, originPoint, boxScale) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, _a) {
  var x = _a.x, y = _a.y;
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
function applyAxisTransforms(final, axis, transforms, _a) {
  var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
  final.min = axis.min;
  final.max = axis.max;
  var axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  var originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
}
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
function applyBoxTransforms(finalBox, box, transforms) {
  applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);
  applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate, scale2, origin, boxScale) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  if (origin === void 0) {
    origin = 0.5;
  }
  var originPoint = mix(axis.min, axis.max, origin) - translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, _a) {
  var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);
}
function removeBoxTransforms(box, transforms) {
  removeAxisTransforms(box.x, transforms, xKeys);
  removeAxisTransforms(box.y, transforms, yKeys);
}
function applyTreeDeltas(box, treeScale, treePath) {
  var treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  var node;
  var delta2;
  for (var i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta2 = node.getLayoutState().delta;
    treeScale.x *= delta2.x.scale;
    treeScale.y *= delta2.y.scale;
    applyBoxDelta(box, delta2);
    if (isDraggable(node)) {
      applyBoxTransforms(box, box, node.getLatestValues());
    }
  }
}

// node_modules/svelte-motion/src/utils/geometry/delta-calc.js
var clampProgress = function(v) {
  return clamp(0, 1, v);
};
function isNear(value, target, maxDistance) {
  if (target === void 0) {
    target = 0;
  }
  if (maxDistance === void 0) {
    maxDistance = 0.01;
  }
  return distance(value, target) < maxDistance;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function calcOrigin(source, target) {
  var origin = 0.5;
  var sourceLength = calcLength(source);
  var targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clampProgress(origin);
}
function updateAxisDelta(delta2, source, target, origin) {
  if (origin === void 0) {
    origin = 0.5;
  }
  delta2.origin = origin;
  delta2.originPoint = mix(source.min, source.max, delta2.origin);
  delta2.scale = calcLength(target) / calcLength(source);
  if (isNear(delta2.scale, 1, 1e-4))
    delta2.scale = 1;
  delta2.translate = mix(target.min, target.max, delta2.origin) - delta2.originPoint;
  if (isNear(delta2.translate))
    delta2.translate = 0;
}
function updateBoxDelta(delta2, source, target, origin) {
  updateAxisDelta(delta2.x, source.x, target.x, defaultOrigin(origin.originX));
  updateAxisDelta(delta2.y, source.y, target.y, defaultOrigin(origin.originY));
}
function defaultOrigin(origin) {
  return typeof origin === "number" ? origin : 0.5;
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(projection, parentProjection) {
  calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);
  calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);
}

// node_modules/svelte-motion/src/value/utils/is-motion-value.js
var isMotionValue = function(value) {
  return value !== null && typeof value === "object" && value.getVelocity;
};

// node_modules/svelte-motion/src/render/utils/state.js
var createProjectionState = function() {
  return {
    isEnabled: false,
    isTargetLocked: false,
    target: axisBox(),
    targetFinal: axisBox()
  };
};
function createLayoutState() {
  return {
    isHydrated: false,
    layout: axisBox(),
    layoutCorrected: axisBox(),
    treeScale: { x: 1, y: 1 },
    delta: delta(),
    deltaFinal: delta(),
    deltaTransform: ""
  };
}
var zeroLayout = createLayoutState();

// node_modules/svelte-motion/src/render/html/utils/build-projection-transform.js
function buildLayoutProjectionTransform(_a, treeScale, latestTransform) {
  var x = _a.x, y = _a.y;
  var xTranslate = x.translate / treeScale.x;
  var yTranslate = y.translate / treeScale.y;
  var transform2 = "translate3d(" + xTranslate + "px, " + yTranslate + "px, 0) ";
  if (latestTransform) {
    var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;
    if (rotate)
      transform2 += "rotate(" + rotate + ") ";
    if (rotateX)
      transform2 += "rotateX(" + rotateX + ") ";
    if (rotateY)
      transform2 += "rotateY(" + rotateY + ") ";
  }
  transform2 += "scale(" + x.scale + ", " + y.scale + ")";
  return !latestTransform && transform2 === identityProjection ? "" : transform2;
}
function buildLayoutProjectionTransformOrigin(_a) {
  var deltaFinal = _a.deltaFinal;
  return deltaFinal.x.origin * 100 + "% " + deltaFinal.y.origin * 100 + "% 0";
}
var identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });

// node_modules/svelte-motion/src/animation/utils/is-animation-controls.js
var isAnimationControls = function(v) {
  return typeof v === "object" && typeof v.start === "function";
};

// node_modules/svelte-motion/src/utils/shallow-compare.js
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  var prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (var i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i])
      return false;
  }
  return true;
}

// node_modules/svelte-motion/src/render/utils/types.js
var AnimationType;
(function(AnimationType2) {
  AnimationType2["Animate"] = "animate";
  AnimationType2["Hover"] = "whileHover";
  AnimationType2["Tap"] = "whileTap";
  AnimationType2["Drag"] = "whileDrag";
  AnimationType2["Focus"] = "whileFocus";
  AnimationType2["Exit"] = "exit";
})(AnimationType || (AnimationType = {}));

// node_modules/svelte-motion/src/render/utils/animation-state.js
var variantPriorityOrder = [
  AnimationType.Animate,
  AnimationType.Hover,
  AnimationType.Tap,
  AnimationType.Drag,
  AnimationType.Focus,
  AnimationType.Exit
];
var reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder)).reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement2) {
  return function(animations2) {
    return Promise.all(animations2.map(function(_a) {
      var animation = _a.animation, options = _a.options;
      return animateVisualElement(visualElement2, animation, options);
    }));
  };
}
function createAnimationState(visualElement2) {
  var animate3 = animateList(visualElement2);
  var state = createState();
  var allAnimatedKeys = {};
  var isInitialRender = true;
  var buildResolvedTypeValues = function(acc, definition) {
    var resolved = resolveVariant(visualElement2, definition);
    if (resolved) {
      resolved.transition;
      var transitionEnd = resolved.transitionEnd, target = __rest(resolved, ["transition", "transitionEnd"]);
      acc = Object.assign(Object.assign(Object.assign({}, acc), target), transitionEnd);
    }
    return acc;
  };
  function isAnimated(key) {
    return allAnimatedKeys[key] !== void 0;
  }
  function setAnimateFunction(makeAnimator) {
    animate3 = makeAnimator(visualElement2);
  }
  function animateChanges(options, changedActiveType) {
    var _a;
    var props = visualElement2.getProps();
    var context = visualElement2.getVariantContext(true) || {};
    var animations2 = [];
    var removedKeys = /* @__PURE__ */ new Set();
    var encounteredKeys = {};
    var removedVariantIndex = Infinity;
    var _loop_1 = function(i2) {
      var type = reversePriorityOrder[i2];
      var typeState = state[type];
      var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];
      var propIsVariant = isVariantLabel(prop);
      var activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement2.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = Object.assign({}, encounteredKeys);
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        return "continue";
      }
      var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant;
      var definitionList = Array.isArray(prop) ? prop : [prop];
      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;
      var allKeys = Object.assign(Object.assign({}, prevResolvedValues), resolvedValues);
      var markToAnimate = function(key2) {
        shouldAnimateType = true;
        removedKeys.delete(key2);
        typeState.needsAnimating[key2] = true;
      };
      for (var key in allKeys) {
        var next = resolvedValues[key];
        var prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev)) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = Object.assign(Object.assign({}, encounteredKeys), resolvedValues);
      }
      if (isInitialRender && visualElement2.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push.apply(animations2, __spreadArray([], __read(definitionList.map(function(animation) {
          return {
            animation,
            options: Object.assign({ type }, options)
          };
        }))));
      }
    };
    for (var i = 0; i < numAnimationTypes; i++) {
      _loop_1(i);
    }
    allAnimatedKeys = Object.assign({}, encounteredKeys);
    if (removedKeys.size) {
      var fallbackAnimation_1 = {};
      removedKeys.forEach(function(key) {
        var fallbackTarget = visualElement2.getBaseTarget(key);
        if (fallbackTarget !== void 0) {
          fallbackAnimation_1[key] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation_1 });
    }
    var shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement2.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate3(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options) {
    var _a;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    return animateChanges(options, type);
  }
  return {
    isAnimated,
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: function() {
      return state;
    }
  };
}
function variantsHaveChanged(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (isVariantLabels(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive) {
  if (isActive === void 0) {
    isActive = false;
  }
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  var _a;
  return _a = {}, _a[AnimationType.Animate] = createTypeState(true), _a[AnimationType.Hover] = createTypeState(), _a[AnimationType.Tap] = createTypeState(), _a[AnimationType.Drag] = createTypeState(), _a[AnimationType.Focus] = createTypeState(), _a[AnimationType.Exit] = createTypeState(), _a;
}

// node_modules/svelte-motion/src/render/utils/lifecycles.js
var names = [
  "LayoutMeasure",
  "BeforeLayoutMeasure",
  "LayoutUpdate",
  "ViewportBoxUpdate",
  "Update",
  "Render",
  "AnimationComplete",
  "LayoutAnimationComplete",
  "AnimationStart",
  "SetAxisTarget",
  "Unmount"
];
function createLifecycles() {
  var managers = names.map(function() {
    return new SubscriptionManager();
  });
  var propSubscriptions = {};
  var lifecycles = {
    clearAllListeners: function() {
      return managers.forEach(function(manager) {
        return manager.clear();
      });
    },
    updatePropListeners: function(props) {
      return names.forEach(function(name) {
        var _a;
        (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);
        var on = "on" + name;
        var propListener = props[on];
        if (propListener) {
          propSubscriptions[name] = lifecycles[on](propListener);
        }
      });
    }
  };
  managers.forEach(function(manager, i) {
    lifecycles["on" + names[i]] = function(handler) {
      return manager.add(handler);
    };
    lifecycles["notify" + names[i]] = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return manager.notify.apply(manager, __spreadArray([], __read(args)));
    };
  });
  return lifecycles;
}

// node_modules/svelte-motion/src/render/utils/motion-values.js
function updateMotionValuesFromProps(element2, next, prev) {
  var _a;
  for (var key in next) {
    var nextValue = next[key];
    var prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element2.addValue(key, nextValue);
    } else if (isMotionValue(prevValue)) {
      element2.addValue(key, motionValue(nextValue));
    } else if (prevValue !== nextValue) {
      if (element2.hasValue(key)) {
        var existingValue = element2.getValue(key);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        element2.addValue(key, motionValue((_a = element2.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));
      }
    }
  }
  for (var key in prev) {
    if (next[key] === void 0)
      element2.removeValue(key);
  }
  return next;
}

// node_modules/svelte-motion/src/render/utils/projection.js
function updateLayoutDeltas(_a, _b, treePath, transformOrigin) {
  var delta2 = _a.delta, layout = _a.layout, layoutCorrected = _a.layoutCorrected, treeScale = _a.treeScale;
  var target = _b.target;
  resetBox(layoutCorrected, layout);
  applyTreeDeltas(layoutCorrected, treeScale, treePath);
  updateBoxDelta(delta2, layoutCorrected, target, transformOrigin);
}

// node_modules/svelte-motion/src/render/utils/compare-by-depth.js
var compareByDepth = function(a, b) {
  return a.depth - b.depth;
};

// node_modules/svelte-motion/src/render/utils/flat-tree.js
var FlatTree = (
  /** @class */
  function() {
    function FlatTree2() {
      this.children = [];
      this.isDirty = false;
    }
    FlatTree2.prototype.add = function(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    };
    FlatTree2.prototype.remove = function(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    };
    FlatTree2.prototype.forEach = function(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      var numChildren = this.children.length;
      for (var i = 0; i < numChildren; i++) {
        callback(this.children[i]);
      }
    };
    return FlatTree2;
  }()
);

// node_modules/svelte-motion/src/motion/features/layout/utils.js
function tweenAxis(target, prev, next, p) {
  target.min = mix(prev.min, next.min, p);
  target.max = mix(prev.max, next.max, p);
}
function calcRelativeOffsetAxis(parent, child) {
  return {
    min: child.min - parent.min,
    max: child.max - parent.min
  };
}
function calcRelativeOffset(parent, child) {
  return {
    x: calcRelativeOffsetAxis(parent.x, child.x),
    y: calcRelativeOffsetAxis(parent.y, child.y)
  };
}

// node_modules/svelte-motion/src/render/dom/projection/relative-set.js
function setCurrentViewportBox(visualElement2) {
  var projectionParent = visualElement2.getProjectionParent();
  if (!projectionParent) {
    visualElement2.rebaseProjectionTarget();
    return;
  }
  var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement2.getLayoutState().layout);
  eachAxis(function(axis) {
    visualElement2.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);
  });
}

// node_modules/svelte-motion/src/render/index.js
var visualElement = function(_a) {
  var _b = _a.treeType, treeType = _b === void 0 ? "" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps3 = _a.scrapeMotionValuesFromProps;
  return function(_a2, options) {
    var parent = _a2.parent, props = _a2.props, presenceId2 = _a2.presenceId, blockInitialAnimation = _a2.blockInitialAnimation, visualState = _a2.visualState;
    if (options === void 0) {
      options = {};
    }
    var latestValues = visualState.latestValues, renderState = visualState.renderState;
    var instance35;
    var lifecycles = createLifecycles();
    var projection = createProjectionState();
    var projectionParent;
    var leadProjection = projection;
    var leadLatestValues = latestValues;
    var unsubscribeFromLeadVisualElement;
    var layoutState2 = createLayoutState();
    var crossfader;
    var hasViewportBoxUpdated = false;
    var values = /* @__PURE__ */ new Map();
    var valueSubscriptions = /* @__PURE__ */ new Map();
    var prevMotionValues = {};
    var projectionTargetProgress;
    var baseTarget = Object.assign({}, latestValues);
    var removeFromVariantTree;
    function render() {
      if (!instance35)
        return;
      if (element2.isProjectionReady()) {
        applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);
        updateBoxDelta(layoutState2.deltaFinal, layoutState2.layoutCorrected, leadProjection.targetFinal, latestValues);
      }
      triggerBuild();
      renderInstance(instance35, renderState);
    }
    function triggerBuild() {
      var valuesToRender = latestValues;
      if (crossfader && crossfader.isActive()) {
        var crossfadedValues = crossfader.getCrossfadeState(element2);
        if (crossfadedValues)
          valuesToRender = crossfadedValues;
      }
      build(element2, renderState, valuesToRender, leadProjection, layoutState2, options, props);
    }
    function update() {
      lifecycles.notifyUpdate(latestValues);
    }
    function updateLayoutProjection() {
      if (!element2.isProjectionReady())
        return;
      var delta2 = layoutState2.delta, treeScale = layoutState2.treeScale;
      var prevTreeScaleX = treeScale.x;
      var prevTreeScaleY = treeScale.y;
      var prevDeltaTransform = layoutState2.deltaTransform;
      updateLayoutDeltas(layoutState2, leadProjection, element2.path, latestValues);
      hasViewportBoxUpdated && element2.notifyViewportBoxUpdate(leadProjection.target, delta2);
      hasViewportBoxUpdated = false;
      var deltaTransform = buildLayoutProjectionTransform(delta2, treeScale);
      if (deltaTransform !== prevDeltaTransform || // Also compare calculated treeScale, for values that rely on this only for scale correction
      prevTreeScaleX !== treeScale.x || prevTreeScaleY !== treeScale.y) {
        element2.scheduleRender();
      }
      layoutState2.deltaTransform = deltaTransform;
    }
    function updateTreeLayoutProjection() {
      element2.layoutTree.forEach(fireUpdateLayoutProjection);
    }
    function bindToMotionValue(key2, value2) {
      var removeOnChange = value2.onChange(function(latestValue) {
        latestValues[key2] = latestValue;
        props.onUpdate && es_default.update(update, false, true);
      });
      var removeOnRenderRequest = value2.onRenderRequest(element2.scheduleRender);
      valueSubscriptions.set(key2, function() {
        removeOnChange();
        removeOnRenderRequest();
      });
    }
    var initialMotionValues = scrapeMotionValuesFromProps3(props);
    for (var key in initialMotionValues) {
      var value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
    var isControllingVariants = checkIfControllingVariants(props);
    var isVariantNode = checkIfVariantNode(props);
    var element2 = Object.assign(Object.assign({
      treeType,
      /**
       * This is a mirror of the internal instance prop, which keeps
       * VisualElement type-compatible with React's RefObject.
       */
      current: null,
      /**
       * The depth of this visual element within the visual element tree.
       */
      depth: parent ? parent.depth + 1 : 0,
      parent,
      children: /* @__PURE__ */ new Set(),
      /**
       * An ancestor path back to the root visual element. This is used
       * by layout projection to quickly recurse back up the tree.
       */
      path: parent ? __spreadArray(__spreadArray([], __read(parent.path)), [parent]) : [],
      layoutTree: parent ? parent.layoutTree : new FlatTree(),
      /**
       *
       */
      presenceId: presenceId2,
      projection,
      /**
       * If this component is part of the variant tree, it should track
       * any children that are also part of the tree. This is essentially
       * a shadow tree to simplify logic around how to stagger over children.
       */
      variantChildren: isVariantNode ? /* @__PURE__ */ new Set() : void 0,
      /**
       * Whether this instance is visible. This can be changed imperatively
       * by AnimateSharedLayout, is analogous to CSS's visibility in that
       * hidden elements should take up layout, and needs enacting by the configured
       * render function.
       */
      isVisible: void 0,
      /**
       * Normally, if a component is controlled by a parent's variants, it can
       * rely on that ancestor to trigger animations further down the tree.
       * However, if a component is created after its parent is mounted, the parent
       * won't trigger that mount animation so the child needs to.
       *
       * TODO: This might be better replaced with a method isParentMounted
       */
      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),
      /**
       * This can be set by AnimatePresence to force components that mount
       * at the same time as it to mount as if they have initial={false} set.
       */
      blockInitialAnimation,
      /**
       * Determine whether this component has mounted yet. This is mostly used
       * by variant children to determine whether they need to trigger their
       * own animations on mount.
       */
      isMounted: function() {
        return Boolean(instance35);
      },
      mount: function(newInstance) {
        instance35 = element2.current = newInstance;
        element2.pointTo(element2);
        if (isVariantNode && parent && !isControllingVariants) {
          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element2);
        }
        parent === null || parent === void 0 ? void 0 : parent.children.add(element2);
      },
      /**
       *
       */
      unmount: function() {
        cancelSync.update(update);
        cancelSync.render(render);
        cancelSync.preRender(element2.updateLayoutProjection);
        valueSubscriptions.forEach(function(remove) {
          return remove();
        });
        element2.stopLayoutAnimation();
        element2.layoutTree.remove(element2);
        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();
        parent === null || parent === void 0 ? void 0 : parent.children.delete(element2);
        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();
        lifecycles.clearAllListeners();
      },
      /**
       * Add a child visual element to our set of children.
       */
      addVariantChild: function(child) {
        var _a3;
        var closestVariantNode = element2.getClosestVariantNode();
        if (closestVariantNode) {
          (_a3 = closestVariantNode.variantChildren) === null || _a3 === void 0 ? void 0 : _a3.add(child);
          return function() {
            return closestVariantNode.variantChildren.delete(child);
          };
        }
      },
      sortNodePosition: function(other) {
        if (!sortNodePosition || treeType !== other.treeType)
          return 0;
        return sortNodePosition(element2.getInstance(), other.getInstance());
      },
      /**
       * Returns the closest variant node in the tree starting from
       * this visual element.
       */
      getClosestVariantNode: function() {
        return isVariantNode ? element2 : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();
      },
      /**
       * A method that schedules an update to layout projections throughout
       * the tree. We inherit from the parent so there's only ever one
       * job scheduled on the next frame - that of the root visual element.
       */
      scheduleUpdateLayoutProjection: parent ? parent.scheduleUpdateLayoutProjection : function() {
        return es_default.preRender(element2.updateTreeLayoutProjection, false, true);
      },
      /**
       * Expose the latest layoutId prop.
       */
      getLayoutId: function() {
        return props.layoutId;
      },
      /**
       * Returns the current instance.
       */
      getInstance: function() {
        return instance35;
      },
      /**
       * Get/set the latest static values.
       */
      getStaticValue: function(key2) {
        return latestValues[key2];
      },
      setStaticValue: function(key2, value2) {
        return latestValues[key2] = value2;
      },
      /**
       * Returns the latest motion value state. Currently only used to take
       * a snapshot of the visual element - perhaps this can return the whole
       * visual state
       */
      getLatestValues: function() {
        return latestValues;
      },
      /**
       * Set the visiblity of the visual element. If it's changed, schedule
       * a render to reflect these changes.
       */
      setVisibility: function(visibility) {
        if (element2.isVisible === visibility)
          return;
        element2.isVisible = visibility;
        element2.scheduleRender();
      },
      /**
       * Make a target animatable by Popmotion. For instance, if we're
       * trying to animate width from 100px to 100vw we need to measure 100vw
       * in pixels to determine what we really need to animate to. This is also
       * pluggable to support Framer's custom value types like Color,
       * and CSS variables.
       */
      makeTargetAnimatable: function(target, canMutate) {
        if (canMutate === void 0) {
          canMutate = true;
        }
        return makeTargetAnimatable(element2, target, props, canMutate);
      },
      // Motion values ========================
      /**
       * Add a motion value and bind it to this visual element.
       */
      addValue: function(key2, value2) {
        if (element2.hasValue(key2))
          element2.removeValue(key2);
        values.set(key2, value2);
        latestValues[key2] = value2.get();
        bindToMotionValue(key2, value2);
      },
      /**
       * Remove a motion value and unbind any active subscriptions.
       */
      removeValue: function(key2) {
        var _a3;
        values.delete(key2);
        (_a3 = valueSubscriptions.get(key2)) === null || _a3 === void 0 ? void 0 : _a3();
        valueSubscriptions.delete(key2);
        delete latestValues[key2];
        removeValueFromRenderState(key2, renderState);
      },
      /**
       * Check whether we have a motion value for this key
       */
      hasValue: function(key2) {
        return values.has(key2);
      },
      /**
       * Get a motion value for this key. If called with a default
       * value, we'll create one if none exists.
       */
      getValue: function(key2, defaultValue) {
        var value2 = values.get(key2);
        if (value2 === void 0 && defaultValue !== void 0) {
          value2 = motionValue(defaultValue);
          element2.addValue(key2, value2);
        }
        return value2;
      },
      /**
       * Iterate over our motion values.
       */
      forEachValue: function(callback) {
        return values.forEach(callback);
      },
      /**
       * If we're trying to animate to a previously unencountered value,
       * we need to check for it in our state and as a last resort read it
       * directly from the instance (which might have performance implications).
       */
      readValue: function(key2) {
        var _a3;
        return (_a3 = latestValues[key2]) !== null && _a3 !== void 0 ? _a3 : readValueFromInstance(instance35, key2, options);
      },
      /**
       * Set the base target to later animate back to. This is currently
       * only hydrated on creation and when we first read a value.
       */
      setBaseTarget: function(key2, value2) {
        baseTarget[key2] = value2;
      },
      /**
       * Find the base target for a value thats been removed from all animation
       * props.
       */
      getBaseTarget: function(key2) {
        if (getBaseTarget) {
          var target = getBaseTarget(props, key2);
          if (target !== void 0 && !isMotionValue(target))
            return target;
        }
        return baseTarget[key2];
      }
    }, lifecycles), {
      /**
       * Build the renderer state based on the latest visual state.
       */
      build: function() {
        triggerBuild();
        return renderState;
      },
      /**
       * Schedule a render on the next animation frame.
       */
      scheduleRender: function() {
        es_default.render(render, false, true);
      },
      /**
       * Synchronously fire render. It's prefered that we batch renders but
       * in many circumstances, like layout measurement, we need to run this
       * synchronously. However in those instances other measures should be taken
       * to batch reads/writes.
       */
      syncRender: render,
      /**
       * Update the provided props. Ensure any newly-added motion values are
       * added to our map, old ones removed, and listeners updated.
       */
      setProps: function(newProps) {
        props = newProps;
        lifecycles.updatePropListeners(newProps);
        prevMotionValues = updateMotionValuesFromProps(element2, scrapeMotionValuesFromProps3(props), prevMotionValues);
      },
      getProps: function() {
        return props;
      },
      // Variants ==============================
      /**
       * Returns the variant definition with a given name.
       */
      getVariant: function(name) {
        var _a3;
        return (_a3 = props.variants) === null || _a3 === void 0 ? void 0 : _a3[name];
      },
      /**
       * Returns the defined default transition on this component.
       */
      getDefaultTransition: function() {
        return props.transition;
      },
      /**
       * Used by child variant nodes to get the closest ancestor variant props.
       */
      getVariantContext: function(startAtParent) {
        if (startAtParent === void 0) {
          startAtParent = false;
        }
        if (startAtParent)
          return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();
        if (!isControllingVariants) {
          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};
          if (props.initial !== void 0) {
            context_1.initial = props.initial;
          }
          return context_1;
        }
        var context = {};
        for (var i = 0; i < numVariantProps; i++) {
          var name_1 = variantProps[i];
          var prop = props[name_1];
          if (isVariantLabel(prop) || prop === false) {
            context[name_1] = prop;
          }
        }
        return context;
      },
      // Layout projection ==============================
      /**
       * Enable layout projection for this visual element. Won't actually
       * occur until we also have hydrated layout measurements.
       */
      enableLayoutProjection: function() {
        projection.isEnabled = true;
        element2.layoutTree.add(element2);
      },
      /**
       * Lock the projection target, for instance when dragging, so
       * nothing else can try and animate it.
       */
      lockProjectionTarget: function() {
        projection.isTargetLocked = true;
      },
      unlockProjectionTarget: function() {
        element2.stopLayoutAnimation();
        projection.isTargetLocked = false;
      },
      getLayoutState: function() {
        return layoutState2;
      },
      setCrossfader: function(newCrossfader) {
        crossfader = newCrossfader;
      },
      isProjectionReady: function() {
        return projection.isEnabled && projection.isHydrated && layoutState2.isHydrated;
      },
      /**
       * Start a layout animation on a given axis.
       */
      startLayoutAnimation: function(axis, transition, isRelative) {
        if (isRelative === void 0) {
          isRelative = false;
        }
        var progress2 = element2.getProjectionAnimationProgress()[axis];
        var _a3 = isRelative ? projection.relativeTarget[axis] : projection.target[axis], min = _a3.min, max = _a3.max;
        var length = max - min;
        progress2.clearListeners();
        progress2.set(min);
        progress2.set(min);
        progress2.onChange(function(v) {
          element2.setProjectionTargetAxis(axis, v, v + length, isRelative);
        });
        return element2.animateMotionValue(axis, progress2, 0, transition);
      },
      /**
       * Stop layout animations.
       */
      stopLayoutAnimation: function() {
        eachAxis(function(axis) {
          return element2.getProjectionAnimationProgress()[axis].stop();
        });
      },
      /**
       * Measure the current viewport box with or without transforms.
       * Only measures axis-aligned boxes, rotate and skew must be manually
       * removed with a re-render to work.
       */
      measureViewportBox: function(withTransform) {
        if (withTransform === void 0) {
          withTransform = true;
        }
        var viewportBox = measureViewportBox(instance35, options);
        if (!withTransform)
          removeBoxTransforms(viewportBox, latestValues);
        return viewportBox;
      },
      /**
       * Get the motion values tracking the layout animations on each
       * axis. Lazy init if not already created.
       */
      getProjectionAnimationProgress: function() {
        projectionTargetProgress || (projectionTargetProgress = {
          x: motionValue(0),
          y: motionValue(0)
        });
        return projectionTargetProgress;
      },
      /**
       * Update the projection of a single axis. Schedule an update to
       * the tree layout projection.
       */
      setProjectionTargetAxis: function(axis, min, max, isRelative) {
        if (isRelative === void 0) {
          isRelative = false;
        }
        var target;
        if (isRelative) {
          if (!projection.relativeTarget) {
            projection.relativeTarget = axisBox();
          }
          target = projection.relativeTarget[axis];
        } else {
          projection.relativeTarget = void 0;
          target = projection.target[axis];
        }
        projection.isHydrated = true;
        target.min = min;
        target.max = max;
        hasViewportBoxUpdated = true;
        lifecycles.notifySetAxisTarget();
      },
      /**
       * Rebase the projection target on top of the provided viewport box
       * or the measured layout. This ensures that non-animating elements
       * don't fall out of sync differences in measurements vs projections
       * after a page scroll or other relayout.
       */
      rebaseProjectionTarget: function(force, box) {
        if (box === void 0) {
          box = layoutState2.layout;
        }
        var _a3 = element2.getProjectionAnimationProgress(), x = _a3.x, y = _a3.y;
        var shouldRebase = !projection.relativeTarget && !projection.isTargetLocked && !x.isAnimating() && !y.isAnimating();
        if (force || shouldRebase) {
          eachAxis(function(axis) {
            var _a4 = box[axis], min = _a4.min, max = _a4.max;
            element2.setProjectionTargetAxis(axis, min, max);
          });
        }
      },
      /**
       * Notify the visual element that its layout is up-to-date.
       * Currently Animate.tsx uses this to check whether a layout animation
       * needs to be performed.
       */
      notifyLayoutReady: function(config) {
        setCurrentViewportBox(element2);
        element2.notifyLayoutUpdate(layoutState2.layout, element2.prevViewportBox || layoutState2.layout, config);
      },
      /**
       * Temporarily reset the transform of the instance.
       */
      resetTransform: function() {
        return resetTransform(element2, instance35, props);
      },
      restoreTransform: function() {
        return restoreTransform(instance35, renderState);
      },
      updateLayoutProjection,
      updateTreeLayoutProjection: function() {
        element2.layoutTree.forEach(fireResolveRelativeTargetBox);
        es_default.preRender(updateTreeLayoutProjection, false, true);
      },
      getProjectionParent: function() {
        if (projectionParent === void 0) {
          var foundParent = false;
          for (var i = element2.path.length - 1; i >= 0; i--) {
            var ancestor = element2.path[i];
            if (ancestor.projection.isEnabled) {
              foundParent = ancestor;
              break;
            }
          }
          projectionParent = foundParent;
        }
        return projectionParent;
      },
      resolveRelativeTargetBox: function() {
        var relativeParent = element2.getProjectionParent();
        if (!projection.relativeTarget || !relativeParent)
          return;
        calcRelativeBox(projection, relativeParent.projection);
        if (isDraggable(relativeParent)) {
          var target = projection.target;
          applyBoxTransforms(target, target, relativeParent.getLatestValues());
        }
      },
      shouldResetTransform: function() {
        return Boolean(props._layoutResetTransform);
      },
      /**
       *
       */
      pointTo: function(newLead) {
        leadProjection = newLead.projection;
        leadLatestValues = newLead.getLatestValues();
        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();
        unsubscribeFromLeadVisualElement = pipe(newLead.onSetAxisTarget(element2.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function() {
          var _a3;
          if (element2.isPresent) {
            element2.presence = Presence.Present;
          } else {
            (_a3 = element2.layoutSafeToRemove) === null || _a3 === void 0 ? void 0 : _a3.call(element2);
          }
        }));
      },
      // TODO: Clean this up
      isPresent: true,
      presence: Presence.Entering
    });
    return element2;
  };
};
function fireResolveRelativeTargetBox(child) {
  child.resolveRelativeTargetBox();
}
function fireUpdateLayoutProjection(child) {
  child.updateLayoutProjection();
}
var variantProps = __spreadArray(["initial"], __read(variantPriorityOrder));
var numVariantProps = variantProps.length;

// node_modules/svelte-motion/src/motion/utils/valid-prop.js
var validMotionProps = /* @__PURE__ */ new Set([
  "initial",
  "animate",
  "exit",
  "style",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "layout",
  "layoutId",
  "onLayoutAnimationComplete",
  "onViewportBoxUpdate",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "drag",
  "dragControls",
  "dragListener",
  "dragConstraints",
  "dragDirectionLock",
  "_dragX",
  "_dragY",
  "dragElastic",
  "dragMomentum",
  "dragPropagation",
  "dragTransition",
  "whileDrag",
  "onPan",
  "onPanStart",
  "onPanEnd",
  "onPanSessionStart",
  "onTap",
  "onTapStart",
  "onTapCancel",
  "onHoverStart",
  "onHoverEnd",
  "whileFocus",
  "whileTap",
  "whileHover"
]);
function isValidMotionProp(key) {
  return validMotionProps.has(key);
}

// node_modules/svelte-motion/src/context/PresenceContext.js
var PresenceContext = (c) => getDomContext("Presence", c) || writable(null);

// node_modules/svelte-motion/src/components/AnimatePresence/use-presence.js
var counter = 0;
var incrementId = () => counter++;
function isPresent(context) {
  return context === null ? true : context.isPresent;
}
var useIsPresent = (isCustom = false) => {
  let presenceContext = getContext(PresenceContext) || PresenceContext(isCustom);
  return derived(presenceContext, ($v) => $v === null ? true : $v.isPresent);
};
var usePresence = (isCustom = false) => {
  const context = getContext(PresenceContext) || PresenceContext(isCustom);
  const id = get_store_value(context) === null ? void 0 : incrementId();
  onMount(() => {
    if (get_store_value(context) !== null) {
      get_store_value(context).register(id);
    }
  });
  if (get_store_value(context) === null) {
    return readable([true, null]);
  }
  return derived(
    context,
    ($v) => !$v.isPresent && $v.onExitComplete ? [false, () => {
      var _a;
      return (_a = $v.onExitComplete) == null ? void 0 : _a.call($v, id);
    }] : [true]
  );
};

// node_modules/svelte-motion/src/context/LayoutGroupContext.js
var LayoutGroupContext = (c) => getDomContext("LayoutGroup", c) || writable(null);

// node_modules/svelte-motion/src/render/dom/projection/utils.js
function isProjecting(visualElement2) {
  var isEnabled = visualElement2.projection.isEnabled;
  return isEnabled || visualElement2.shouldResetTransform();
}
function collectProjectingAncestors(visualElement2, ancestors) {
  if (ancestors === void 0) {
    ancestors = [];
  }
  var parent = visualElement2.parent;
  if (parent)
    collectProjectingAncestors(parent, ancestors);
  if (isProjecting(visualElement2))
    ancestors.push(visualElement2);
  return ancestors;
}
function collectProjectingChildren(visualElement2) {
  var children2 = [];
  var addChild = function(child) {
    if (isProjecting(child))
      children2.push(child);
    child.children.forEach(addChild);
  };
  visualElement2.children.forEach(addChild);
  return children2.sort(compareByDepth);
}
function updateLayoutMeasurement(visualElement2) {
  if (visualElement2.shouldResetTransform())
    return;
  var layoutState2 = visualElement2.getLayoutState();
  visualElement2.notifyBeforeLayoutMeasure(layoutState2.layout);
  layoutState2.isHydrated = true;
  layoutState2.layout = visualElement2.measureViewportBox();
  layoutState2.layoutCorrected = copyAxisBox(layoutState2.layout);
  visualElement2.notifyLayoutMeasure(layoutState2.layout, visualElement2.prevViewportBox || layoutState2.layout);
  es_default.update(function() {
    return visualElement2.rebaseProjectionTarget();
  });
}
function snapshotViewportBox(visualElement2, nc) {
  if (visualElement2.shouldResetTransform())
    return;
  if (!nc) visualElement2.prevViewportBox = visualElement2.measureViewportBox(false);
  visualElement2.rebaseProjectionTarget(false, visualElement2.prevViewportBox);
}

// node_modules/svelte-motion/src/render/dom/utils/batch-layout.js
var unresolvedJobs = /* @__PURE__ */ new Set();
var layoutState = {
  isMeasuringLayout: false
};
function pushJob(stack, job, pointer) {
  if (!stack[pointer])
    stack[pointer] = [];
  stack[pointer].push(job);
}
function batchLayout(callback) {
  unresolvedJobs.add(callback);
  return function() {
    return unresolvedJobs.delete(callback);
  };
}
function flushLayout() {
  if (!unresolvedJobs.size)
    return;
  var pointer = 0;
  var reads = [[]];
  var writes = [];
  var setRead = function(job) {
    return pushJob(reads, job, pointer);
  };
  var setWrite = function(job) {
    pushJob(writes, job, pointer);
    pointer++;
  };
  unresolvedJobs.forEach(function(callback) {
    callback(setRead, setWrite);
    pointer = 0;
  });
  unresolvedJobs.clear();
  layoutState.isMeasuringLayout = true;
  es_default.postRender(function() {
    setTimeout(function() {
      return layoutState.isMeasuringLayout = false;
    }, 10);
  });
  var numStacks = writes.length;
  for (var i = 0; i <= numStacks; i++) {
    reads[i] && reads[i].forEach(executeJob);
    writes[i] && writes[i].forEach(executeJob);
  }
}
var executeJob = function(job) {
  return job();
};

// node_modules/svelte-motion/src/components/AnimateSharedLayout/utils/batcher.js
var defaultHandler = {
  layoutReady: function(child) {
    return child.notifyLayoutReady();
  }
};
function createBatcher() {
  var queue = /* @__PURE__ */ new Set();
  return {
    add: function(child) {
      return queue.add(child);
    },
    flush: function(_a) {
      var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;
      batchLayout(function(read, write) {
        var order2 = Array.from(queue).sort(compareByDepth);
        var ancestors = parent ? collectProjectingAncestors(parent) : [];
        write(function() {
          var allElements = __spreadArray(__spreadArray([], __read(ancestors)), __read(order2));
          allElements.forEach(function(element2) {
            return element2.resetTransform();
          });
        });
        read(function() {
          order2.forEach(updateLayoutMeasurement);
        });
        write(function() {
          ancestors.forEach(function(element2) {
            return element2.restoreTransform();
          });
          order2.forEach(layoutReady);
        });
        read(function() {
          order2.forEach(function(child) {
            if (child.isPresent)
              child.presence = Presence.Present;
          });
        });
        write(function() {
          flushSync.preRender();
          flushSync.render();
        });
        read(function() {
          es_default.postRender(function() {
            return order2.forEach(assignProjectionToSnapshot);
          });
          queue.clear();
        });
      });
      flushLayout();
    }
  };
}
function assignProjectionToSnapshot(child) {
  child.prevViewportBox = child.projection.target;
}

// node_modules/svelte-motion/src/context/SharedLayoutContext.js
var SharedLayoutContext = (custom) => getDomContext("SharedLayout", custom) || writable(createBatcher());
var FramerTreeLayoutContext = () => writable(createBatcher());
function isSharedLayout(context) {
  return !!context.forceUpdate;
}

// node_modules/svelte-motion/src/context/LazyContext.js
var LazyContext = (c) => getDomContext("Lazy", c) || writable({ strict: false });

// node_modules/svelte-motion/src/context/MotionContext/MotionContext.svelte
var MotionContext = (c) => getDomContext("Motion", c) || writable({});

// node_modules/svelte-motion/src/motion/utils/UseVisualElement.svelte
var get_default_slot_changes = (dirty) => ({
  visualElement: dirty & /*visualElement*/
  1
});
var get_default_slot_context = (ctx) => ({ visualElement: (
  /*visualElement*/
  ctx[0]
) });
function create_fragment3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, visualElement*/
        262145)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var ssr = false;
function instance3($$self, $$props, $$invalidate) {
  let $presenceContext;
  let $config;
  let $lazyContext;
  let $layoutGroupId;
  let $mc;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseVisualElement", slots, ["default"]);
  let { createVisualElement = void 0, props, Component, visualState, isCustom } = $$props;
  const config = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  validate_store(config, "config");
  component_subscribe($$self, config, (value) => $$invalidate(15, $config = value));
  const presenceContext = getContext(PresenceContext) || PresenceContext(isCustom);
  validate_store(presenceContext, "presenceContext");
  component_subscribe($$self, presenceContext, (value) => $$invalidate(14, $presenceContext = value));
  const lazyContext = getContext(LazyContext) || LazyContext(isCustom);
  validate_store(lazyContext, "lazyContext");
  component_subscribe($$self, lazyContext, (value) => $$invalidate(20, $lazyContext = value));
  const mc = getContext(MotionContext) || MotionContext(isCustom);
  validate_store(mc, "mc");
  component_subscribe($$self, mc, (value) => $$invalidate(17, $mc = value));
  let parent = get_store_value(mc).visualElement;
  const layoutGroupId = getContext(LayoutGroupContext) || LayoutGroupContext(isCustom);
  validate_store(layoutGroupId, "layoutGroupId");
  component_subscribe($$self, layoutGroupId, (value) => $$invalidate(16, $layoutGroupId = value));
  let layoutId = $layoutGroupId && props.layoutId !== void 0 ? $layoutGroupId + "-" + props.layoutId : props.layoutId;
  let visualElementRef = void 0;
  if (!createVisualElement) {
    createVisualElement = $lazyContext.renderer;
  }
  let visualElement2 = visualElementRef;
  afterUpdate(() => {
    tick().then(() => {
      var _a;
      (_a = visualElement2.animationState) == null ? void 0 : _a.animateChanges();
    });
  });
  onDestroy(() => {
    visualElement2 == null ? void 0 : visualElement2.notifyUnmount();
  });
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseVisualElement> was created without expected prop 'props'");
    }
    if (Component === void 0 && !("Component" in $$props || $$self.$$.bound[$$self.$$.props["Component"]])) {
      console.warn("<UseVisualElement> was created without expected prop 'Component'");
    }
    if (visualState === void 0 && !("visualState" in $$props || $$self.$$.bound[$$self.$$.props["visualState"]])) {
      console.warn("<UseVisualElement> was created without expected prop 'visualState'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<UseVisualElement> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["createVisualElement", "props", "Component", "visualState", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseVisualElement> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("createVisualElement" in $$props2) $$invalidate(6, createVisualElement = $$props2.createVisualElement);
    if ("props" in $$props2) $$invalidate(7, props = $$props2.props);
    if ("Component" in $$props2) $$invalidate(8, Component = $$props2.Component);
    if ("visualState" in $$props2) $$invalidate(9, visualState = $$props2.visualState);
    if ("isCustom" in $$props2) $$invalidate(10, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2) $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ssr,
    afterUpdate,
    getContext,
    onDestroy,
    tick,
    PresenceContext,
    LazyContext,
    MotionConfigContext,
    LayoutGroupContext,
    MotionContext,
    isPresent,
    get: get_store_value,
    createVisualElement,
    props,
    Component,
    visualState,
    isCustom,
    config,
    presenceContext,
    lazyContext,
    mc,
    parent,
    layoutGroupId,
    layoutId,
    visualElementRef,
    visualElement: visualElement2,
    $presenceContext,
    $config,
    $lazyContext,
    $layoutGroupId,
    $mc
  });
  $$self.$inject_state = ($$props2) => {
    if ("createVisualElement" in $$props2) $$invalidate(6, createVisualElement = $$props2.createVisualElement);
    if ("props" in $$props2) $$invalidate(7, props = $$props2.props);
    if ("Component" in $$props2) $$invalidate(8, Component = $$props2.Component);
    if ("visualState" in $$props2) $$invalidate(9, visualState = $$props2.visualState);
    if ("isCustom" in $$props2) $$invalidate(10, isCustom = $$props2.isCustom);
    if ("parent" in $$props2) $$invalidate(11, parent = $$props2.parent);
    if ("layoutId" in $$props2) $$invalidate(12, layoutId = $$props2.layoutId);
    if ("visualElementRef" in $$props2) $$invalidate(13, visualElementRef = $$props2.visualElementRef);
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$mc*/
    131072) {
      $: $$invalidate(11, parent = $mc.visualElement);
    }
    if ($$self.$$.dirty & /*$layoutGroupId, props*/
    65664) {
      $: $$invalidate(12, layoutId = $layoutGroupId && props.layoutId !== void 0 ? $layoutGroupId + "-" + props.layoutId : props.layoutId);
    }
    if ($$self.$$.dirty & /*visualElementRef, createVisualElement, Component, visualState, parent, props, layoutId, $presenceContext*/
    31680) {
      $: if (!visualElementRef && createVisualElement) {
        $$invalidate(13, visualElementRef = createVisualElement(Component, {
          visualState,
          parent,
          props: { ...props, layoutId },
          presenceId: $presenceContext == null ? void 0 : $presenceContext.id,
          blockInitialAnimation: ($presenceContext == null ? void 0 : $presenceContext.initial) === false
        }));
      }
    }
    if ($$self.$$.dirty & /*visualElementRef*/
    8192) {
      $: $$invalidate(0, visualElement2 = visualElementRef);
    }
    if ($$self.$$.dirty & /*visualElement, $config, props, layoutId, $presenceContext, parent*/
    55425) {
      $: if (visualElement2) {
        visualElement2.setProps({ ...$config, ...props, layoutId });
        $$invalidate(0, visualElement2.isPresent = isPresent($presenceContext), visualElement2);
        $$invalidate(0, visualElement2.isPresenceRoot = !parent || parent.presenceId !== ($presenceContext == null ? void 0 : $presenceContext.id), visualElement2);
        visualElement2.syncRender();
      }
    }
  };
  return [
    visualElement2,
    config,
    presenceContext,
    lazyContext,
    mc,
    layoutGroupId,
    createVisualElement,
    props,
    Component,
    visualState,
    isCustom,
    parent,
    layoutId,
    visualElementRef,
    $presenceContext,
    $config,
    $layoutGroupId,
    $mc,
    $$scope,
    slots
  ];
}
var UseVisualElement = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      createVisualElement: 6,
      props: 7,
      Component: 8,
      visualState: 9,
      isCustom: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseVisualElement",
      options,
      id: create_fragment3.name
    });
  }
  get createVisualElement() {
    throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set createVisualElement(value) {
    throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Component() {
    throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Component(value) {
    throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualState() {
    throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualState(value) {
    throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseVisualElement_default = UseVisualElement;

// node_modules/svelte-motion/src/motion/features/definitions.js
var createDefinition = function(propNames) {
  return {
    isEnabled: function(props) {
      return propNames.some(function(name) {
        return !!props[name];
      });
    }
  };
};
var featureDefinitions = {
  measureLayout: createDefinition(["layout", "layoutId", "drag"]),
  animation: createDefinition([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag"
  ]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  layoutAnimation: createDefinition(["layout", "layoutId"])
};
function loadFeatures(features) {
  for (var key in features) {
    var Component = features[key];
    if (Component !== null) {
      featureDefinitions[key].Component = Component;
    }
  }
}

// node_modules/svelte-motion/src/motion/features/UseFeatures.svelte
var { Object: Object_1 } = globals;
var get_default_slot_changes2 = (dirty) => ({ features: dirty & /*features*/
2 });
var get_default_slot_context2 = (ctx) => ({ features: (
  /*features*/
  ctx[1]
) });
function create_if_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, features*/
        10)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(40:0) {#if visualElement}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*visualElement*/
    ctx[0] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*visualElement*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*visualElement*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseFeatures", slots, ["default"]);
  const featureNames = Object.keys(featureDefinitions);
  const numFeatures = featureNames.length;
  let { visualElement: visualElement2, props } = $$props;
  let features = [];
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<UseFeatures> was created without expected prop 'visualElement'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseFeatures> was created without expected prop 'props'");
    }
  });
  const writable_props = ["visualElement", "props"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseFeatures> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2) $$invalidate(2, props = $$props2.props);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    featureDefinitions,
    featureNames,
    numFeatures,
    visualElement: visualElement2,
    props,
    features
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2) $$invalidate(2, props = $$props2.props);
    if ("features" in $$props2) $$invalidate(1, features = $$props2.features);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props, features, visualElement*/
    7) {
      $: {
        $$invalidate(1, features = []);
        for (let i = 0; i < numFeatures; i++) {
          const name = featureNames[i];
          const { isEnabled, Component } = featureDefinitions[name];
          if (isEnabled(props) && Component) {
            features.push({
              Component,
              key: name,
              props,
              visualElement: visualElement2
            });
          }
        }
      }
    }
  };
  return [visualElement2, features, props, $$scope, slots];
}
var UseFeatures = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { visualElement: 0, props: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseFeatures",
      options,
      id: create_fragment4.name
    });
  }
  get visualElement() {
    throw new Error("<UseFeatures>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<UseFeatures>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseFeatures>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseFeatures>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseFeatures_default = UseFeatures;

// node_modules/svelte-motion/src/context/MotionContext/MotionContextProvider.svelte
function create_fragment5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MotionContextProvider", slots, ["default"]);
  let { value, isCustom } = $$props;
  let store = writable(value);
  setContext(MotionContext, store);
  setDomContext("Motion", isCustom, store);
  onDestroy(() => {
    var _a;
    (_a = value == null ? void 0 : value.visualElement) == null ? void 0 : _a.unmount();
  });
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<MotionContextProvider> was created without expected prop 'value'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<MotionContextProvider> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["value", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<MotionContextProvider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("isCustom" in $$props2) $$invalidate(1, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    setContext,
    writable,
    setDomContext,
    MotionContext,
    value,
    isCustom,
    store
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("isCustom" in $$props2) $$invalidate(1, isCustom = $$props2.isCustom);
    if ("store" in $$props2) $$invalidate(4, store = $$props2.store);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    1) {
      $: store.set(value);
    }
  };
  return [value, isCustom, $$scope, slots];
}
var MotionContextProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { value: 0, isCustom: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MotionContextProvider",
      options,
      id: create_fragment5.name
    });
  }
  get value() {
    throw new Error("<MotionContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<MotionContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<MotionContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<MotionContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MotionContextProvider_default = MotionContextProvider;

// node_modules/svelte-motion/src/render/html/utils/create-render-state.js
var createHtmlRenderState = function() {
  return {
    style: {},
    transform: {},
    transformKeys: [],
    transformOrigin: {},
    vars: {}
  };
};

// node_modules/svelte-motion/src/render/svg/utils/create-render-state.js
var createSvgRenderState = function() {
  return Object.assign(Object.assign({}, createHtmlRenderState()), { attrs: {} });
};

// node_modules/svelte-motion/src/render/html/utils/transform.js
var transformAxes = ["", "X", "Y", "Z"];
var order = ["translate", "scale", "rotate", "skew"];
var transformProps = ["transformPerspective", "x", "y", "z"];
order.forEach(function(operationKey) {
  return transformAxes.forEach(function(axesKey) {
    return transformProps.push(operationKey + axesKey);
  });
});
function sortTransformProps(a, b) {
  return transformProps.indexOf(a) - transformProps.indexOf(b);
}
var transformPropSet = new Set(transformProps);
function isTransformProp(key) {
  return transformPropSet.has(key);
}
var transformOriginProps = /* @__PURE__ */ new Set(["originX", "originY", "originZ"]);
function isTransformOriginProp(key) {
  return transformOriginProps.has(key);
}

// node_modules/svelte-motion/src/motion/utils/is-forced-motion-value.js
function isForcedMotionValue(key, _a) {
  var layout = _a.layout, layoutId = _a.layoutId;
  return isTransformProp(key) || isTransformOriginProp(key) || (layout || layoutId !== void 0) && !!valueScaleCorrection[key];
}

// node_modules/svelte-motion/src/render/html/utils/build-transform.js
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
function buildTransform(_a, _b, transformIsDefault, transformTemplate) {
  var transform2 = _a.transform, transformKeys2 = _a.transformKeys;
  var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;
  var transformString = "";
  transformKeys2.sort(sortTransformProps);
  var transformHasZ = false;
  var numTransformKeys = transformKeys2.length;
  for (var i = 0; i < numTransformKeys; i++) {
    var key = transformKeys2[i];
    transformString += (translateAlias[key] || key) + "(" + transform2[key] + ") ";
    if (key === "z")
      transformHasZ = true;
  }
  if (!transformHasZ && enableHardwareAcceleration) {
    transformString += "translateZ(0)";
  } else {
    transformString = transformString.trim();
  }
  if (transformTemplate) {
    transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildTransformOrigin(_a) {
  var _b = _a.originX, originX = _b === void 0 ? "50%" : _b, _c = _a.originY, originY = _c === void 0 ? "50%" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;
  return originX + " " + originY + " " + originZ;
}

// node_modules/svelte-motion/src/render/dom/utils/is-css-variable.js
function isCSSVariable(key) {
  return key.startsWith("--");
}

// node_modules/svelte-motion/src/render/dom/value-types/get-as-type.js
var getValueAsType = function(value, type) {
  return type && typeof value === "number" ? type.transform(value) : value;
};

// node_modules/svelte-motion/src/render/html/utils/build-styles.js
function buildHTMLStyles(state, latestValues, projection, layoutState2, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {
  var _a;
  var style = state.style, vars = state.vars, transform2 = state.transform, transformKeys2 = state.transformKeys, transformOrigin = state.transformOrigin;
  transformKeys2.length = 0;
  var hasTransform = false;
  var hasTransformOrigin = false;
  var transformIsNone = true;
  for (var key in latestValues) {
    var value = latestValues[key];
    if (isCSSVariable(key)) {
      vars[key] = value;
      continue;
    }
    var valueType = numberValueTypes[key];
    var valueAsType = getValueAsType(value, valueType);
    if (isTransformProp(key)) {
      hasTransform = true;
      transform2[key] = valueAsType;
      transformKeys2.push(key);
      if (!transformIsNone)
        continue;
      if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))
        transformIsNone = false;
    } else if (isTransformOriginProp(key)) {
      transformOrigin[key] = valueAsType;
      hasTransformOrigin = true;
    } else {
      if (layoutState2 && projection && layoutState2.isHydrated && valueScaleCorrection[key]) {
        var correctedValue = valueScaleCorrection[key].process(value, layoutState2, projection);
        var applyTo = valueScaleCorrection[key].applyTo;
        if (applyTo) {
          var num = applyTo.length;
          for (var i = 0; i < num; i++) {
            style[applyTo[i]] = correctedValue;
          }
        } else {
          style[key] = correctedValue;
        }
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (layoutState2 && projection && buildProjectionTransform && buildProjectionTransformOrigin) {
    style.transform = buildProjectionTransform(layoutState2.deltaFinal, layoutState2.treeScale, hasTransform ? transform2 : void 0);
    if (transformTemplate) {
      style.transform = transformTemplate(transform2, style.transform);
    }
    style.transformOrigin = buildProjectionTransformOrigin(layoutState2);
  } else {
    if (hasTransform) {
      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);
    }
    if (hasTransformOrigin) {
      style.transformOrigin = buildTransformOrigin(transformOrigin);
    }
  }
}

// node_modules/svelte-motion/src/render/html/UseInitialMotionValues.svelte
var get_default_slot_changes3 = (dirty) => ({ styles: dirty & /*styles*/
1 });
var get_default_slot_context3 = (ctx) => ({ styles: (
  /*styles*/
  ctx[0]
) });
function create_fragment6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_default_slot_context3
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, styles*/
        17)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let styles;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseInitialMotionValues", slots, ["default"]);
  let { visualState, isStatic, props } = $$props;
  const memo = () => {
    let state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, void 0, void 0, { enableHardwareAcceleration: !isStatic }, props.transformTemplate);
    const { vars, style } = state;
    return { ...vars, ...style };
  };
  $$self.$$.on_mount.push(function() {
    if (visualState === void 0 && !("visualState" in $$props || $$self.$$.bound[$$self.$$.props["visualState"]])) {
      console.warn("<UseInitialMotionValues> was created without expected prop 'visualState'");
    }
    if (isStatic === void 0 && !("isStatic" in $$props || $$self.$$.bound[$$self.$$.props["isStatic"]])) {
      console.warn("<UseInitialMotionValues> was created without expected prop 'isStatic'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseInitialMotionValues> was created without expected prop 'props'");
    }
  });
  const writable_props = ["visualState", "isStatic", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseInitialMotionValues> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualState" in $$props2) $$invalidate(1, visualState = $$props2.visualState);
    if ("isStatic" in $$props2) $$invalidate(2, isStatic = $$props2.isStatic);
    if ("props" in $$props2) $$invalidate(3, props = $$props2.props);
    if ("$$scope" in $$props2) $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    buildHTMLStyles,
    createHtmlRenderState,
    visualState,
    isStatic,
    props,
    memo,
    styles
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualState" in $$props2) $$invalidate(1, visualState = $$props2.visualState);
    if ("isStatic" in $$props2) $$invalidate(2, isStatic = $$props2.isStatic);
    if ("props" in $$props2) $$invalidate(3, props = $$props2.props);
    if ("styles" in $$props2) $$invalidate(0, styles = $$props2.styles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*visualState*/
    2) {
      $: $$invalidate(0, styles = memo(visualState));
    }
  };
  return [styles, visualState, isStatic, props, $$scope, slots];
}
var UseInitialMotionValues = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { visualState: 1, isStatic: 2, props: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseInitialMotionValues",
      options,
      id: create_fragment6.name
    });
  }
  get visualState() {
    throw new Error("<UseInitialMotionValues>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualState(value) {
    throw new Error("<UseInitialMotionValues>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<UseInitialMotionValues>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<UseInitialMotionValues>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseInitialMotionValues>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseInitialMotionValues>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseInitialMotionValues_default = UseInitialMotionValues;

// node_modules/svelte-motion/src/render/html/UseStyle.svelte
var { Object: Object_12 } = globals;
var get_default_slot_changes4 = (dirty) => ({ styles: dirty & /*s1, props, style*/
522 });
var get_default_slot_context4 = (ctx) => ({
  styles: (
    /*toStyle*/
    ctx[4](
      /*s1*/
      ctx[9],
      /*props*/
      ctx[1],
      /*style*/
      ctx[3]
    )
  )
});
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context4
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, s1, props, style*/
        650)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes4
            ),
            get_default_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(41:0) <UseInitialMotionValues {props} {visualState} {isStatic} let:styles={s1}>",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let useinitialmotionvalues;
  let current;
  useinitialmotionvalues = new UseInitialMotionValues_default({
    props: {
      props: (
        /*props*/
        ctx[1]
      ),
      visualState: (
        /*visualState*/
        ctx[0]
      ),
      isStatic: (
        /*isStatic*/
        ctx[2]
      ),
      $$slots: {
        default: [
          create_default_slot,
          ({ styles: s1 }) => ({ 9: s1 }),
          ({ styles: s1 }) => s1 ? 512 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(useinitialmotionvalues.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(useinitialmotionvalues.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(useinitialmotionvalues, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const useinitialmotionvalues_changes = {};
      if (dirty & /*props*/
      2) useinitialmotionvalues_changes.props = /*props*/
      ctx2[1];
      if (dirty & /*visualState*/
      1) useinitialmotionvalues_changes.visualState = /*visualState*/
      ctx2[0];
      if (dirty & /*isStatic*/
      4) useinitialmotionvalues_changes.isStatic = /*isStatic*/
      ctx2[2];
      if (dirty & /*$$scope, s1, props, style*/
      650) {
        useinitialmotionvalues_changes.$$scope = { dirty, ctx: ctx2 };
      }
      useinitialmotionvalues.$set(useinitialmotionvalues_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(useinitialmotionvalues.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(useinitialmotionvalues.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(useinitialmotionvalues, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function instance7($$self, $$props, $$invalidate) {
  let styleProp;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseStyle", slots, ["default"]);
  let { visualState, props, isStatic } = $$props;
  let style = {};
  const cRVO = copyRawValuesOnly;
  const toStyle = (s1) => {
    Object.assign(style, s1);
    if (props.transformValues) {
      $$invalidate(3, style = props.transformValues(style));
    }
    return style;
  };
  $$self.$$.on_mount.push(function() {
    if (visualState === void 0 && !("visualState" in $$props || $$self.$$.bound[$$self.$$.props["visualState"]])) {
      console.warn("<UseStyle> was created without expected prop 'visualState'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseStyle> was created without expected prop 'props'");
    }
    if (isStatic === void 0 && !("isStatic" in $$props || $$self.$$.bound[$$self.$$.props["isStatic"]])) {
      console.warn("<UseStyle> was created without expected prop 'isStatic'");
    }
  });
  const writable_props = ["visualState", "props", "isStatic"];
  Object_12.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseStyle> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualState" in $$props2) $$invalidate(0, visualState = $$props2.visualState);
    if ("props" in $$props2) $$invalidate(1, props = $$props2.props);
    if ("isStatic" in $$props2) $$invalidate(2, isStatic = $$props2.isStatic);
    if ("$$scope" in $$props2) $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    copyRawValuesOnly,
    isMotionValue,
    isForcedMotionValue,
    UseInitialMotionValues: UseInitialMotionValues_default,
    visualState,
    props,
    isStatic,
    style,
    cRVO,
    toStyle,
    styleProp
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualState" in $$props2) $$invalidate(0, visualState = $$props2.visualState);
    if ("props" in $$props2) $$invalidate(1, props = $$props2.props);
    if ("isStatic" in $$props2) $$invalidate(2, isStatic = $$props2.isStatic);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("styleProp" in $$props2) $$invalidate(5, styleProp = $$props2.styleProp);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    2) {
      $: $$invalidate(5, styleProp = props.style || {});
    }
    if ($$self.$$.dirty & /*style, styleProp, props*/
    42) {
      $: cRVO(style, styleProp, props);
    }
  };
  return [visualState, props, isStatic, style, toStyle, styleProp, slots, $$scope];
}
var UseStyle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { visualState: 0, props: 1, isStatic: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseStyle",
      options,
      id: create_fragment7.name
    });
  }
  get visualState() {
    throw new Error("<UseStyle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualState(value) {
    throw new Error("<UseStyle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseStyle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseStyle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<UseStyle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<UseStyle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseStyle_default = UseStyle;

// node_modules/svelte-motion/src/render/html/UseHTMLProps.svelte
var get_default_slot_changes5 = (dirty) => ({
  visualProps: dirty & /*styles, props*/
  65
});
var get_default_slot_context5 = (ctx) => ({
  visualProps: (
    /*getHTMLProps*/
    ctx[3](
      /*styles*/
      ctx[6],
      /*props*/
      ctx[0]
    )
  )
});
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context5
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, styles, props*/
        97)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes5
            ),
            get_default_slot_context5
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(36:0) <UseStyle let:styles {visualState} {props} {isStatic}>",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let usestyle;
  let current;
  usestyle = new UseStyle_default({
    props: {
      visualState: (
        /*visualState*/
        ctx[1]
      ),
      props: (
        /*props*/
        ctx[0]
      ),
      isStatic: (
        /*isStatic*/
        ctx[2]
      ),
      $$slots: {
        default: [
          create_default_slot2,
          ({ styles }) => ({ 6: styles }),
          ({ styles }) => styles ? 64 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usestyle.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usestyle.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usestyle, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const usestyle_changes = {};
      if (dirty & /*visualState*/
      2) usestyle_changes.visualState = /*visualState*/
      ctx2[1];
      if (dirty & /*props*/
      1) usestyle_changes.props = /*props*/
      ctx2[0];
      if (dirty & /*isStatic*/
      4) usestyle_changes.isStatic = /*isStatic*/
      ctx2[2];
      if (dirty & /*$$scope, styles, props*/
      97) {
        usestyle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usestyle.$set(usestyle_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usestyle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usestyle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usestyle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseHTMLProps", slots, ["default"]);
  let { props, visualState, isStatic } = $$props;
  const getHTMLProps = (style, props2) => {
    let htmlProps = {};
    if (Boolean(props2.drag)) {
      htmlProps.draggable = false;
      style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
      style.touchAction = props2.drag === true ? "none" : `pan-${props2.drag === "x" ? "y" : "x"}`;
    }
    htmlProps.style = style;
    return htmlProps;
  };
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseHTMLProps> was created without expected prop 'props'");
    }
    if (visualState === void 0 && !("visualState" in $$props || $$self.$$.bound[$$self.$$.props["visualState"]])) {
      console.warn("<UseHTMLProps> was created without expected prop 'visualState'");
    }
    if (isStatic === void 0 && !("isStatic" in $$props || $$self.$$.bound[$$self.$$.props["isStatic"]])) {
      console.warn("<UseHTMLProps> was created without expected prop 'isStatic'");
    }
  });
  const writable_props = ["props", "visualState", "isStatic"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseHTMLProps> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2) $$invalidate(0, props = $$props2.props);
    if ("visualState" in $$props2) $$invalidate(1, visualState = $$props2.visualState);
    if ("isStatic" in $$props2) $$invalidate(2, isStatic = $$props2.isStatic);
    if ("$$scope" in $$props2) $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    UseStyle: UseStyle_default,
    props,
    visualState,
    isStatic,
    getHTMLProps
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2) $$invalidate(0, props = $$props2.props);
    if ("visualState" in $$props2) $$invalidate(1, visualState = $$props2.visualState);
    if ("isStatic" in $$props2) $$invalidate(2, isStatic = $$props2.isStatic);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [props, visualState, isStatic, getHTMLProps, slots, $$scope];
}
var UseHTMLProps = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { props: 0, visualState: 1, isStatic: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseHTMLProps",
      options,
      id: create_fragment8.name
    });
  }
  get props() {
    throw new Error("<UseHTMLProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseHTMLProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualState() {
    throw new Error("<UseHTMLProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualState(value) {
    throw new Error("<UseHTMLProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<UseHTMLProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<UseHTMLProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseHTMLProps_default = UseHTMLProps;

// node_modules/svelte-motion/src/render/svg/utils/transform-origin.js
function calcOrigin2(origin, offset, size) {
  return typeof origin === "string" ? origin : px.transform(offset + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  var pxOriginX = calcOrigin2(originX, dimensions.x, dimensions.width);
  var pxOriginY = calcOrigin2(originY, dimensions.y, dimensions.height);
  return pxOriginX + " " + pxOriginY;
}

// node_modules/svelte-motion/src/render/svg/utils/path.js
var progressToPixels = function(progress2, length) {
  return px.transform(progress2 * length);
};
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {
  if (spacing === void 0) {
    spacing = 1;
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (useDashCase === void 0) {
    useDashCase = true;
  }
  var keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = progressToPixels(-offset, totalLength);
  var pathLength = progressToPixels(length, totalLength);
  var pathSpacing = progressToPixels(spacing, totalLength);
  attrs[keys.array] = pathLength + " " + pathSpacing;
}

// node_modules/svelte-motion/src/render/svg/utils/build-attrs.js
function buildSVGAttrs(state, _a, projection, layoutState2, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {
  var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, latest = __rest(_a, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
  buildHTMLStyles(state, latest, projection, layoutState2, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin);
  state.attrs = state.style;
  state.style = {};
  var attrs = state.attrs, style = state.style, dimensions = state.dimensions, totalPathLength = state.totalPathLength;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (totalPathLength !== void 0 && pathLength !== void 0) {
    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);
  }
}

// node_modules/svelte-motion/src/render/svg/UseSVGProps.svelte
var get_default_slot_changes6 = (dirty) => ({ visualProps: dirty & /*visualProps*/
1 });
var get_default_slot_context6 = (ctx) => ({ visualProps: (
  /*visualProps*/
  ctx[0]
) });
function create_fragment9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_default_slot_context6
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, visualProps*/
        9)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_default_slot_changes6
            ),
            get_default_slot_context6
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let visualProps;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseSVGProps", slots, ["default"]);
  let { visualState, props } = $$props;
  let memo = () => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, void 0, void 0, { enableHardwareAcceleration: false }, props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  };
  $$self.$$.on_mount.push(function() {
    if (visualState === void 0 && !("visualState" in $$props || $$self.$$.bound[$$self.$$.props["visualState"]])) {
      console.warn("<UseSVGProps> was created without expected prop 'visualState'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseSVGProps> was created without expected prop 'props'");
    }
  });
  const writable_props = ["visualState", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseSVGProps> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualState" in $$props2) $$invalidate(1, visualState = $$props2.visualState);
    if ("props" in $$props2) $$invalidate(2, props = $$props2.props);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createSvgRenderState,
    copyRawValuesOnly,
    buildSVGAttrs,
    visualState,
    props,
    memo,
    visualProps
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualState" in $$props2) $$invalidate(1, visualState = $$props2.visualState);
    if ("props" in $$props2) $$invalidate(2, props = $$props2.props);
    if ("memo" in $$props2) $$invalidate(5, memo = $$props2.memo);
    if ("visualProps" in $$props2) $$invalidate(0, visualProps = $$props2.visualProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*visualState*/
    2) {
      $: $$invalidate(0, visualProps = memo(visualState));
    }
    if ($$self.$$.dirty & /*props, visualProps*/
    5) {
      $: if (props.style) {
        const rawStyles = {};
        copyRawValuesOnly(rawStyles, props.style, props);
        $$invalidate(0, visualProps.style = { ...rawStyles, ...visualProps.style }, visualProps);
      }
    }
  };
  return [visualProps, visualState, props, $$scope, slots];
}
var UseSVGProps = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { visualState: 1, props: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseSVGProps",
      options,
      id: create_fragment9.name
    });
  }
  get visualState() {
    throw new Error("<UseSVGProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualState(value) {
    throw new Error("<UseSVGProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseSVGProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseSVGProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseSVGProps_default = UseSVGProps;

// node_modules/svelte-motion/src/render/dom/utils/filter-props.js
var shouldForward = function(key) {
  return !isValidMotionProp(key);
};
try {
  emotionIsPropValid_1 = __require("@emotion/is-prop-valid").default;
  shouldForward = function(key) {
    if (key.startsWith("on")) {
      return !isValidMotionProp(key);
    } else {
      return emotionIsPropValid_1(key);
    }
  };
} catch (_a) {
}
var emotionIsPropValid_1;
function filterProps(props, isDom, forwardMotionProps) {
  var filteredProps = {};
  for (var key in props) {
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key)) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}

// node_modules/svelte-motion/src/render/dom/UseRender.svelte
var get_default_slot_changes7 = (dirty) => ({
  props: dirty & /*filteredProps, visualProps*/
  2064
});
var get_default_slot_context7 = (ctx) => ({
  motion: (
    /*motion*/
    ctx[5]
  ),
  props: {
    .../*filteredProps*/
    ctx[4],
    .../*visualProps*/
    ctx[11]
  }
});
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context7
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, filteredProps, visualProps*/
        3088)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes7
            ),
            get_default_slot_context7
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(33:0) <svelte:component     this={Component === 'SVG' ? UseSVGProps : UseHTMLProps}     {visualState}     {isStatic}     {props}     let:visualProps>",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*Component*/
    ctx[2] === "SVG" ? UseSVGProps_default : UseHTMLProps_default
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        visualState: (
          /*visualState*/
          ctx2[1]
        ),
        isStatic: (
          /*isStatic*/
          ctx2[3]
        ),
        props: (
          /*props*/
          ctx2[0]
        ),
        $$slots: {
          default: [
            create_default_slot3,
            ({ visualProps }) => ({ 11: visualProps }),
            ({ visualProps }) => visualProps ? 2048 : 0
          ]
        },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*Component*/
      4 && switch_value !== (switch_value = /*Component*/
      ctx2[2] === "SVG" ? UseSVGProps_default : UseHTMLProps_default)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*visualState*/
        2) switch_instance_changes.visualState = /*visualState*/
        ctx2[1];
        if (dirty & /*isStatic*/
        8) switch_instance_changes.isStatic = /*isStatic*/
        ctx2[3];
        if (dirty & /*props*/
        1) switch_instance_changes.props = /*props*/
        ctx2[0];
        if (dirty & /*$$scope, filteredProps, visualProps*/
        3088) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let filteredProps;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseRender", slots, ["default"]);
  let { props, visualState, Component, forwardMotionProps = false, isStatic, ref, targetEl = void 0 } = $$props;
  const motion2 = (node) => {
    ref(node);
  };
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseRender> was created without expected prop 'props'");
    }
    if (visualState === void 0 && !("visualState" in $$props || $$self.$$.bound[$$self.$$.props["visualState"]])) {
      console.warn("<UseRender> was created without expected prop 'visualState'");
    }
    if (Component === void 0 && !("Component" in $$props || $$self.$$.bound[$$self.$$.props["Component"]])) {
      console.warn("<UseRender> was created without expected prop 'Component'");
    }
    if (isStatic === void 0 && !("isStatic" in $$props || $$self.$$.bound[$$self.$$.props["isStatic"]])) {
      console.warn("<UseRender> was created without expected prop 'isStatic'");
    }
    if (ref === void 0 && !("ref" in $$props || $$self.$$.bound[$$self.$$.props["ref"]])) {
      console.warn("<UseRender> was created without expected prop 'ref'");
    }
  });
  const writable_props = [
    "props",
    "visualState",
    "Component",
    "forwardMotionProps",
    "isStatic",
    "ref",
    "targetEl"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseRender> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2) $$invalidate(0, props = $$props2.props);
    if ("visualState" in $$props2) $$invalidate(1, visualState = $$props2.visualState);
    if ("Component" in $$props2) $$invalidate(2, Component = $$props2.Component);
    if ("forwardMotionProps" in $$props2) $$invalidate(6, forwardMotionProps = $$props2.forwardMotionProps);
    if ("isStatic" in $$props2) $$invalidate(3, isStatic = $$props2.isStatic);
    if ("ref" in $$props2) $$invalidate(7, ref = $$props2.ref);
    if ("targetEl" in $$props2) $$invalidate(8, targetEl = $$props2.targetEl);
    if ("$$scope" in $$props2) $$invalidate(10, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    UseSVGProps: UseSVGProps_default,
    UseHTMLProps: UseHTMLProps_default,
    filterProps,
    props,
    visualState,
    Component,
    forwardMotionProps,
    isStatic,
    ref,
    targetEl,
    motion: motion2,
    filteredProps
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2) $$invalidate(0, props = $$props2.props);
    if ("visualState" in $$props2) $$invalidate(1, visualState = $$props2.visualState);
    if ("Component" in $$props2) $$invalidate(2, Component = $$props2.Component);
    if ("forwardMotionProps" in $$props2) $$invalidate(6, forwardMotionProps = $$props2.forwardMotionProps);
    if ("isStatic" in $$props2) $$invalidate(3, isStatic = $$props2.isStatic);
    if ("ref" in $$props2) $$invalidate(7, ref = $$props2.ref);
    if ("targetEl" in $$props2) $$invalidate(8, targetEl = $$props2.targetEl);
    if ("filteredProps" in $$props2) $$invalidate(4, filteredProps = $$props2.filteredProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props, Component, forwardMotionProps*/
    69) {
      $: $$invalidate(4, filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps));
    }
    if ($$self.$$.dirty & /*targetEl*/
    256) {
      $: if (targetEl) {
        motion2(targetEl);
      }
    }
  };
  return [
    props,
    visualState,
    Component,
    isStatic,
    filteredProps,
    motion2,
    forwardMotionProps,
    ref,
    targetEl,
    slots,
    $$scope
  ];
}
var UseRender = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      props: 0,
      visualState: 1,
      Component: 2,
      forwardMotionProps: 6,
      isStatic: 3,
      ref: 7,
      targetEl: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseRender",
      options,
      id: create_fragment10.name
    });
  }
  get props() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualState() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualState(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Component() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Component(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forwardMotionProps() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forwardMotionProps(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetEl() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetEl(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseRender_default = UseRender;

// node_modules/svelte-motion/src/render/dom/projection/measure.js
function getBoundingBox(element2, transformPagePoint) {
  var box = element2.getBoundingClientRect();
  return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));
}

// node_modules/svelte-motion/src/render/dom/utils/css-variables-conversion.js
function isCSSVariable2(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  var match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  var _a = __read(match, 3), token = _a[1], fallback = _a[2];
  return [token, fallback];
}
function getVariableValue(current, element2, depth) {
  if (depth === void 0) {
    depth = 1;
  }
  var _a = __read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];
  if (!token)
    return;
  var resolved = window.getComputedStyle(element2).getPropertyValue(token);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable2(fallback)) {
    return getVariableValue(fallback, element2, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement2, _a, transitionEnd) {
  var _b;
  var target = __rest(_a, []);
  var element2 = visualElement2.getInstance();
  if (!(element2 instanceof HTMLElement))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = Object.assign({}, transitionEnd);
  }
  visualElement2.forEachValue(function(value) {
    var current2 = value.get();
    if (!isCSSVariable2(current2))
      return;
    var resolved2 = getVariableValue(current2, element2);
    if (resolved2)
      value.set(resolved2);
  });
  for (var key in target) {
    var current = target[key];
    if (!isCSSVariable2(current))
      continue;
    var resolved = getVariableValue(current, element2);
    if (!resolved)
      continue;
    target[key] = resolved;
    if (transitionEnd)
      (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;
  }
  return { target, transitionEnd };
}

// node_modules/svelte-motion/src/render/dom/utils/unit-conversion.js
var positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
var isPositionalKey = function(key) {
  return positionalKeys.has(key);
};
var hasPositionalKey = function(target) {
  return Object.keys(target).some(isPositionalKey);
};
var setAndResetVelocity = function(value, to) {
  value.set(to, false);
  value.set(to);
};
var isNumOrPxType = function(v) {
  return v === number || v === px;
};
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
var getPosFromMatrix = function(matrix, pos) {
  return parseFloat(matrix.split(", ")[pos]);
};
var getTranslateFromMatrix = function(pos2, pos3) {
  return function(_bbox, _a) {
    var transform2 = _a.transform;
    if (transform2 === "none" || !transform2)
      return 0;
    var matrix3d = transform2.match(/^matrix3d\((.+)\)$/);
    if (matrix3d) {
      return getPosFromMatrix(matrix3d[1], pos3);
    } else {
      var matrix = transform2.match(/^matrix\((.+)\)$/);
      if (matrix) {
        return getPosFromMatrix(matrix[1], pos2);
      } else {
        return 0;
      }
    }
  };
};
var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformProps.filter(function(key) {
  return !transformKeys.has(key);
});
function removeNonTranslationalTransform(visualElement2) {
  var removedTransforms = [];
  nonTranslationalTransformKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement2.syncRender();
  return removedTransforms;
}
var positionalValues = {
  // Dimensions
  width: function(_a) {
    var x = _a.x;
    return x.max - x.min;
  },
  height: function(_a) {
    var y = _a.y;
    return y.max - y.min;
  },
  top: function(_bbox, _a) {
    var top = _a.top;
    return parseFloat(top);
  },
  left: function(_bbox, _a) {
    var left = _a.left;
    return parseFloat(left);
  },
  bottom: function(_a, _b) {
    var y = _a.y;
    var top = _b.top;
    return parseFloat(top) + (y.max - y.min);
  },
  right: function(_a, _b) {
    var x = _a.x;
    var left = _b.left;
    return parseFloat(left) + (x.max - x.min);
  },
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
var convertChangedValueTypes = function(target, visualElement2, changedKeys) {
  var originBbox = visualElement2.measureViewportBox();
  var element2 = visualElement2.getInstance();
  var elementComputedStyle = getComputedStyle(element2);
  var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform2 = elementComputedStyle.transform;
  var originComputedStyle = { top, left, bottom, right, transform: transform2 };
  if (display === "none") {
    visualElement2.setStaticValue("display", target.display || "block");
  }
  visualElement2.syncRender();
  var targetBbox = visualElement2.measureViewportBox();
  changedKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
};
var checkAndConvertChangedValueTypes = function(visualElement2, target, origin, transitionEnd) {
  if (origin === void 0) {
    origin = {};
  }
  if (transitionEnd === void 0) {
    transitionEnd = {};
  }
  target = Object.assign({}, target);
  transitionEnd = Object.assign({}, transitionEnd);
  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  var removedTransformValues = [];
  var hasAttemptedToRemoveTransformValues = false;
  var changedValueTypeKeys = [];
  targetPositionalKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (!visualElement2.hasValue(key))
      return;
    var from = origin[key];
    var to = target[key];
    var fromType = findDimensionValueType(from);
    var toType;
    if (isKeyframesTarget(to)) {
      var numKeyframes = to.length;
      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {
        if (!toType) {
          toType = findDimensionValueType(to[i]);
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        var current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {
        if (from === 0) {
          value.set(toType.transform(from));
        } else {
          target[key] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement2);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
        setAndResetVelocity(value, to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    var convertedTarget = convertChangedValueTypes(target, visualElement2, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(function(_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        visualElement2.getValue(key).set(value);
      });
    }
    visualElement2.syncRender();
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement2, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement2, target, origin, transitionEnd) : { target, transitionEnd };
}

// node_modules/svelte-motion/src/render/dom/utils/parse-dom-variant.js
var parseDomVariant = function(visualElement2, target, origin, transitionEnd) {
  var resolved = resolveCSSVariables(visualElement2, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement2, target, origin, transitionEnd);
};

// node_modules/svelte-motion/src/render/html/utils/scrape-motion-values.js
function scrapeMotionValuesFromProps(props) {
  var style = props.style;
  var newValues = {};
  for (var key in style) {
    if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}

// node_modules/svelte-motion/src/render/html/utils/render.js
function renderHTML(element2, _a) {
  var style = _a.style, vars = _a.vars;
  Object.assign(element2.style, style);
  for (var key in vars) {
    element2.style.setProperty(key, vars[key]);
  }
}

// node_modules/svelte-motion/src/render/html/visual-element.js
function getComputedStyle2(element2) {
  return window.getComputedStyle(element2);
}
var htmlConfig = {
  treeType: "dom",
  readValueFromInstance: function(domElement, key) {
    if (isTransformProp(key)) {
      var defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      var computedStyle = getComputedStyle2(domElement);
      return (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
    }
  },
  sortNodePosition: function(a, b) {
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  },
  getBaseTarget: function(props, key) {
    var _a;
    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];
  },
  measureViewportBox: function(element2, _a) {
    var transformPagePoint = _a.transformPagePoint;
    return getBoundingBox(element2, transformPagePoint);
  },
  /**
   * Reset the transform on the current Element. This is called as part
   * of a batched process across the entire layout tree. To remove this write
   * cycle it'd be interesting to see if it's possible to "undo" all the current
   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms
   * works
   */
  resetTransform: function(element2, domElement, props) {
    var transformTemplate = props.transformTemplate;
    domElement.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    element2.scheduleRender();
  },
  restoreTransform: function(instance35, mutableState) {
    instance35.style.transform = mutableState.style.transform;
  },
  removeValueFromRenderState: function(key, _a) {
    var vars = _a.vars, style = _a.style;
    delete vars[key];
    delete style[key];
  },
  /**
   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`
   * can be animated by Motion.
   */
  makeTargetAnimatable: function(element2, _a, _b, isMounted) {
    var transformValues = _b.transformValues;
    if (isMounted === void 0) {
      isMounted = true;
    }
    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, ["transition", "transitionEnd"]);
    var origin = getOrigin(target, transition || {}, element2);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(element2, target, origin);
      var parsed = parseDomVariant(element2, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return Object.assign({
      transition,
      transitionEnd
    }, target);
  },
  scrapeMotionValuesFromProps,
  build: function(element2, renderState, latestValues, projection, layoutState2, options, props) {
    if (element2.isVisible !== void 0) {
      renderState.style.visibility = element2.isVisible ? "visible" : "hidden";
    }
    var isProjectionTranform = projection.isEnabled && layoutState2.isHydrated;
    buildHTMLStyles(renderState, latestValues, projection, layoutState2, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : void 0, isProjectionTranform ? buildLayoutProjectionTransformOrigin : void 0);
  },
  render: renderHTML
};
var htmlVisualElement = visualElement(htmlConfig);

// node_modules/svelte-motion/src/render/svg/utils/scrape-motion-values.js
function scrapeMotionValuesFromProps2(props) {
  var newValues = scrapeMotionValuesFromProps(props);
  for (var key in props) {
    if (isMotionValue(props[key])) {
      var targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}

// node_modules/svelte-motion/src/render/dom/utils/camel-to-dash.js
var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = "$1-$2";
var camelToDash = function(str) {
  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
};

// node_modules/svelte-motion/src/render/svg/utils/camel-case-attrs.js
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox"
]);

// node_modules/svelte-motion/src/render/svg/utils/render.js
function renderSVG(element2, renderState) {
  renderHTML(element2, renderState);
  for (var key in renderState.attrs) {
    element2.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}

// node_modules/svelte-motion/src/render/svg/visual-element.js
var svgVisualElement = visualElement(Object.assign(Object.assign({}, htmlConfig), {
  getBaseTarget: function(props, key) {
    return props[key];
  },
  readValueFromInstance: function(domElement, key) {
    var _a;
    if (isTransformProp(key)) {
      return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return domElement.getAttribute(key);
  },
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
  build: function(_element, renderState, latestValues, projection, layoutState2, options, props) {
    var isProjectionTranform = projection.isEnabled && layoutState2.isHydrated;
    buildSVGAttrs(renderState, latestValues, projection, layoutState2, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : void 0, isProjectionTranform ? buildLayoutProjectionTransformOrigin : void 0);
  },
  render: renderSVG
}));

// node_modules/svelte-motion/src/render/dom/create-visual-element.js
var createDomVisualElement = function(Component, options) {
  return Component === "SVG" ? svgVisualElement(options, { enableHardwareAcceleration: false }) : htmlVisualElement(options, { enableHardwareAcceleration: true });
};

// node_modules/svelte-motion/src/render/svg/config-motion.js
var svgMotionConfig = {
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
  createRenderState: createSvgRenderState,
  onMount: function(props, instance35, _a) {
    var renderState = _a.renderState, latestValues = _a.latestValues;
    try {
      renderState.dimensions = typeof instance35.getBBox === "function" ? instance35.getBBox() : instance35.getBoundingClientRect();
    } catch (e) {
      renderState.dimensions = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }
    if (isPath(instance35)) {
      renderState.totalPathLength = instance35.getTotalLength();
    }
    buildSVGAttrs(renderState, latestValues, void 0, void 0, { enableHardwareAcceleration: false }, props.transformTemplate);
    renderSVG(instance35, renderState);
  }
};
function isPath(element2) {
  return element2.tagName === "path";
}

// node_modules/svelte-motion/src/render/html/config-motion.js
var htmlMotionConfig = {
  scrapeMotionValuesFromProps,
  createRenderState: createHtmlRenderState
};

// node_modules/svelte-motion/src/context/MotionContext/utils.js
function getCurrentTreeVariants(props, context) {
  if (checkIfControllingVariants(props)) {
    var initial = props.initial, animate3 = props.animate;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate3) ? animate3 : void 0
    };
  }
  return props.inherit !== false ? context || {} : {};
}

// node_modules/svelte-motion/src/context/MotionContext/UseCreateMotionContext.svelte
var get_default_slot_changes8 = (dirty) => ({ value: dirty & /*value*/
1 });
var get_default_slot_context8 = (ctx) => ({ value: (
  /*value*/
  ctx[0]
) });
function create_fragment11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context8
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, value*/
        257)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes8
            ),
            get_default_slot_context8
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let $mc;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseCreateMotionContext", slots, ["default"]);
  let { props, isStatic, isCustom } = $$props;
  let mc = getContext(MotionContext) || MotionContext(isCustom);
  validate_store(mc, "mc");
  component_subscribe($$self, mc, (value2) => $$invalidate(7, $mc = value2));
  let { initial, animate: animate3 } = getCurrentTreeVariants(props, get_store_value(mc));
  const variantLabelsAsDependency = (prop) => {
    return Array.isArray(prop) ? prop.join(" ") : prop;
  };
  const memo = () => {
    return { initial, animate: animate3 };
  };
  let value = memo();
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseCreateMotionContext> was created without expected prop 'props'");
    }
    if (isStatic === void 0 && !("isStatic" in $$props || $$self.$$.bound[$$self.$$.props["isStatic"]])) {
      console.warn("<UseCreateMotionContext> was created without expected prop 'isStatic'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<UseCreateMotionContext> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["props", "isStatic", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseCreateMotionContext> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2) $$invalidate(2, props = $$props2.props);
    if ("isStatic" in $$props2) $$invalidate(3, isStatic = $$props2.isStatic);
    if ("isCustom" in $$props2) $$invalidate(4, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2) $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    get: get_store_value,
    MotionContext,
    getCurrentTreeVariants,
    props,
    isStatic,
    isCustom,
    mc,
    initial,
    animate: animate3,
    variantLabelsAsDependency,
    memo,
    value,
    $mc
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2) $$invalidate(2, props = $$props2.props);
    if ("isStatic" in $$props2) $$invalidate(3, isStatic = $$props2.isStatic);
    if ("isCustom" in $$props2) $$invalidate(4, isCustom = $$props2.isCustom);
    if ("mc" in $$props2) $$invalidate(1, mc = $$props2.mc);
    if ("initial" in $$props2) $$invalidate(5, initial = $$props2.initial);
    if ("animate" in $$props2) $$invalidate(6, animate3 = $$props2.animate);
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props, $mc*/
    132) {
      $: $$invalidate(5, { initial, animate: animate3 } = getCurrentTreeVariants(props, $mc), initial, ($$invalidate(6, animate3), $$invalidate(2, props), $$invalidate(7, $mc)));
    }
    if ($$self.$$.dirty & /*isStatic, initial, animate*/
    104) {
      $: if (isStatic) {
        $$invalidate(0, value = memo(variantLabelsAsDependency(initial), variantLabelsAsDependency(animate3)));
      }
    }
  };
  return [value, mc, props, isStatic, isCustom, initial, animate3, $mc, $$scope, slots];
}
var UseCreateMotionContext = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { props: 2, isStatic: 3, isCustom: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseCreateMotionContext",
      options,
      id: create_fragment11.name
    });
  }
  get props() {
    throw new Error("<UseCreateMotionContext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseCreateMotionContext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<UseCreateMotionContext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<UseCreateMotionContext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<UseCreateMotionContext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<UseCreateMotionContext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseCreateMotionContext_default = UseCreateMotionContext;

// node_modules/svelte-motion/src/value/utils/resolve-motion-value.js
function resolveMotionValue(value) {
  var unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}

// node_modules/svelte-motion/src/motion/utils/UseVisualState.svelte
var get_default_slot_changes9 = (dirty) => ({ state: dirty & /*state*/
1 });
var get_default_slot_context9 = (ctx) => ({ state: (
  /*state*/
  ctx[0]
) });
function create_fragment12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context9
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, state*/
        513)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes9
            ),
            get_default_slot_context9
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var makeState = ({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount: onMount2 }, props, context, presenceContext) => {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  if (onMount2) {
    state.mount = (instance35) => onMount2(props, instance35, state);
  }
  return state;
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const blockInitialAnimation = (presenceContext == null ? void 0 : presenceContext.initial) === false;
  const motionValues = scrapeMotionValues(props);
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate: animate3 } = props;
  const isControllingVariants = checkIfControllingVariants(props);
  const isVariantNode = checkIfVariantNode(props);
  if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {
    initial !== null && initial !== void 0 ? initial : initial = context.initial;
    animate3 !== null && animate3 !== void 0 ? animate3 : animate3 = context.animate;
  }
  const variantToSet = blockInitialAnimation || initial === false ? animate3 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach((definition) => {
      const resolved = resolveVariantFromProps(props, definition);
      if (!resolved) return;
      const { transitionEnd, transition, ...target } = resolved;
      for (const key in target) values[key] = target[key];
      for (const key in transitionEnd) values[key] = transitionEnd[key];
    });
  }
  return values;
}
function instance12($$self, $$props, $$invalidate) {
  let $presenceContext;
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseVisualState", slots, ["default"]);
  let { config, props, isStatic, isCustom } = $$props;
  const context = getContext(MotionContext) || MotionContext(isCustom);
  validate_store(context, "context");
  component_subscribe($$self, context, (value) => $$invalidate(8, $context = value));
  const presenceContext = getContext(PresenceContext) || PresenceContext(isCustom);
  validate_store(presenceContext, "presenceContext");
  component_subscribe($$self, presenceContext, (value) => $$invalidate(7, $presenceContext = value));
  let state = makeState(config, props, get_store_value(context), get_store_value(presenceContext));
  const ms = makeState;
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<UseVisualState> was created without expected prop 'config'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseVisualState> was created without expected prop 'props'");
    }
    if (isStatic === void 0 && !("isStatic" in $$props || $$self.$$.bound[$$self.$$.props["isStatic"]])) {
      console.warn("<UseVisualState> was created without expected prop 'isStatic'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<UseVisualState> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["config", "props", "isStatic", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseVisualState> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2) $$invalidate(3, config = $$props2.config);
    if ("props" in $$props2) $$invalidate(4, props = $$props2.props);
    if ("isStatic" in $$props2) $$invalidate(5, isStatic = $$props2.isStatic);
    if ("isCustom" in $$props2) $$invalidate(6, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2) $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    resolveMotionValue,
    checkIfControllingVariants,
    checkIfVariantNode,
    resolveVariantFromProps,
    isAnimationControls,
    makeState,
    makeLatestValues,
    getContext,
    get: get_store_value,
    PresenceContext,
    MotionContext,
    config,
    props,
    isStatic,
    isCustom,
    context,
    presenceContext,
    state,
    ms,
    $presenceContext,
    $context
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2) $$invalidate(3, config = $$props2.config);
    if ("props" in $$props2) $$invalidate(4, props = $$props2.props);
    if ("isStatic" in $$props2) $$invalidate(5, isStatic = $$props2.isStatic);
    if ("isCustom" in $$props2) $$invalidate(6, isCustom = $$props2.isCustom);
    if ("state" in $$props2) $$invalidate(0, state = $$props2.state);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isStatic, config, props, $context, $presenceContext*/
    440) {
      $: if (isStatic) {
        $$invalidate(0, state = ms(config, props, $context, $presenceContext));
      }
    }
  };
  return [
    state,
    context,
    presenceContext,
    config,
    props,
    isStatic,
    isCustom,
    $presenceContext,
    $context,
    $$scope,
    slots
  ];
}
var UseVisualState = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      config: 3,
      props: 4,
      isStatic: 5,
      isCustom: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseVisualState",
      options,
      id: create_fragment12.name
    });
  }
  get config() {
    throw new Error("<UseVisualState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<UseVisualState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseVisualState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseVisualState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<UseVisualState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<UseVisualState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<UseVisualState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<UseVisualState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseVisualState_default = UseVisualState;

// node_modules/svelte-motion/src/utils/is-ref-object.js
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}

// node_modules/svelte-motion/src/motion/utils/use-motion-ref.js
function useMotionRef(visualState, visualElement2, externalRef) {
  return function(instance35) {
    var _a;
    instance35 && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance35));
    if (visualElement2) {
      instance35 ? visualElement2.mount(instance35) : visualElement2.unmount();
    }
    if (externalRef) {
      if (typeof externalRef === "function") {
        externalRef(instance35);
      } else if (isRefObject(externalRef)) {
        externalRef.current = instance35;
      }
    }
  };
}

// node_modules/svelte-motion/src/motion/Motion.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
var get_default_slot_changes10 = (dirty) => ({
  motion: dirty & /*motion*/
  16777216,
  props: dirty & /*renderProps*/
  33554432
});
var get_default_slot_context10 = (ctx) => ({
  motion: (
    /*motion*/
    ctx[24]
  ),
  props: (
    /*renderProps*/
    ctx[25]
  )
});
function create_default_slot_6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context10
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, motion, renderProps*/
        50364416)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes10
            ),
            get_default_slot_context10
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: "(193:24) <UseRender                             {Component}                             props={motionProps}                             ref={useMotionRef(visualState, context.visualElement, externalRef)}                             {visualState}                             {isStatic}                             {forwardMotionProps}                             let:motion                             let:props={renderProps}>",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let userender;
  let current;
  userender = new UseRender_default({
    props: {
      Component: (
        /*Component*/
        ctx[6]
      ),
      props: (
        /*motionProps*/
        ctx[4]
      ),
      ref: useMotionRef(
        /*visualState*/
        ctx[18],
        /*context*/
        ctx[17].visualElement,
        /*externalRef*/
        ctx[1]
      ),
      visualState: (
        /*visualState*/
        ctx[18]
      ),
      isStatic: (
        /*isStatic*/
        ctx[3]
      ),
      forwardMotionProps: (
        /*forwardMotionProps*/
        ctx[0]
      ),
      $$slots: {
        default: [
          create_default_slot_6,
          ({ motion: motion2, props: renderProps }) => ({ 24: motion2, 25: renderProps }),
          ({ motion: motion2, props: renderProps }) => (motion2 ? 16777216 : 0) | (renderProps ? 33554432 : 0)
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(userender.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(userender.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(userender, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const userender_changes = {};
      if (dirty & /*motionProps*/
      16) userender_changes.props = /*motionProps*/
      ctx2[4];
      if (dirty & /*visualState, context, externalRef*/
      393218) userender_changes.ref = useMotionRef(
        /*visualState*/
        ctx2[18],
        /*context*/
        ctx2[17].visualElement,
        /*externalRef*/
        ctx2[1]
      );
      if (dirty & /*visualState*/
      262144) userender_changes.visualState = /*visualState*/
      ctx2[18];
      if (dirty & /*isStatic*/
      8) userender_changes.isStatic = /*isStatic*/
      ctx2[3];
      if (dirty & /*forwardMotionProps*/
      1) userender_changes.forwardMotionProps = /*forwardMotionProps*/
      ctx2[0];
      if (dirty & /*$$scope, motion, renderProps*/
      50364416) {
        userender_changes.$$scope = { dirty, ctx: ctx2 };
      }
      userender.$set(userender_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(userender.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(userender.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(userender, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(192:20) <MotionContextProvider value={context} {isCustom}>",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*_features*/
    ctx[20]
  );
  const get_key = (ctx2) => (
    /*feat*/
    ctx2[21].key
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*_features, isCustom*/
      1048608) {
        each_value = ensure_array_like_dev(
          /*_features*/
          ctx2[20]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(206:20) {#if mounted}",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*feat*/
    ctx[21].Component
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        props: (
          /*feat*/
          ctx2[21].props
        ),
        visualElement: (
          /*feat*/
          ctx2[21].visualElement
        ),
        isCustom: (
          /*isCustom*/
          ctx2[5]
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*_features*/
      1048576 && switch_value !== (switch_value = /*feat*/
      ctx[21].Component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*_features*/
        1048576) switch_instance_changes.props = /*feat*/
        ctx[21].props;
        if (dirty & /*_features*/
        1048576) switch_instance_changes.visualElement = /*feat*/
        ctx[21].visualElement;
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(207:24) {#each _features as feat (feat.key)}",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let motioncontextprovider;
  let t;
  let if_block_anchor;
  let current;
  motioncontextprovider = new MotionContextProvider_default({
    props: {
      value: (
        /*context*/
        ctx[17]
      ),
      isCustom: (
        /*isCustom*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block = (
    /*mounted*/
    ctx[2] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      create_component(motioncontextprovider.$$.fragment);
      t = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(motioncontextprovider.$$.fragment, nodes);
      t = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(motioncontextprovider, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const motioncontextprovider_changes = {};
      if (dirty & /*context*/
      131072) motioncontextprovider_changes.value = /*context*/
      ctx2[17];
      if (dirty & /*$$scope, motionProps, visualState, context, externalRef, isStatic, forwardMotionProps*/
      426011) {
        motioncontextprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      motioncontextprovider.$set(motioncontextprovider_changes);
      if (
        /*mounted*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*mounted*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(motioncontextprovider.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(motioncontextprovider.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      destroy_component(motioncontextprovider, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(188:16) <UseFeatures                     visualElement={setContext(context, visualElement)}                     props={motionProps}                     let:features={_features}>",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let usefeatures;
  let current;
  usefeatures = new UseFeatures_default({
    props: {
      visualElement: (
        /*setContext*/
        ctx[10](
          /*context*/
          ctx[17],
          /*visualElement*/
          ctx[19]
        )
      ),
      props: (
        /*motionProps*/
        ctx[4]
      ),
      $$slots: {
        default: [
          create_default_slot_4,
          ({ features: _features }) => ({ 20: _features }),
          ({ features: _features }) => _features ? 1048576 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usefeatures.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usefeatures.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usefeatures, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usefeatures_changes = {};
      if (dirty & /*context, visualElement*/
      655360) usefeatures_changes.visualElement = /*setContext*/
      ctx2[10](
        /*context*/
        ctx2[17],
        /*visualElement*/
        ctx2[19]
      );
      if (dirty & /*motionProps*/
      16) usefeatures_changes.props = /*motionProps*/
      ctx2[4];
      if (dirty & /*$$scope, _features, mounted, context, motionProps, visualState, externalRef, isStatic, forwardMotionProps*/
      1474591) {
        usefeatures_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usefeatures.$set(usefeatures_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usefeatures.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usefeatures.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usefeatures, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(181:12) <UseVisualElement                 {Component}                 {visualState}                 {createVisualElement}                 props={motionProps}                 {isCustom}                 let:visualElement>",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let usevisualelement;
  let current;
  usevisualelement = new UseVisualElement_default({
    props: {
      Component: (
        /*Component*/
        ctx[6]
      ),
      visualState: (
        /*visualState*/
        ctx[18]
      ),
      createVisualElement: (
        /*createVisualElement*/
        ctx[7]
      ),
      props: (
        /*motionProps*/
        ctx[4]
      ),
      isCustom: (
        /*isCustom*/
        ctx[5]
      ),
      $$slots: {
        default: [
          create_default_slot_3,
          ({ visualElement: visualElement2 }) => ({ 19: visualElement2 }),
          ({ visualElement: visualElement2 }) => visualElement2 ? 524288 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usevisualelement.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usevisualelement.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usevisualelement, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usevisualelement_changes = {};
      if (dirty & /*visualState*/
      262144) usevisualelement_changes.visualState = /*visualState*/
      ctx2[18];
      if (dirty & /*motionProps*/
      16) usevisualelement_changes.props = /*motionProps*/
      ctx2[4];
      if (dirty & /*$$scope, context, visualElement, motionProps, mounted, visualState, externalRef, isStatic, forwardMotionProps*/
      950303) {
        usevisualelement_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usevisualelement.$set(usevisualelement_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usevisualelement.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usevisualelement.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usevisualelement, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(175:8) <UseVisualState             config={visualStateConfig}             props={motionProps}             {isStatic}             {isCustom}             let:state={visualState}>",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let usevisualstate;
  let current;
  usevisualstate = new UseVisualState_default({
    props: {
      config: (
        /*visualStateConfig*/
        ctx[8]
      ),
      props: (
        /*motionProps*/
        ctx[4]
      ),
      isStatic: (
        /*isStatic*/
        ctx[3]
      ),
      isCustom: (
        /*isCustom*/
        ctx[5]
      ),
      $$slots: {
        default: [
          create_default_slot_2,
          ({ state: visualState }) => ({ 18: visualState }),
          ({ state: visualState }) => visualState ? 262144 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usevisualstate.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usevisualstate.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usevisualstate, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usevisualstate_changes = {};
      if (dirty & /*motionProps*/
      16) usevisualstate_changes.props = /*motionProps*/
      ctx2[4];
      if (dirty & /*isStatic*/
      8) usevisualstate_changes.isStatic = /*isStatic*/
      ctx2[3];
      if (dirty & /*$$scope, visualState, motionProps, context, mounted, externalRef, isStatic, forwardMotionProps*/
      426015) {
        usevisualstate_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usevisualstate.$set(usevisualstate_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usevisualstate.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usevisualstate.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usevisualstate, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(174:4) <UseCreateMotionContext props={motionProps} {isStatic} let:value={context} {isCustom}>",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let usecreatemotioncontext;
  let current;
  usecreatemotioncontext = new UseCreateMotionContext_default({
    props: {
      props: (
        /*motionProps*/
        ctx[4]
      ),
      isStatic: (
        /*isStatic*/
        ctx[3]
      ),
      isCustom: (
        /*isCustom*/
        ctx[5]
      ),
      $$slots: {
        default: [
          create_default_slot_1,
          ({ value: context }) => ({ 17: context }),
          ({ value: context }) => context ? 131072 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usecreatemotioncontext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usecreatemotioncontext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usecreatemotioncontext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usecreatemotioncontext_changes = {};
      if (dirty & /*motionProps*/
      16) usecreatemotioncontext_changes.props = /*motionProps*/
      ctx2[4];
      if (dirty & /*isStatic*/
      8) usecreatemotioncontext_changes.isStatic = /*isStatic*/
      ctx2[3];
      if (dirty & /*$$scope, motionProps, isStatic, context, mounted, externalRef, forwardMotionProps*/
      163871) {
        usecreatemotioncontext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usecreatemotioncontext.$set(usecreatemotioncontext_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usecreatemotioncontext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usecreatemotioncontext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usecreatemotioncontext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(173:0) <ScaleCorrectionProvider {isCustom}>",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let scalecorrectionprovider;
  let current;
  scalecorrectionprovider = new ScaleCorrectionProvider_default({
    props: {
      isCustom: (
        /*isCustom*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scalecorrectionprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(scalecorrectionprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scalecorrectionprovider, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const scalecorrectionprovider_changes = {};
      if (dirty & /*$$scope, motionProps, isStatic, mounted, externalRef, forwardMotionProps*/
      32799) {
        scalecorrectionprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scalecorrectionprovider.$set(scalecorrectionprovider_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(scalecorrectionprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scalecorrectionprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scalecorrectionprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let motionProps;
  let isStatic;
  const omit_props_names = ["isSVG", "forwardMotionProps", "externalRef", "targetEl"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Motion", slots, ["default"]);
  let { isSVG = false, forwardMotionProps = false, externalRef = void 0, targetEl = void 0 } = $$props;
  const isCustom = targetEl;
  let Component = isSVG ? "SVG" : "DOM";
  let createVisualElement = createDomVisualElement;
  let visualStateConfig = isSVG ? svgMotionConfig : htmlMotionConfig;
  const a = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  validate_store(a, "a");
  component_subscribe($$self, a, (value) => $$invalidate(13, $a = value));
  let mounted = false;
  const setContext2 = (c, v) => {
    c.visualElement = v;
    return v;
  };
  onMount(() => $$invalidate(2, mounted = true));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isSVG" in $$new_props) $$invalidate(11, isSVG = $$new_props.isSVG);
    if ("forwardMotionProps" in $$new_props) $$invalidate(0, forwardMotionProps = $$new_props.forwardMotionProps);
    if ("externalRef" in $$new_props) $$invalidate(1, externalRef = $$new_props.externalRef);
    if ("targetEl" in $$new_props) $$invalidate(12, targetEl = $$new_props.targetEl);
    if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MotionConfigContext,
    UseVisualElement: UseVisualElement_default,
    UseFeatures: UseFeatures_default,
    MotionContextProvider: MotionContextProvider_default,
    getContext,
    onMount,
    UseRender: UseRender_default,
    createDomVisualElement,
    svgMotionConfig,
    htmlMotionConfig,
    UseCreateMotionContext: UseCreateMotionContext_default,
    UseVisualState: UseVisualState_default,
    useMotionRef,
    ScaleCorrectionProvider: ScaleCorrectionProvider_default,
    isSVG,
    forwardMotionProps,
    externalRef,
    targetEl,
    isCustom,
    Component,
    createVisualElement,
    visualStateConfig,
    a,
    mounted,
    setContext: setContext2,
    isStatic,
    motionProps,
    $a
  });
  $$self.$inject_state = ($$new_props) => {
    if ("isSVG" in $$props) $$invalidate(11, isSVG = $$new_props.isSVG);
    if ("forwardMotionProps" in $$props) $$invalidate(0, forwardMotionProps = $$new_props.forwardMotionProps);
    if ("externalRef" in $$props) $$invalidate(1, externalRef = $$new_props.externalRef);
    if ("targetEl" in $$props) $$invalidate(12, targetEl = $$new_props.targetEl);
    if ("Component" in $$props) $$invalidate(6, Component = $$new_props.Component);
    if ("createVisualElement" in $$props) $$invalidate(7, createVisualElement = $$new_props.createVisualElement);
    if ("visualStateConfig" in $$props) $$invalidate(8, visualStateConfig = $$new_props.visualStateConfig);
    if ("mounted" in $$props) $$invalidate(2, mounted = $$new_props.mounted);
    if ("isStatic" in $$props) $$invalidate(3, isStatic = $$new_props.isStatic);
    if ("motionProps" in $$props) $$invalidate(4, motionProps = $$new_props.motionProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, motionProps = $$restProps);
    if ($$self.$$.dirty & /*$a*/
    8192) {
      $: $$invalidate(3, { isStatic } = $a || {}, isStatic);
    }
  };
  return [
    forwardMotionProps,
    externalRef,
    mounted,
    isStatic,
    motionProps,
    isCustom,
    Component,
    createVisualElement,
    visualStateConfig,
    a,
    setContext2,
    isSVG,
    targetEl,
    $a,
    slots,
    $$scope
  ];
}
var Motion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      isSVG: 11,
      forwardMotionProps: 0,
      externalRef: 1,
      targetEl: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Motion",
      options,
      id: create_fragment13.name
    });
  }
  get isSVG() {
    throw new Error("<Motion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSVG(value) {
    throw new Error("<Motion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forwardMotionProps() {
    throw new Error("<Motion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forwardMotionProps(value) {
    throw new Error("<Motion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get externalRef() {
    throw new Error("<Motion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set externalRef(value) {
    throw new Error("<Motion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetEl() {
    throw new Error("<Motion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetEl(value) {
    throw new Error("<Motion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Motion_default = Motion;

// node_modules/svelte-motion/src/motion/index.js
var createMotionComponent = ({
  preloadedFeatures,
  createVisualElement,
  forwardMotionProps,
  visualStateConfig,
  Component
}) => {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  return class MotionComponent extends Motion_default {
    constructor(options) {
      const props = options.props;
      options.props = {
        props,
        defaultFeatures: preloadedFeatures,
        createVisualElement,
        forwardMotionProps,
        Component,
        visualStateConfig
      };
      super(options);
    }
  };
};

// node_modules/svelte-motion/src/events/UseDomEvent.svelte
function create_fragment14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function addDomEvent(target, eventName, handler, options) {
  target.addEventListener(eventName, handler, options);
  return function() {
    return target.removeEventListener(eventName, handler, options);
  };
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseDomEvent", slots, ["default"]);
  let { ref, eventName, handler = void 0, options = void 0 } = $$props;
  let cleanup = () => {
  };
  const effect = () => {
    cleanup();
    if (!ref) {
      return () => {
      };
    }
    const element2 = ref.current;
    if (handler && element2) {
      return addDomEvent(element2, eventName, handler, options);
    }
    return () => {
    };
  };
  onDestroy(cleanup);
  $$self.$$.on_mount.push(function() {
    if (ref === void 0 && !("ref" in $$props || $$self.$$.bound[$$self.$$.props["ref"]])) {
      console.warn("<UseDomEvent> was created without expected prop 'ref'");
    }
    if (eventName === void 0 && !("eventName" in $$props || $$self.$$.bound[$$self.$$.props["eventName"]])) {
      console.warn("<UseDomEvent> was created without expected prop 'eventName'");
    }
  });
  const writable_props = ["ref", "eventName", "handler", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseDomEvent> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("ref" in $$props2) $$invalidate(0, ref = $$props2.ref);
    if ("eventName" in $$props2) $$invalidate(1, eventName = $$props2.eventName);
    if ("handler" in $$props2) $$invalidate(2, handler = $$props2.handler);
    if ("options" in $$props2) $$invalidate(3, options = $$props2.options);
    if ("$$scope" in $$props2) $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    addDomEvent,
    onDestroy,
    ref,
    eventName,
    handler,
    options,
    cleanup,
    effect
  });
  $$self.$inject_state = ($$props2) => {
    if ("ref" in $$props2) $$invalidate(0, ref = $$props2.ref);
    if ("eventName" in $$props2) $$invalidate(1, eventName = $$props2.eventName);
    if ("handler" in $$props2) $$invalidate(2, handler = $$props2.handler);
    if ("options" in $$props2) $$invalidate(3, options = $$props2.options);
    if ("cleanup" in $$props2) cleanup = $$props2.cleanup;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*ref, eventName, handler, options*/
    15) {
      $: cleanup = effect(ref, eventName, handler, options);
    }
  };
  return [ref, eventName, handler, options, $$scope, slots];
}
var UseDomEvent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      ref: 0,
      eventName: 1,
      handler: 2,
      options: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseDomEvent",
      options,
      id: create_fragment14.name
    });
  }
  get ref() {
    throw new Error("<UseDomEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<UseDomEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get eventName() {
    throw new Error("<UseDomEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set eventName(value) {
    throw new Error("<UseDomEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handler() {
    throw new Error("<UseDomEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<UseDomEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<UseDomEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<UseDomEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseDomEvent_default = UseDomEvent;

// node_modules/svelte-motion/src/gestures/utils/event-type.js
function isMouseEvent(event) {
  if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {
    return !!(event.pointerType === "mouse");
  }
  return event instanceof MouseEvent;
}
function isTouchEvent(event) {
  var hasTouches = !!event.touches;
  return hasTouches;
}

// node_modules/svelte-motion/src/events/event-info.js
function filterPrimaryPointer(eventHandler) {
  return function(event) {
    var isMouseEvent2 = event instanceof MouseEvent;
    var isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;
    if (isPrimaryPointer) {
      eventHandler(event);
    }
  };
}
var defaultPagePoint = { pageX: 0, pageY: 0 };
function pointFromTouch(e, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  var primaryTouch = e.touches[0] || e.changedTouches[0];
  var point = primaryTouch || defaultPagePoint;
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function pointFromMouse(point, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function extractEventInfo(event, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
  };
}
function getViewportPointFromEvent(event) {
  return extractEventInfo(event, "client");
}
var wrapHandler = function(handler, shouldFilterPrimaryPointer) {
  if (shouldFilterPrimaryPointer === void 0) {
    shouldFilterPrimaryPointer = false;
  }
  var listener = function(event) {
    return handler(event, extractEventInfo(event));
  };
  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
};

// node_modules/svelte-motion/src/utils/is-browser.js
var isBrowser = typeof window !== "undefined";

// node_modules/svelte-motion/src/events/utils.js
var supportsPointerEvents = function() {
  return isBrowser && window.onpointerdown === null;
};
var supportsTouchEvents = function() {
  return isBrowser && window.ontouchstart === null;
};
var supportsMouseEvents = function() {
  return isBrowser && window.onmousedown === null;
};

// node_modules/svelte-motion/src/events/UsePointerEvent.svelte
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: '(65:0) <UseDomEvent {ref}   eventName={getPointerEventName(eventName)} handler={handler && wrapHandler(handler, eventName === \\"pointerdown\\")} {options}>',
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let usedomevent;
  let current;
  usedomevent = new UseDomEvent_default({
    props: {
      ref: (
        /*ref*/
        ctx[0]
      ),
      eventName: getPointerEventName(
        /*eventName*/
        ctx[1]
      ),
      handler: (
        /*handler*/
        ctx[2] && wrapHandler(
          /*handler*/
          ctx[2],
          /*eventName*/
          ctx[1] === "pointerdown"
        )
      ),
      options: (
        /*options*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usedomevent.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usedomevent.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usedomevent, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const usedomevent_changes = {};
      if (dirty & /*ref*/
      1) usedomevent_changes.ref = /*ref*/
      ctx2[0];
      if (dirty & /*eventName*/
      2) usedomevent_changes.eventName = getPointerEventName(
        /*eventName*/
        ctx2[1]
      );
      if (dirty & /*handler, eventName*/
      6) usedomevent_changes.handler = /*handler*/
      ctx2[2] && wrapHandler(
        /*handler*/
        ctx2[2],
        /*eventName*/
        ctx2[1] === "pointerdown"
      );
      if (dirty & /*options*/
      8) usedomevent_changes.options = /*options*/
      ctx2[3];
      if (dirty & /*$$scope*/
      32) {
        usedomevent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usedomevent.$set(usedomevent_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usedomevent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usedomevent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usedomevent, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getPointerEventName(name) {
  if (supportsPointerEvents()) {
    return name;
  } else if (supportsTouchEvents()) {
    return touchEventNames[name];
  } else if (supportsMouseEvents()) {
    return mouseEventNames[name];
  }
  return name;
}
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === "pointerdown"), options);
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UsePointerEvent", slots, ["default"]);
  let { ref, eventName, handler = void 0, options = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (ref === void 0 && !("ref" in $$props || $$self.$$.bound[$$self.$$.props["ref"]])) {
      console.warn("<UsePointerEvent> was created without expected prop 'ref'");
    }
    if (eventName === void 0 && !("eventName" in $$props || $$self.$$.bound[$$self.$$.props["eventName"]])) {
      console.warn("<UsePointerEvent> was created without expected prop 'eventName'");
    }
  });
  const writable_props = ["ref", "eventName", "handler", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UsePointerEvent> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("ref" in $$props2) $$invalidate(0, ref = $$props2.ref);
    if ("eventName" in $$props2) $$invalidate(1, eventName = $$props2.eventName);
    if ("handler" in $$props2) $$invalidate(2, handler = $$props2.handler);
    if ("options" in $$props2) $$invalidate(3, options = $$props2.options);
    if ("$$scope" in $$props2) $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    UseDomEvent: UseDomEvent_default,
    supportsPointerEvents,
    supportsTouchEvents,
    supportsMouseEvents,
    mouseEventNames,
    touchEventNames,
    getPointerEventName,
    addPointerEvent,
    wrapHandler,
    addDomEvent,
    ref,
    eventName,
    handler,
    options
  });
  $$self.$inject_state = ($$props2) => {
    if ("ref" in $$props2) $$invalidate(0, ref = $$props2.ref);
    if ("eventName" in $$props2) $$invalidate(1, eventName = $$props2.eventName);
    if ("handler" in $$props2) $$invalidate(2, handler = $$props2.handler);
    if ("options" in $$props2) $$invalidate(3, options = $$props2.options);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ref, eventName, handler, options, slots, $$scope];
}
var UsePointerEvent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, {
      ref: 0,
      eventName: 1,
      handler: 2,
      options: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UsePointerEvent",
      options,
      id: create_fragment15.name
    });
  }
  get ref() {
    throw new Error("<UsePointerEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<UsePointerEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get eventName() {
    throw new Error("<UsePointerEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set eventName(value) {
    throw new Error("<UsePointerEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handler() {
    throw new Error("<UsePointerEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<UsePointerEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<UsePointerEvent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<UsePointerEvent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UsePointerEvent_default = UsePointerEvent;

// node_modules/svelte-motion/src/gestures/PanSession.js
var PanSession = (
  /** @class */
  function() {
    function PanSession2(event, handlers, _a) {
      var _this = this;
      var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.updatePoint = function() {
        if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))
          return;
        var info2 = getPanInfo(_this.lastMoveEventInfo, _this.history);
        var isPanStarted = _this.startEvent !== null;
        var isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        var point2 = info2.point;
        var timestamp2 = getFrameData().timestamp;
        _this.history.push(Object.assign(Object.assign({}, point2), { timestamp: timestamp2 }));
        var _a2 = _this.handlers, onStart = _a2.onStart, onMove = _a2.onMove;
        if (!isPanStarted) {
          onStart && onStart(_this.lastMoveEvent, info2);
          _this.startEvent = _this.lastMoveEvent;
        }
        onMove && onMove(_this.lastMoveEvent, info2);
      };
      this.handlePointerMove = function(event2, info2) {
        _this.lastMoveEvent = event2;
        _this.lastMoveEventInfo = transformPoint(info2, _this.transformPagePoint);
        if (isMouseEvent(event2) && event2.buttons === 0) {
          _this.handlePointerUp(event2, info2);
          return;
        }
        es_default.update(_this.updatePoint, true);
      };
      this.handlePointerUp = function(event2, info2) {
        _this.end();
        var _a2 = _this.handlers, onEnd = _a2.onEnd, onSessionEnd = _a2.onSessionEnd;
        var panInfo = getPanInfo(transformPoint(info2, _this.transformPagePoint), _this.history);
        if (_this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (isTouchEvent(event) && event.touches.length > 1)
        return;
      this.handlers = handlers;
      this.transformPagePoint = transformPagePoint;
      var info = extractEventInfo(event);
      var initialInfo = transformPoint(info, this.transformPagePoint);
      var point = initialInfo.point;
      var timestamp = getFrameData().timestamp;
      this.history = [Object.assign(Object.assign({}, point), { timestamp })];
      var onSessionStart = handlers.onSessionStart;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
    }
    PanSession2.prototype.updateHandlers = function(handlers) {
      this.handlers = handlers;
    };
    PanSession2.prototype.end = function() {
      this.removeListeners && this.removeListeners();
      cancelSync.update(this.updatePoint);
    };
    return PanSession2;
  }()
);
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function getPanInfo(_a, history) {
  var point = _a.point;
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity2(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity2(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  var i = history.length - 1;
  var timestampedPoint = null;
  var lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time === 0) {
    return { x: 0, y: 0 };
  }
  var currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}

// node_modules/svelte-motion/src/gestures/UsePanGesture.svelte
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: '(61:0) <UsePointerEvent ref={visualElement} eventName=\\"pointerdown\\" handler={hasPanEvents && onPointerDown}>',
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let usepointerevent;
  let current;
  usepointerevent = new UsePointerEvent_default({
    props: {
      ref: (
        /*visualElement*/
        ctx[0]
      ),
      eventName: "pointerdown",
      handler: (
        /*hasPanEvents*/
        ctx[1] && /*onPointerDown*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usepointerevent.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usepointerevent.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usepointerevent, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const usepointerevent_changes = {};
      if (dirty & /*visualElement*/
      1) usepointerevent_changes.ref = /*visualElement*/
      ctx2[0];
      if (dirty & /*hasPanEvents*/
      2) usepointerevent_changes.handler = /*hasPanEvents*/
      ctx2[1] && /*onPointerDown*/
      ctx2[3];
      if (dirty & /*$$scope*/
      4096) {
        usepointerevent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usepointerevent.$set(usepointerevent_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usepointerevent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usepointerevent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usepointerevent, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let hasPanEvents;
  let $mcc;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UsePanGesture", slots, ["default"]);
  let { props, visualElement: visualElement2, isCustom } = $$props;
  let { onPan, onPanStart, onPanEnd, onPanSessionStart } = props;
  let panSession = null;
  const mcc = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  validate_store(mcc, "mcc");
  component_subscribe($$self, mcc, (value) => $$invalidate(10, $mcc = value));
  let { transformPagePoint } = get_store_value(mcc);
  let handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: (event, info) => {
      panSession = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  function onPointerDown(event) {
    panSession = new PanSession(event, handlers, { transformPagePoint });
  }
  afterUpdate(() => {
    if (panSession !== null) {
      panSession.updateHandlers(handlers);
    }
  });
  onDestroy(() => panSession && panSession.end());
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UsePanGesture> was created without expected prop 'props'");
    }
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<UsePanGesture> was created without expected prop 'visualElement'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<UsePanGesture> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["props", "visualElement", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UsePanGesture> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2) $$invalidate(4, props = $$props2.props);
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("isCustom" in $$props2) $$invalidate(5, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2) $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    MotionConfigContext,
    PanSession,
    afterUpdate,
    getContext,
    onDestroy,
    UsePointerEvent: UsePointerEvent_default,
    get: get_store_value,
    props,
    visualElement: visualElement2,
    isCustom,
    onPan,
    onPanStart,
    onPanEnd,
    onPanSessionStart,
    panSession,
    mcc,
    transformPagePoint,
    handlers,
    onPointerDown,
    hasPanEvents,
    $mcc
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2) $$invalidate(4, props = $$props2.props);
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("isCustom" in $$props2) $$invalidate(5, isCustom = $$props2.isCustom);
    if ("onPan" in $$props2) $$invalidate(6, onPan = $$props2.onPan);
    if ("onPanStart" in $$props2) $$invalidate(7, onPanStart = $$props2.onPanStart);
    if ("onPanEnd" in $$props2) $$invalidate(8, onPanEnd = $$props2.onPanEnd);
    if ("onPanSessionStart" in $$props2) $$invalidate(9, onPanSessionStart = $$props2.onPanSessionStart);
    if ("panSession" in $$props2) panSession = $$props2.panSession;
    if ("transformPagePoint" in $$props2) transformPagePoint = $$props2.transformPagePoint;
    if ("handlers" in $$props2) handlers = $$props2.handlers;
    if ("hasPanEvents" in $$props2) $$invalidate(1, hasPanEvents = $$props2.hasPanEvents);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    16) {
      $: $$invalidate(6, { onPan, onPanStart, onPanEnd, onPanSessionStart } = props, onPan, ($$invalidate(7, onPanStart), $$invalidate(4, props)), ($$invalidate(8, onPanEnd), $$invalidate(4, props)), ($$invalidate(9, onPanSessionStart), $$invalidate(4, props)));
    }
    if ($$self.$$.dirty & /*onPan, onPanStart, onPanEnd, onPanSessionStart*/
    960) {
      $: $$invalidate(1, hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart);
    }
    if ($$self.$$.dirty & /*$mcc*/
    1024) {
      $: ({ transformPagePoint } = $mcc);
    }
    if ($$self.$$.dirty & /*onPanSessionStart, onPanStart, onPan, onPanEnd*/
    960) {
      $: handlers = {
        onSessionStart: onPanSessionStart,
        onStart: onPanStart,
        onMove: onPan,
        onEnd: (event, info) => {
          panSession = null;
          onPanEnd && onPanEnd(event, info);
        }
      };
    }
  };
  return [
    visualElement2,
    hasPanEvents,
    mcc,
    onPointerDown,
    props,
    isCustom,
    onPan,
    onPanStart,
    onPanEnd,
    onPanSessionStart,
    $mcc,
    slots,
    $$scope
  ];
}
var UsePanGesture = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { props: 4, visualElement: 0, isCustom: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UsePanGesture",
      options,
      id: create_fragment16.name
    });
  }
  get props() {
    throw new Error("<UsePanGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UsePanGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualElement() {
    throw new Error("<UsePanGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<UsePanGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<UsePanGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<UsePanGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UsePanGesture_default = UsePanGesture;

// node_modules/svelte-motion/src/gestures/utils/is-node-or-child.js
var isNodeOrChild = function(parent, child) {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};

// node_modules/svelte-motion/src/gestures/drag/utils/lock.js
function createLock(name) {
  var lock = null;
  return function() {
    var openLock = function() {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
var globalHorizontalLock = createLock("dragHorizontal");
var globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  var lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    var openHorizontal_1 = globalHorizontalLock();
    var openVertical_1 = globalVerticalLock();
    if (openHorizontal_1 && openVertical_1) {
      lock = function() {
        openHorizontal_1();
        openVertical_1();
      };
    } else {
      if (openHorizontal_1)
        openHorizontal_1();
      if (openVertical_1)
        openVertical_1();
    }
  }
  return lock;
}
function isDragActive() {
  var openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}

// node_modules/svelte-motion/src/gestures/UseTapGesture.svelte
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: '(73:0) <UsePointerEvent     ref={visualElement}     eventName=\\"pointerdown\\"     handler={hasPressListeners ? onPointerDown : undefined}>',
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let usepointerevent;
  let current;
  usepointerevent = new UsePointerEvent_default({
    props: {
      ref: (
        /*visualElement*/
        ctx[0]
      ),
      eventName: "pointerdown",
      handler: (
        /*hasPressListeners*/
        ctx[1] ? (
          /*onPointerDown*/
          ctx[2]
        ) : void 0
      ),
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usepointerevent.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usepointerevent.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usepointerevent, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const usepointerevent_changes = {};
      if (dirty & /*visualElement*/
      1) usepointerevent_changes.ref = /*visualElement*/
      ctx2[0];
      if (dirty & /*hasPressListeners*/
      2) usepointerevent_changes.handler = /*hasPressListeners*/
      ctx2[1] ? (
        /*onPointerDown*/
        ctx2[2]
      ) : void 0;
      if (dirty & /*$$scope*/
      512) {
        usepointerevent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usepointerevent.$set(usepointerevent_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usepointerevent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usepointerevent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usepointerevent, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let onTap;
  let onTapStart;
  let onTapCancel;
  let whileTap;
  let hasPressListeners;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseTapGesture", slots, ["default"]);
  let { props, visualElement: visualElement2 } = $$props;
  let isPressing = false;
  let cancelPointerEndListeners = null;
  function removePointerEndListener() {
    cancelPointerEndListeners == null ? void 0 : cancelPointerEndListeners();
    cancelPointerEndListeners = null;
  }
  function checkPointerEnd() {
    var _a;
    removePointerEndListener();
    isPressing = false;
    (_a = visualElement2.animationState) == null ? void 0 : _a.setActive(AnimationType.Tap, false);
    return !isDragActive();
  }
  function onPointerUp(event, info) {
    if (!checkPointerEnd()) return;
    !isNodeOrChild(visualElement2.getInstance(), event.target) ? onTapCancel == null ? void 0 : onTapCancel(event, info) : onTap == null ? void 0 : onTap(event, info);
  }
  function onPointerCancel(event, info) {
    if (!checkPointerEnd()) return;
    onTapCancel == null ? void 0 : onTapCancel(event, info);
  }
  function onPointerDown(event, info) {
    var _a;
    if (isPressing) return;
    removePointerEndListener();
    isPressing = true;
    cancelPointerEndListeners = pipe(addPointerEvent(window, "pointerup", onPointerUp), addPointerEvent(window, "pointercancel", onPointerCancel));
    onTapStart == null ? void 0 : onTapStart(event, info);
    (_a = visualElement2.animationState) == null ? void 0 : _a.setActive(AnimationType.Tap, true);
  }
  onDestroy(removePointerEndListener);
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseTapGesture> was created without expected prop 'props'");
    }
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<UseTapGesture> was created without expected prop 'visualElement'");
    }
  });
  const writable_props = ["props", "visualElement"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseTapGesture> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2) $$invalidate(3, props = $$props2.props);
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("$$scope" in $$props2) $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    fixed,
    isNodeOrChild,
    pipe,
    isDragActive,
    onDestroy,
    UsePointerEvent: UsePointerEvent_default,
    addPointerEvent,
    AnimationType,
    props,
    visualElement: visualElement2,
    isPressing,
    cancelPointerEndListeners,
    removePointerEndListener,
    checkPointerEnd,
    onPointerUp,
    onPointerCancel,
    onPointerDown,
    onTapStart,
    onTapCancel,
    onTap,
    whileTap,
    hasPressListeners
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2) $$invalidate(3, props = $$props2.props);
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("isPressing" in $$props2) isPressing = $$props2.isPressing;
    if ("cancelPointerEndListeners" in $$props2) cancelPointerEndListeners = $$props2.cancelPointerEndListeners;
    if ("onTapStart" in $$props2) $$invalidate(4, onTapStart = $$props2.onTapStart);
    if ("onTapCancel" in $$props2) $$invalidate(5, onTapCancel = $$props2.onTapCancel);
    if ("onTap" in $$props2) $$invalidate(6, onTap = $$props2.onTap);
    if ("whileTap" in $$props2) $$invalidate(7, whileTap = $$props2.whileTap);
    if ("hasPressListeners" in $$props2) $$invalidate(1, hasPressListeners = $$props2.hasPressListeners);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    8) {
      $: $$invalidate(6, { onTap, onTapStart, onTapCancel, whileTap } = props, onTap, ($$invalidate(4, onTapStart), $$invalidate(3, props)), ($$invalidate(5, onTapCancel), $$invalidate(3, props)), ($$invalidate(7, whileTap), $$invalidate(3, props)));
    }
    if ($$self.$$.dirty & /*onTap, onTapStart, onTapCancel, whileTap*/
    240) {
      $: $$invalidate(1, hasPressListeners = onTap || onTapStart || onTapCancel || whileTap);
    }
  };
  return [
    visualElement2,
    hasPressListeners,
    onPointerDown,
    props,
    onTapStart,
    onTapCancel,
    onTap,
    whileTap,
    slots,
    $$scope
  ];
}
var UseTapGesture = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { props: 3, visualElement: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseTapGesture",
      options,
      id: create_fragment17.name
    });
  }
  get props() {
    throw new Error("<UseTapGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseTapGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualElement() {
    throw new Error("<UseTapGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<UseTapGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseTapGesture_default = UseTapGesture;

// node_modules/svelte-motion/src/gestures/UseHoverGesture.svelte
function create_fragment18(ctx) {
  let usepointerevent0;
  let t0;
  let usepointerevent1;
  let t1;
  let current;
  usepointerevent0 = new UsePointerEvent_default({
    props: {
      ref: (
        /*visualElement*/
        ctx[0]
      ),
      eventName: "pointerenter",
      handler: (
        /*onHoverStart*/
        ctx[1] || /*whileHover*/
        ctx[3] ? createHoverEvent(
          /*visualElement*/
          ctx[0],
          true,
          /*onHoverStart*/
          ctx[1]
        ) : void 0
      )
    },
    $$inline: true
  });
  usepointerevent1 = new UsePointerEvent_default({
    props: {
      ref: (
        /*visualElement*/
        ctx[0]
      ),
      eventName: "pointerleave",
      handler: (
        /*onHoverEnd*/
        ctx[2] || /*whileHover*/
        ctx[3] ? createHoverEvent(
          /*visualElement*/
          ctx[0],
          false,
          /*onHoverEnd*/
          ctx[2]
        ) : void 0
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      create_component(usepointerevent0.$$.fragment);
      t0 = space();
      create_component(usepointerevent1.$$.fragment);
      t1 = space();
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(usepointerevent0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(usepointerevent1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usepointerevent0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(usepointerevent1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const usepointerevent0_changes = {};
      if (dirty & /*visualElement*/
      1) usepointerevent0_changes.ref = /*visualElement*/
      ctx2[0];
      if (dirty & /*onHoverStart, whileHover, visualElement*/
      11) usepointerevent0_changes.handler = /*onHoverStart*/
      ctx2[1] || /*whileHover*/
      ctx2[3] ? createHoverEvent(
        /*visualElement*/
        ctx2[0],
        true,
        /*onHoverStart*/
        ctx2[1]
      ) : void 0;
      usepointerevent0.$set(usepointerevent0_changes);
      const usepointerevent1_changes = {};
      if (dirty & /*visualElement*/
      1) usepointerevent1_changes.ref = /*visualElement*/
      ctx2[0];
      if (dirty & /*onHoverEnd, whileHover, visualElement*/
      13) usepointerevent1_changes.handler = /*onHoverEnd*/
      ctx2[2] || /*whileHover*/
      ctx2[3] ? createHoverEvent(
        /*visualElement*/
        ctx2[0],
        false,
        /*onHoverEnd*/
        ctx2[2]
      ) : void 0;
      usepointerevent1.$set(usepointerevent1_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usepointerevent0.$$.fragment, local);
      transition_in(usepointerevent1.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usepointerevent0.$$.fragment, local);
      transition_out(usepointerevent1.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      destroy_component(usepointerevent0, detaching);
      destroy_component(usepointerevent1, detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function createHoverEvent(visualElement2, isActive, callback) {
  return (event, info) => {
    var _a;
    if (!isMouseEvent(event) || isDragActive()) return;
    callback == null ? void 0 : callback(event, info);
    (_a = visualElement2.animationState) == null ? void 0 : _a.setActive(AnimationType.Hover, isActive);
  };
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseHoverGesture", slots, ["default"]);
  let { props, visualElement: visualElement2 } = $$props;
  let { onHoverStart, onHoverEnd, whileHover } = props;
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseHoverGesture> was created without expected prop 'props'");
    }
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<UseHoverGesture> was created without expected prop 'visualElement'");
    }
  });
  const writable_props = ["props", "visualElement"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseHoverGesture> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2) $$invalidate(4, props = $$props2.props);
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("$$scope" in $$props2) $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    isDragActive,
    createHoverEvent,
    UsePointerEvent: UsePointerEvent_default,
    AnimationType,
    isMouseEvent,
    props,
    visualElement: visualElement2,
    onHoverStart,
    onHoverEnd,
    whileHover
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2) $$invalidate(4, props = $$props2.props);
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("onHoverStart" in $$props2) $$invalidate(1, onHoverStart = $$props2.onHoverStart);
    if ("onHoverEnd" in $$props2) $$invalidate(2, onHoverEnd = $$props2.onHoverEnd);
    if ("whileHover" in $$props2) $$invalidate(3, whileHover = $$props2.whileHover);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    16) {
      $: $$invalidate(1, { onHoverStart, onHoverEnd, whileHover } = props, onHoverStart, ($$invalidate(2, onHoverEnd), $$invalidate(4, props)), ($$invalidate(3, whileHover), $$invalidate(4, props)));
    }
  };
  return [visualElement2, onHoverStart, onHoverEnd, whileHover, props, $$scope, slots];
}
var UseHoverGesture = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { props: 4, visualElement: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseHoverGesture",
      options,
      id: create_fragment18.name
    });
  }
  get props() {
    throw new Error("<UseHoverGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseHoverGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualElement() {
    throw new Error("<UseHoverGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<UseHoverGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseHoverGesture_default = UseHoverGesture;

// node_modules/svelte-motion/src/gestures/UseFocusGesture.svelte
function create_default_slot_12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: '(22:4) <UseDomEvent ref={visualElement} eventName=\\"blur\\" handler={whileFocus ? onBlur : undefined}>',
    ctx
  });
  return block;
}
function create_default_slot8(ctx) {
  let usedomevent;
  let current;
  usedomevent = new UseDomEvent_default({
    props: {
      ref: (
        /*visualElement*/
        ctx[0]
      ),
      eventName: "blur",
      handler: (
        /*whileFocus*/
        ctx[1] ? (
          /*onBlur*/
          ctx[3]
        ) : void 0
      ),
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usedomevent.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usedomevent.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usedomevent, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usedomevent_changes = {};
      if (dirty & /*visualElement*/
      1) usedomevent_changes.ref = /*visualElement*/
      ctx2[0];
      if (dirty & /*whileFocus*/
      2) usedomevent_changes.handler = /*whileFocus*/
      ctx2[1] ? (
        /*onBlur*/
        ctx2[3]
      ) : void 0;
      if (dirty & /*$$scope*/
      64) {
        usedomevent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usedomevent.$set(usedomevent_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usedomevent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usedomevent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usedomevent, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: '(21:0) <UseDomEvent ref={visualElement} eventName=\\"focus\\" handler={whileFocus ? onFocus : undefined}>',
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let usedomevent;
  let current;
  usedomevent = new UseDomEvent_default({
    props: {
      ref: (
        /*visualElement*/
        ctx[0]
      ),
      eventName: "focus",
      handler: (
        /*whileFocus*/
        ctx[1] ? (
          /*onFocus*/
          ctx[2]
        ) : void 0
      ),
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usedomevent.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usedomevent.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usedomevent, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const usedomevent_changes = {};
      if (dirty & /*visualElement*/
      1) usedomevent_changes.ref = /*visualElement*/
      ctx2[0];
      if (dirty & /*whileFocus*/
      2) usedomevent_changes.handler = /*whileFocus*/
      ctx2[1] ? (
        /*onFocus*/
        ctx2[2]
      ) : void 0;
      if (dirty & /*$$scope, visualElement, whileFocus*/
      67) {
        usedomevent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usedomevent.$set(usedomevent_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usedomevent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usedomevent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usedomevent, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let whileFocus;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseFocusGesture", slots, ["default"]);
  let { props, visualElement: visualElement2 } = $$props;
  const onFocus = () => {
    var _a;
    (_a = visualElement2.animationState) == null ? void 0 : _a.setActive(AnimationType.Focus, true);
  };
  const onBlur = () => {
    var _a;
    (_a = visualElement2.animationState) == null ? void 0 : _a.setActive(AnimationType.Focus, false);
  };
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseFocusGesture> was created without expected prop 'props'");
    }
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<UseFocusGesture> was created without expected prop 'visualElement'");
    }
  });
  const writable_props = ["props", "visualElement"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseFocusGesture> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2) $$invalidate(4, props = $$props2.props);
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    UseDomEvent: UseDomEvent_default,
    AnimationType,
    props,
    visualElement: visualElement2,
    onFocus,
    onBlur,
    whileFocus
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2) $$invalidate(4, props = $$props2.props);
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("whileFocus" in $$props2) $$invalidate(1, whileFocus = $$props2.whileFocus);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    16) {
      $: $$invalidate(1, { whileFocus } = props, whileFocus);
    }
  };
  return [visualElement2, whileFocus, onFocus, onBlur, props, slots, $$scope];
}
var UseFocusGesture = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { props: 4, visualElement: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseFocusGesture",
      options,
      id: create_fragment19.name
    });
  }
  get props() {
    throw new Error("<UseFocusGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseFocusGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualElement() {
    throw new Error("<UseFocusGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<UseFocusGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseFocusGesture_default = UseFocusGesture;

// node_modules/svelte-motion/src/gestures/UseGestures.svelte
function create_fragment20(ctx) {
  let usepangesture;
  let t0;
  let usetapgesture;
  let t1;
  let usehovergesture;
  let t2;
  let usefocusgesture;
  let t3;
  let current;
  usepangesture = new UsePanGesture_default({
    props: {
      props: (
        /*props*/
        ctx[0]
      ),
      visualElement: (
        /*visualElement*/
        ctx[1]
      )
    },
    $$inline: true
  });
  usetapgesture = new UseTapGesture_default({
    props: {
      props: (
        /*props*/
        ctx[0]
      ),
      visualElement: (
        /*visualElement*/
        ctx[1]
      )
    },
    $$inline: true
  });
  usehovergesture = new UseHoverGesture_default({
    props: {
      props: (
        /*props*/
        ctx[0]
      ),
      visualElement: (
        /*visualElement*/
        ctx[1]
      )
    },
    $$inline: true
  });
  usefocusgesture = new UseFocusGesture_default({
    props: {
      props: (
        /*props*/
        ctx[0]
      ),
      visualElement: (
        /*visualElement*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      create_component(usepangesture.$$.fragment);
      t0 = space();
      create_component(usetapgesture.$$.fragment);
      t1 = space();
      create_component(usehovergesture.$$.fragment);
      t2 = space();
      create_component(usefocusgesture.$$.fragment);
      t3 = space();
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(usepangesture.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(usetapgesture.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(usehovergesture.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(usefocusgesture.$$.fragment, nodes);
      t3 = claim_space(nodes);
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usepangesture, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(usetapgesture, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(usehovergesture, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(usefocusgesture, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const usepangesture_changes = {};
      if (dirty & /*props*/
      1) usepangesture_changes.props = /*props*/
      ctx2[0];
      if (dirty & /*visualElement*/
      2) usepangesture_changes.visualElement = /*visualElement*/
      ctx2[1];
      usepangesture.$set(usepangesture_changes);
      const usetapgesture_changes = {};
      if (dirty & /*props*/
      1) usetapgesture_changes.props = /*props*/
      ctx2[0];
      if (dirty & /*visualElement*/
      2) usetapgesture_changes.visualElement = /*visualElement*/
      ctx2[1];
      usetapgesture.$set(usetapgesture_changes);
      const usehovergesture_changes = {};
      if (dirty & /*props*/
      1) usehovergesture_changes.props = /*props*/
      ctx2[0];
      if (dirty & /*visualElement*/
      2) usehovergesture_changes.visualElement = /*visualElement*/
      ctx2[1];
      usehovergesture.$set(usehovergesture_changes);
      const usefocusgesture_changes = {};
      if (dirty & /*props*/
      1) usefocusgesture_changes.props = /*props*/
      ctx2[0];
      if (dirty & /*visualElement*/
      2) usefocusgesture_changes.visualElement = /*visualElement*/
      ctx2[1];
      usefocusgesture.$set(usefocusgesture_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usepangesture.$$.fragment, local);
      transition_in(usetapgesture.$$.fragment, local);
      transition_in(usehovergesture.$$.fragment, local);
      transition_in(usefocusgesture.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usepangesture.$$.fragment, local);
      transition_out(usetapgesture.$$.fragment, local);
      transition_out(usehovergesture.$$.fragment, local);
      transition_out(usefocusgesture.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
      }
      destroy_component(usepangesture, detaching);
      destroy_component(usetapgesture, detaching);
      destroy_component(usehovergesture, detaching);
      destroy_component(usefocusgesture, detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseGestures", slots, ["default"]);
  let { props, visualElement: visualElement2 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseGestures> was created without expected prop 'props'");
    }
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<UseGestures> was created without expected prop 'visualElement'");
    }
  });
  const writable_props = ["props", "visualElement"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseGestures> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2) $$invalidate(0, props = $$props2.props);
    if ("visualElement" in $$props2) $$invalidate(1, visualElement2 = $$props2.visualElement);
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    UsePanGesture: UsePanGesture_default,
    UseTapGesture: UseTapGesture_default,
    UseHoverGesture: UseHoverGesture_default,
    UseFocusGesture: UseFocusGesture_default,
    props,
    visualElement: visualElement2
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2) $$invalidate(0, props = $$props2.props);
    if ("visualElement" in $$props2) $$invalidate(1, visualElement2 = $$props2.visualElement);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [props, visualElement2, $$scope, slots];
}
var UseGestures = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { props: 0, visualElement: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseGestures",
      options,
      id: create_fragment20.name
    });
  }
  get props() {
    throw new Error("<UseGestures>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseGestures>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualElement() {
    throw new Error("<UseGestures>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<UseGestures>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseGestures_default = UseGestures;

// node_modules/svelte-motion/src/render/dom/create-motion-class.js
var createMotionClass = (features) => {
  features && loadFeatures(features);
  return Motion_default;
};

// node_modules/svelte-motion/src/motion/features/gestures.js
var gestureAnimations = {
  tap: UseTapGesture_default,
  focus: UseFocusGesture_default,
  hover: UseHoverGesture_default
};

// node_modules/svelte-motion/src/gestures/drag/utils/constraints.js
function applyConstraints(point, _a, elastic) {
  var min = _a.min, max = _a.max;
  if (min !== void 0 && point < min) {
    point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
function calcConstrainedMinPoint(point, length, progress2, constraints, elastic) {
  var min = point - length * progress2;
  return constraints ? applyConstraints(min, constraints, elastic) : min;
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, _a) {
  var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  var _a;
  var min = constraintsAxis.min - layoutAxis.min;
  var max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    _a = __read([max, min], 2), min = _a[0], max = _a[1];
  }
  return {
    min: layoutAxis.min + min,
    max: layoutAxis.min + max
  };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcPositionFromProgress(axis, constraints, progress2) {
  var axisLength = axis.max - axis.min;
  var min = mix(constraints.min, constraints.max - axisLength, progress2);
  return { min, max: min + axisLength };
}
function rebaseAxisConstraints(layout, constraints) {
  var relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  var _a;
  return typeof dragElastic === "number" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;
}

// node_modules/svelte-motion/src/render/dom/projection/convert-to-relative.js
function convertToRelativeProjection(visualElement2, isLayoutDrag) {
  if (isLayoutDrag === void 0) {
    isLayoutDrag = true;
  }
  var projectionParent = visualElement2.getProjectionParent();
  if (!projectionParent)
    return false;
  var offset;
  if (isLayoutDrag) {
    offset = calcRelativeOffset(projectionParent.projection.target, visualElement2.projection.target);
    removeBoxTransforms(offset, projectionParent.getLatestValues());
  } else {
    offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement2.getLayoutState().layout);
  }
  eachAxis(function(axis) {
    return visualElement2.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);
  });
  return true;
}

// node_modules/svelte-motion/src/gestures/drag/VisualElementDragControls.js
var elementDragControls = /* @__PURE__ */ new WeakMap();
var lastPointerEvent;
var VisualElementDragControls = (
  /** @class */
  function() {
    function VisualElementDragControls2(_a) {
      var visualElement2 = _a.visualElement;
      this.isDragging = false;
      this.currentDirection = null;
      this.constraints = false;
      this.elastic = axisBox();
      this.props = {};
      this.hasMutatedConstraints = false;
      this.cursorProgress = {
        x: 0.5,
        y: 0.5
      };
      this.originPoint = {};
      this.openGlobalLock = null;
      this.panSession = null;
      this.visualElement = visualElement2;
      this.visualElement.enableLayoutProjection();
      elementDragControls.set(visualElement2, this);
    }
    VisualElementDragControls2.prototype.start = function(originEvent, _a) {
      var _this = this;
      var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;
      var onSessionStart = function(event) {
        var _a2;
        _this.stopMotion();
        var initialPoint = getViewportPointFromEvent(event).point;
        (_a2 = _this.cancelLayout) === null || _a2 === void 0 ? void 0 : _a2.call(_this);
        _this.cancelLayout = batchLayout(function(read, write) {
          var ancestors = collectProjectingAncestors(_this.visualElement);
          var children2 = collectProjectingChildren(_this.visualElement);
          var tree = __spreadArray(__spreadArray([], __read(ancestors)), __read(children2));
          var hasManuallySetCursorOrigin = false;
          _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();
          write(function() {
            tree.forEach(function(element2) {
              return element2.resetTransform();
            });
          });
          read(function() {
            updateLayoutMeasurement(_this.visualElement);
            children2.forEach(updateLayoutMeasurement);
          });
          write(function() {
            tree.forEach(function(element2) {
              return element2.restoreTransform();
            });
            if (snapToCursor) {
              hasManuallySetCursorOrigin = _this.snapToCursor(initialPoint);
            }
          });
          read(function() {
            var isRelativeDrag = Boolean(_this.getAxisMotionValue("x") && !_this.isExternalDrag());
            if (!isRelativeDrag) {
              _this.visualElement.rebaseProjectionTarget(true, _this.visualElement.measureViewportBox(false));
            }
            _this.visualElement.scheduleUpdateLayoutProjection();
            var projection = _this.visualElement.projection;
            eachAxis(function(axis) {
              if (!hasManuallySetCursorOrigin) {
                var _a3 = projection.target[axis], min = _a3.min, max = _a3.max;
                _this.cursorProgress[axis] = cursorProgress ? cursorProgress[axis] : progress(min, max, initialPoint[axis]);
              }
              var axisValue = _this.getAxisMotionValue(axis);
              if (axisValue) {
                _this.originPoint[axis] = axisValue.get();
              }
            });
          });
          write(function() {
            flushSync.update();
            flushSync.preRender();
            flushSync.render();
            flushSync.postRender();
          });
          read(function() {
            return _this.resolveDragConstraints();
          });
        });
      };
      var onStart = function(event, info) {
        var _a2, _b2, _c2;
        var _d = _this.props, drag2 = _d.drag, dragPropagation = _d.dragPropagation;
        if (drag2 && !dragPropagation) {
          if (_this.openGlobalLock)
            _this.openGlobalLock();
          _this.openGlobalLock = getGlobalLock(drag2);
          if (!_this.openGlobalLock)
            return;
        }
        flushLayout();
        _this.isDragging = true;
        _this.currentDirection = null;
        (_b2 = (_a2 = _this.props).onDragStart) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, event, info);
        (_c2 = _this.visualElement.animationState) === null || _c2 === void 0 ? void 0 : _c2.setActive(AnimationType.Drag, true);
      };
      var onMove = function(event, info) {
        var _a2, _b2, _c2, _d;
        var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;
        if (!dragPropagation && !_this.openGlobalLock)
          return;
        var offset = info.offset;
        if (dragDirectionLock && _this.currentDirection === null) {
          _this.currentDirection = getCurrentDirection(offset);
          if (_this.currentDirection !== null) {
            (_b2 = (_a2 = _this.props).onDirectionLock) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, _this.currentDirection);
          }
          return;
        }
        _this.updateAxis("x", info.point, offset);
        _this.updateAxis("y", info.point, offset);
        (_d = (_c2 = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c2, event, info);
        lastPointerEvent = event;
      };
      var onSessionEnd = function(event, info) {
        return _this.stop(event, info);
      };
      var transformPagePoint = this.props.transformPagePoint;
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd
      }, { transformPagePoint });
    };
    VisualElementDragControls2.prototype.resolveDragConstraints = function() {
      var _this = this;
      var _a = this.props, dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;
      var layout = this.visualElement.getLayoutState().layoutCorrected;
      if (dragConstraints) {
        this.constraints = isRefObject(dragConstraints) ? this.resolveRefConstraints(layout, dragConstraints) : calcRelativeConstraints(layout, dragConstraints);
      } else {
        this.constraints = false;
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (this.constraints && !this.hasMutatedConstraints) {
        eachAxis(function(axis) {
          if (_this.getAxisMotionValue(axis)) {
            _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);
          }
        });
      }
    };
    VisualElementDragControls2.prototype.resolveRefConstraints = function(layoutBox, constraints) {
      var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;
      var constraintsElement = constraints.current;
      invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
      this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);
      var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);
      if (onMeasureDragConstraints) {
        var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);
        }
      }
      return measuredConstraints;
    };
    VisualElementDragControls2.prototype.cancelDrag = function() {
      var _a, _b;
      this.visualElement.unlockProjectionTarget();
      (_a = this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(this);
      this.isDragging = false;
      this.panSession && this.panSession.end();
      this.panSession = null;
      if (!this.props.dragPropagation && this.openGlobalLock) {
        this.openGlobalLock();
        this.openGlobalLock = null;
      }
      (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);
    };
    VisualElementDragControls2.prototype.stop = function(event, info) {
      var _a, _b, _c;
      (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();
      this.panSession = null;
      var isDragging = this.isDragging;
      this.cancelDrag();
      if (!isDragging)
        return;
      var velocity = info.velocity;
      this.animateDragEnd(velocity);
      (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);
    };
    VisualElementDragControls2.prototype.snapToCursor = function(point) {
      var _this = this;
      return eachAxis(function(axis) {
        var drag2 = _this.props.drag;
        if (!shouldDrag(axis, drag2, _this.currentDirection))
          return;
        var axisValue = _this.getAxisMotionValue(axis);
        if (axisValue) {
          var box = _this.visualElement.getLayoutState().layout;
          var length_1 = box[axis].max - box[axis].min;
          var center = box[axis].min + length_1 / 2;
          var offset = point[axis] - center;
          _this.originPoint[axis] = point[axis];
          axisValue.set(offset);
        } else {
          _this.cursorProgress[axis] = 0.5;
          return true;
        }
      }).includes(true);
    };
    VisualElementDragControls2.prototype.updateAxis = function(axis, point, offset) {
      var drag2 = this.props.drag;
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      return this.getAxisMotionValue(axis) ? this.updateAxisMotionValue(axis, offset) : this.updateVisualElementAxis(axis, point);
    };
    VisualElementDragControls2.prototype.updateAxisMotionValue = function(axis, offset) {
      var axisValue = this.getAxisMotionValue(axis);
      if (!offset || !axisValue)
        return;
      var nextValue = this.originPoint[axis] + offset[axis];
      var update = this.constraints ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis]) : nextValue;
      axisValue.set(update);
    };
    VisualElementDragControls2.prototype.updateVisualElementAxis = function(axis, point) {
      var _a;
      var axisLayout = this.visualElement.getLayoutState().layout[axis];
      var axisLength = axisLayout.max - axisLayout.min;
      var axisProgress = this.cursorProgress[axis];
      var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]);
      this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);
    };
    VisualElementDragControls2.prototype.setProps = function(_a) {
      var _b = _a.drag, drag2 = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? defaultElastic : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = __rest(_a, ["drag", "dragDirectionLock", "dragPropagation", "dragConstraints", "dragElastic", "dragMomentum"]);
      this.props = Object.assign({
        drag: drag2,
        dragDirectionLock,
        dragPropagation,
        dragConstraints,
        dragElastic,
        dragMomentum
      }, remainingProps);
    };
    VisualElementDragControls2.prototype.getAxisMotionValue = function(axis) {
      var _a = this.props, layout = _a.layout, layoutId = _a.layoutId;
      var dragKey = "_drag" + axis.toUpperCase();
      if (this.props[dragKey]) {
        return this.props[dragKey];
      } else if (!layout && layoutId === void 0) {
        return this.visualElement.getValue(axis, 0);
      }
    };
    VisualElementDragControls2.prototype.isLayoutDrag = function() {
      return !this.getAxisMotionValue("x");
    };
    VisualElementDragControls2.prototype.isExternalDrag = function() {
      var _a = this.props, _dragX = _a._dragX, _dragY = _a._dragY;
      return _dragX || _dragY;
    };
    VisualElementDragControls2.prototype.animateDragEnd = function(velocity) {
      var _this = this;
      var _a = this.props, drag2 = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;
      var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());
      var constraints = this.constraints || {};
      if (isRelative && Object.keys(constraints).length && this.isLayoutDrag()) {
        var projectionParent = this.visualElement.getProjectionParent();
        if (projectionParent) {
          var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);
          eachAxis(function(axis) {
            var _a2 = relativeConstraints_1[axis], min = _a2.min, max = _a2.max;
            constraints[axis] = {
              min: isNaN(min) ? void 0 : min,
              max: isNaN(max) ? void 0 : max
            };
          });
        }
      }
      var momentumAnimations = eachAxis(function(axis) {
        var _a2;
        if (!shouldDrag(axis, drag2, _this.currentDirection)) {
          return;
        }
        var transition = (_a2 = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a2 !== void 0 ? _a2 : {};
        var bounceStiffness = dragElastic ? 200 : 1e6;
        var bounceDamping = dragElastic ? 40 : 1e7;
        var inertia2 = Object.assign(Object.assign({
          type: "inertia",
          velocity: dragMomentum ? velocity[axis] : 0,
          bounceStiffness,
          bounceDamping,
          timeConstant: 750,
          restDelta: 1,
          restSpeed: 10
        }, dragTransition), transition);
        return _this.getAxisMotionValue(axis) ? _this.startAxisValueAnimation(axis, inertia2) : _this.visualElement.startLayoutAnimation(axis, inertia2, isRelative);
      });
      return Promise.all(momentumAnimations).then(function() {
        var _a2, _b;
        (_b = (_a2 = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a2);
      });
    };
    VisualElementDragControls2.prototype.stopMotion = function() {
      var _this = this;
      eachAxis(function(axis) {
        var axisValue = _this.getAxisMotionValue(axis);
        axisValue ? axisValue.stop() : _this.visualElement.stopLayoutAnimation();
      });
    };
    VisualElementDragControls2.prototype.startAxisValueAnimation = function(axis, transition) {
      var axisValue = this.getAxisMotionValue(axis);
      if (!axisValue)
        return;
      var currentValue = axisValue.get();
      axisValue.set(currentValue);
      axisValue.set(currentValue);
      return startAnimation(axis, axisValue, 0, transition);
    };
    VisualElementDragControls2.prototype.scalePoint = function() {
      var _this = this;
      var _a = this.props, drag2 = _a.drag, dragConstraints = _a.dragConstraints;
      if (!isRefObject(dragConstraints) || !this.constraintsBox)
        return;
      this.stopMotion();
      var boxProgress = { x: 0, y: 0 };
      eachAxis(function(axis) {
        boxProgress[axis] = calcOrigin(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);
      });
      this.updateConstraints(function() {
        eachAxis(function(axis) {
          if (!shouldDrag(axis, drag2, null))
            return;
          var _a2 = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a2.min, max = _a2.max;
          _this.visualElement.setProjectionTargetAxis(axis, min, max);
        });
      });
      setTimeout(flushLayout, 1);
    };
    VisualElementDragControls2.prototype.updateConstraints = function(onReady) {
      var _this = this;
      this.cancelLayout = batchLayout(function(read, write) {
        var ancestors = collectProjectingAncestors(_this.visualElement);
        write(function() {
          return ancestors.forEach(function(element2) {
            return element2.resetTransform();
          });
        });
        read(function() {
          return updateLayoutMeasurement(_this.visualElement);
        });
        write(function() {
          return ancestors.forEach(function(element2) {
            return element2.restoreTransform();
          });
        });
        read(function() {
          _this.resolveDragConstraints();
        });
        if (onReady)
          write(onReady);
      });
    };
    VisualElementDragControls2.prototype.mount = function(visualElement2) {
      var _this = this;
      var element2 = visualElement2.getInstance();
      var stopPointerListener = addPointerEvent(element2, "pointerdown", function(event) {
        var _a = _this.props, drag2 = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;
        drag2 && dragListener && _this.start(event);
      });
      var stopResizeListener = addDomEvent(window, "resize", function() {
        _this.scalePoint();
      });
      var stopLayoutUpdateListener = visualElement2.onLayoutUpdate(function() {
        if (_this.isDragging) {
          _this.resolveDragConstraints();
        }
      });
      var prevDragCursor = visualElement2.prevDragCursor;
      if (prevDragCursor) {
        this.start(lastPointerEvent, { cursorProgress: prevDragCursor });
      }
      return function() {
        stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();
        stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();
        stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();
        _this.cancelDrag();
      };
    };
    return VisualElementDragControls2;
  }()
);
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold) {
  if (lockThreshold === void 0) {
    lockThreshold = 10;
  }
  var direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}

// node_modules/svelte-motion/src/gestures/drag/UseDrag.svelte
function create_fragment21(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let $mcc;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseDrag", slots, ["default"]);
  let { visualElement: visualElement2, props, isCustom } = $$props;
  const mcc = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  validate_store(mcc, "mcc");
  component_subscribe($$self, mcc, (value) => $$invalidate(5, $mcc = value));
  let dragControls = new VisualElementDragControls({ visualElement: visualElement2 });
  let cleanup;
  const dragEffect = () => {
    if (cleanup) {
      cleanup();
    }
    if (groupDragControls) {
      cleanup = groupDragControls.subscribe(dragControls);
    }
  };
  let { dragControls: groupDragControls } = props;
  let { transformPagePoint } = get_store_value(mcc);
  dragControls.setProps({ ...props, transformPagePoint });
  onDestroy(() => {
    if (cleanup) {
      cleanup();
    }
  });
  onMount(() => dragControls.mount(visualElement2));
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<UseDrag> was created without expected prop 'visualElement'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseDrag> was created without expected prop 'props'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<UseDrag> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["visualElement", "props", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseDrag> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(1, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2) $$invalidate(2, props = $$props2.props);
    if ("isCustom" in $$props2) $$invalidate(3, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    MotionConfigContext,
    VisualElementDragControls,
    getContext,
    onDestroy,
    onMount,
    get: get_store_value,
    visualElement: visualElement2,
    props,
    isCustom,
    mcc,
    dragControls,
    cleanup,
    dragEffect,
    groupDragControls,
    transformPagePoint,
    $mcc
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(1, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2) $$invalidate(2, props = $$props2.props);
    if ("isCustom" in $$props2) $$invalidate(3, isCustom = $$props2.isCustom);
    if ("dragControls" in $$props2) $$invalidate(10, dragControls = $$props2.dragControls);
    if ("cleanup" in $$props2) cleanup = $$props2.cleanup;
    if ("groupDragControls" in $$props2) groupDragControls = $$props2.groupDragControls;
    if ("transformPagePoint" in $$props2) $$invalidate(4, transformPagePoint = $$props2.transformPagePoint);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    4) {
      $: ({ dragControls: groupDragControls } = props);
    }
    if ($$self.$$.dirty & /*$mcc*/
    32) {
      $: $$invalidate(4, { transformPagePoint } = $mcc, transformPagePoint);
    }
    if ($$self.$$.dirty & /*props, transformPagePoint*/
    20) {
      $: dragControls.setProps({ ...props, transformPagePoint });
    }
  };
  $: dragEffect(dragControls);
  return [mcc, visualElement2, props, isCustom, transformPagePoint, $mcc, $$scope, slots];
}
var UseDrag = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { visualElement: 1, props: 2, isCustom: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseDrag",
      options,
      id: create_fragment21.name
    });
  }
  get visualElement() {
    throw new Error("<UseDrag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<UseDrag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseDrag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseDrag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<UseDrag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<UseDrag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseDrag_default = UseDrag;

// node_modules/svelte-motion/src/motion/features/drag.js
var drag = {
  pan: UsePanGesture_default,
  drag: UseDrag_default
};

// node_modules/svelte-motion/src/render/dom/projection/default-scale-correctors.js
function pixelsToPercent(pixels, axis) {
  return pixels / (axis.max - axis.min) * 100;
}
function correctBorderRadius(latest, _layoutState, _a) {
  var target = _a.target;
  if (typeof latest === "string") {
    if (px.test(latest)) {
      latest = parseFloat(latest);
    } else {
      return latest;
    }
  }
  var x = pixelsToPercent(latest, target.x);
  var y = pixelsToPercent(latest, target.y);
  return x + "% " + y + "%";
}
var varToken = "_$css";
function correctBoxShadow(latest, _a) {
  var delta2 = _a.delta, treeScale = _a.treeScale;
  var original = latest;
  var containsCSSVariables = latest.includes("var(");
  var cssVariables = [];
  if (containsCSSVariables) {
    latest = latest.replace(cssVariableRegex, function(match) {
      cssVariables.push(match);
      return varToken;
    });
  }
  var shadow = complex.parse(latest);
  if (shadow.length > 5)
    return original;
  var template = complex.createTransformer(latest);
  var offset = typeof shadow[0] !== "number" ? 1 : 0;
  var xScale = delta2.x.scale * treeScale.x;
  var yScale = delta2.y.scale * treeScale.y;
  shadow[0 + offset] /= xScale;
  shadow[1 + offset] /= yScale;
  var averageScale = mix(xScale, yScale, 0.5);
  if (typeof shadow[2 + offset] === "number")
    shadow[2 + offset] /= averageScale;
  if (typeof shadow[3 + offset] === "number")
    shadow[3 + offset] /= averageScale;
  var output = template(shadow);
  if (containsCSSVariables) {
    var i_1 = 0;
    output = output.replace(varToken, function() {
      var cssVariable = cssVariables[i_1];
      i_1++;
      return cssVariable;
    });
  }
  return output;
}
var borderCorrectionDefinition = {
  process: correctBorderRadius
};
var defaultScaleCorrectors = {
  borderRadius: Object.assign(Object.assign({}, borderCorrectionDefinition), { applyTo: [
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ] }),
  borderTopLeftRadius: borderCorrectionDefinition,
  borderTopRightRadius: borderCorrectionDefinition,
  borderBottomLeftRadius: borderCorrectionDefinition,
  borderBottomRightRadius: borderCorrectionDefinition,
  boxShadow: {
    process: correctBoxShadow
  }
};

// node_modules/svelte-motion/src/motion/features/layout/Animate.svelte
function create_fragment22(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var progressTarget = 1e3;
function hasMoved(a, b) {
  return !isZeroBox(a) && !isZeroBox(b) && (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y));
}
var zeroAxis = { min: 0, max: 0 };
function isZeroBox(a) {
  return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);
}
function axisIsEqual(a, b) {
  return a.min === b.min && a.max === b.max;
}
var defaultLayoutTransition = { duration: 0.45, ease: [0.4, 0, 0.1, 1] };
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Animate", slots, []);
  let { visualElement: visualElement2, layout = void 0, safeToRemove } = $$props;
  let frameTarget = axisBox();
  let currentAnimationTarget = axisBox();
  let isAnimating = { x: false, y: false };
  let stopAxisAnimation = { x: void 0, y: void 0 };
  let unsubLayoutReady;
  let isAnimatingTree = false;
  onMount(() => {
    $$invalidate(0, visualElement2.animateMotionValue = startAnimation, visualElement2);
    visualElement2.enableLayoutProjection();
    unsubLayoutReady = visualElement2.onLayoutUpdate(animateF);
    $$invalidate(
      0,
      visualElement2.layoutSafeToRemove = function() {
        safeToRemove();
      },
      visualElement2
    );
    addScaleCorrection(defaultScaleCorrectors);
  });
  onDestroy(() => {
    unsubLayoutReady();
    eachAxis((axis) => {
      var _a;
      return (_a = stopAxisAnimation[axis]) == null ? void 0 : _a.call(stopAxisAnimation);
    });
  });
  const animateF = (target, origin, { originBox, targetBox, visibilityAction, shouldStackAnimate, onComplete, ...config } = {}) => {
    if (shouldStackAnimate === false) {
      isAnimatingTree = false;
      return safeToRemove();
    }
    if (isAnimatingTree && shouldStackAnimate !== true) {
      return;
    } else if (shouldStackAnimate) {
      isAnimatingTree = true;
    }
    origin = originBox || origin;
    target = targetBox || target;
    const boxHasMoved = hasMoved(origin, target);
    const animations2 = eachAxis((axis) => {
      if (layout === "position") {
        const targetLength = target[axis].max - target[axis].min;
        origin[axis].max = origin[axis].min + targetLength;
      }
      if (visualElement2.projection.isTargetLocked) {
        return;
      } else if (visibilityAction !== void 0) {
        visualElement2.setVisibility(visibilityAction === VisibilityAction.Show);
      } else if (boxHasMoved) {
        return animateAxis(axis, target[axis], origin[axis], config);
      } else {
        return visualElement2.setProjectionTargetAxis(axis, target[axis].min, target[axis].max);
      }
    });
    visualElement2.syncRender();
    return Promise.all(animations2).then(() => {
      isAnimatingTree = false;
      onComplete && onComplete();
      visualElement2.notifyLayoutAnimationComplete();
    });
  };
  const animateAxis = (axis, target, origin, { transition: _transition } = {}) => {
    var _a, _b;
    (_a = stopAxisAnimation[axis]) == null ? void 0 : _a.call(stopAxisAnimation);
    if (isAnimating[axis] && axisIsEqual(target, currentAnimationTarget[axis])) {
      return;
    }
    (_b = stopAxisAnimation[axis]) == null ? void 0 : _b.call(stopAxisAnimation);
    isAnimating[axis] = true;
    const _frameTarget = frameTarget[axis];
    const layoutProgress = visualElement2.getProjectionAnimationProgress()[axis];
    layoutProgress.clearListeners();
    layoutProgress.set(0);
    layoutProgress.set(0);
    const frame = () => {
      const p = layoutProgress.get() / progressTarget;
      tweenAxis(_frameTarget, origin, target, p);
      visualElement2.setProjectionTargetAxis(axis, _frameTarget.min, _frameTarget.max);
    };
    frame();
    const unsubscribeProgress = layoutProgress.onChange(frame);
    stopAxisAnimation[axis] = () => {
      isAnimating[axis] = false;
      layoutProgress.stop();
      unsubscribeProgress();
    };
    currentAnimationTarget[axis] = target;
    const layoutTransition = _transition || visualElement2.getDefaultTransition() || defaultLayoutTransition;
    const animation = startAnimation(axis === "x" ? "layoutX" : "layoutY", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, "layout")).then(stopAxisAnimation[axis]);
    return animation;
  };
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<Animate> was created without expected prop 'visualElement'");
    }
    if (safeToRemove === void 0 && !("safeToRemove" in $$props || $$self.$$.bound[$$self.$$.props["safeToRemove"]])) {
      console.warn("<Animate> was created without expected prop 'safeToRemove'");
    }
  });
  const writable_props = ["visualElement", "layout", "safeToRemove"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Animate> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("layout" in $$props2) $$invalidate(1, layout = $$props2.layout);
    if ("safeToRemove" in $$props2) $$invalidate(2, safeToRemove = $$props2.safeToRemove);
  };
  $$self.$capture_state = () => ({
    progressTarget,
    hasMoved,
    zeroAxis,
    isZeroBox,
    axisIsEqual,
    defaultLayoutTransition,
    onDestroy,
    onMount,
    axisBox,
    eachAxis,
    startAnimation,
    getValueTransition,
    tweenAxis,
    addScaleCorrection,
    defaultScaleCorrectors,
    visualElement: visualElement2,
    layout,
    safeToRemove,
    frameTarget,
    currentAnimationTarget,
    isAnimating,
    stopAxisAnimation,
    unsubLayoutReady,
    isAnimatingTree,
    animateF,
    animateAxis
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("layout" in $$props2) $$invalidate(1, layout = $$props2.layout);
    if ("safeToRemove" in $$props2) $$invalidate(2, safeToRemove = $$props2.safeToRemove);
    if ("frameTarget" in $$props2) frameTarget = $$props2.frameTarget;
    if ("currentAnimationTarget" in $$props2) currentAnimationTarget = $$props2.currentAnimationTarget;
    if ("isAnimating" in $$props2) isAnimating = $$props2.isAnimating;
    if ("stopAxisAnimation" in $$props2) stopAxisAnimation = $$props2.stopAxisAnimation;
    if ("unsubLayoutReady" in $$props2) unsubLayoutReady = $$props2.unsubLayoutReady;
    if ("isAnimatingTree" in $$props2) isAnimatingTree = $$props2.isAnimatingTree;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [visualElement2, layout, safeToRemove];
}
var Animate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      visualElement: 0,
      layout: 1,
      safeToRemove: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Animate",
      options,
      id: create_fragment22.name
    });
  }
  get visualElement() {
    throw new Error("<Animate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<Animate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    throw new Error("<Animate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set layout(value) {
    throw new Error("<Animate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get safeToRemove() {
    throw new Error("<Animate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set safeToRemove(value) {
    throw new Error("<Animate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Animate_default = Animate;

// node_modules/svelte-motion/src/motion/features/layout/AnimateLayoutContextProvider.svelte
function create_fragment23(ctx) {
  let animate3;
  let current;
  animate3 = new Animate_default({
    props: {
      visualElement: (
        /*visualElement*/
        ctx[0]
      ),
      layout: (
        /*layout*/
        ctx[1]
      ),
      safeToRemove: (
        /*$presence*/
        ctx[2][1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(animate3.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(animate3.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(animate3, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const animate_changes = {};
      if (dirty & /*visualElement*/
      1) animate_changes.visualElement = /*visualElement*/
      ctx2[0];
      if (dirty & /*layout*/
      2) animate_changes.layout = /*layout*/
      ctx2[1];
      if (dirty & /*$presence*/
      4) animate_changes.safeToRemove = /*$presence*/
      ctx2[2][1];
      animate3.$set(animate_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(animate3.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(animate3.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(animate3, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let $presence;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnimateLayoutContextProvider", slots, []);
  let { visualElement: visualElement2, props, isCustom } = $$props;
  let { layout } = props;
  const presence = usePresence(isCustom);
  validate_store(presence, "presence");
  component_subscribe($$self, presence, (value) => $$invalidate(2, $presence = value));
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<AnimateLayoutContextProvider> was created without expected prop 'visualElement'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<AnimateLayoutContextProvider> was created without expected prop 'props'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<AnimateLayoutContextProvider> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["visualElement", "props", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<AnimateLayoutContextProvider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2) $$invalidate(4, props = $$props2.props);
    if ("isCustom" in $$props2) $$invalidate(5, isCustom = $$props2.isCustom);
  };
  $$self.$capture_state = () => ({
    usePresence,
    Animate: Animate_default,
    visualElement: visualElement2,
    props,
    isCustom,
    layout,
    presence,
    $presence
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2) $$invalidate(4, props = $$props2.props);
    if ("isCustom" in $$props2) $$invalidate(5, isCustom = $$props2.isCustom);
    if ("layout" in $$props2) $$invalidate(1, layout = $$props2.layout);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    16) {
      $: $$invalidate(1, { layout } = props, layout);
    }
  };
  return [visualElement2, layout, $presence, presence, props, isCustom];
}
var AnimateLayoutContextProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { visualElement: 0, props: 4, isCustom: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnimateLayoutContextProvider",
      options,
      id: create_fragment23.name
    });
  }
  get visualElement() {
    throw new Error("<AnimateLayoutContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<AnimateLayoutContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<AnimateLayoutContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<AnimateLayoutContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<AnimateLayoutContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<AnimateLayoutContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnimateLayoutContextProvider_default = AnimateLayoutContextProvider;

// node_modules/svelte-motion/src/motion/features/layout/Measure.svelte
function create_fragment24(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Measure", slots, []);
  let { visualElement: visualElement2, syncLayout, framerSyncLayout, update } = $$props;
  const scaleCorrectionContext = getContext(ScaleCorrectionContext);
  const scaleCorrectionParentContext = getContext(ScaleCorrectionParentContext);
  onMount(() => {
    isSharedLayout(syncLayout) && syncLayout.register(visualElement2);
    isSharedLayout(framerSyncLayout) && framerSyncLayout.register(visualElement2);
    visualElement2.onUnmount(() => {
      if (isSharedLayout(syncLayout)) {
        syncLayout.remove(visualElement2);
      }
      if (isSharedLayout(framerSyncLayout)) {
        framerSyncLayout.remove(visualElement2);
      }
    });
  });
  let updated = false;
  const updater = (nc = false) => {
    if (updated) {
      return null;
    }
    updated = true;
    get_store_value(scaleCorrectionContext).forEach((v) => {
      var _a;
      (_a = v.updater) == null ? void 0 : _a.call(v, true);
    });
    if (isSharedLayout(syncLayout)) {
      syncLayout.syncUpdate();
    } else {
      snapshotViewportBox(visualElement2, nc);
      syncLayout.add(visualElement2);
    }
    return null;
  };
  if (update === void 0) {
    beforeUpdate(updater);
  }
  const afterU = (nc = false) => {
    updated = false;
    const scc = get_store_value(scaleCorrectionContext);
    scc.forEach((v, i) => {
      var _a;
      (_a = v.afterU) == null ? void 0 : _a.call(v, true);
    });
    if (!isSharedLayout(syncLayout)) {
      syncLayout.flush();
    }
  };
  scaleCorrectionParentContext.update((v) => v.concat([{ updater, afterU }]));
  afterUpdate(afterU);
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<Measure> was created without expected prop 'visualElement'");
    }
    if (syncLayout === void 0 && !("syncLayout" in $$props || $$self.$$.bound[$$self.$$.props["syncLayout"]])) {
      console.warn("<Measure> was created without expected prop 'syncLayout'");
    }
    if (framerSyncLayout === void 0 && !("framerSyncLayout" in $$props || $$self.$$.bound[$$self.$$.props["framerSyncLayout"]])) {
      console.warn("<Measure> was created without expected prop 'framerSyncLayout'");
    }
    if (update === void 0 && !("update" in $$props || $$self.$$.bound[$$self.$$.props["update"]])) {
      console.warn("<Measure> was created without expected prop 'update'");
    }
  });
  const writable_props = ["visualElement", "syncLayout", "framerSyncLayout", "update"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Measure> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("syncLayout" in $$props2) $$invalidate(1, syncLayout = $$props2.syncLayout);
    if ("framerSyncLayout" in $$props2) $$invalidate(2, framerSyncLayout = $$props2.framerSyncLayout);
    if ("update" in $$props2) $$invalidate(3, update = $$props2.update);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    beforeUpdate,
    getContext,
    onMount,
    get: get_store_value,
    ScaleCorrectionContext,
    ScaleCorrectionParentContext,
    isSharedLayout,
    snapshotViewportBox,
    visualElement: visualElement2,
    syncLayout,
    framerSyncLayout,
    update,
    scaleCorrectionContext,
    scaleCorrectionParentContext,
    updated,
    updater,
    afterU
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("syncLayout" in $$props2) $$invalidate(1, syncLayout = $$props2.syncLayout);
    if ("framerSyncLayout" in $$props2) $$invalidate(2, framerSyncLayout = $$props2.framerSyncLayout);
    if ("update" in $$props2) $$invalidate(3, update = $$props2.update);
    if ("updated" in $$props2) updated = $$props2.updated;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*update*/
    8) {
      $: update !== void 0 && updater(update);
    }
  };
  return [visualElement2, syncLayout, framerSyncLayout, update];
}
var Measure = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {
      visualElement: 0,
      syncLayout: 1,
      framerSyncLayout: 2,
      update: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Measure",
      options,
      id: create_fragment24.name
    });
  }
  get visualElement() {
    throw new Error("<Measure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<Measure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get syncLayout() {
    throw new Error("<Measure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set syncLayout(value) {
    throw new Error("<Measure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get framerSyncLayout() {
    throw new Error("<Measure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set framerSyncLayout(value) {
    throw new Error("<Measure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get update() {
    throw new Error("<Measure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set update(value) {
    throw new Error("<Measure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Measure_default = Measure;

// node_modules/svelte-motion/src/motion/features/layout/MeasureContextProvider.svelte
function create_fragment25(ctx) {
  let measure;
  let current;
  measure = new Measure_default({
    props: {
      syncLayout: (
        /*$syncLayout*/
        ctx[2]
      ),
      framerSyncLayout: (
        /*$framerSyncLayout*/
        ctx[3]
      ),
      visualElement: (
        /*visualElement*/
        ctx[0]
      ),
      update: (
        /*update*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(measure.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(measure.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(measure, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const measure_changes = {};
      if (dirty & /*$syncLayout*/
      4) measure_changes.syncLayout = /*$syncLayout*/
      ctx2[2];
      if (dirty & /*$framerSyncLayout*/
      8) measure_changes.framerSyncLayout = /*$framerSyncLayout*/
      ctx2[3];
      if (dirty & /*visualElement*/
      1) measure_changes.visualElement = /*visualElement*/
      ctx2[0];
      if (dirty & /*update*/
      2) measure_changes.update = /*update*/
      ctx2[1];
      measure.$set(measure_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(measure.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(measure.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(measure, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let update;
  let $syncLayout;
  let $framerSyncLayout;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MeasureContextProvider", slots, []);
  let { visualElement: visualElement2, props, isCustom } = $$props;
  const syncLayout = getContext(SharedLayoutContext) || SharedLayoutContext(isCustom);
  validate_store(syncLayout, "syncLayout");
  component_subscribe($$self, syncLayout, (value) => $$invalidate(2, $syncLayout = value));
  const framerSyncLayout = getContext(FramerTreeLayoutContext) || FramerTreeLayoutContext(isCustom);
  validate_store(framerSyncLayout, "framerSyncLayout");
  component_subscribe($$self, framerSyncLayout, (value) => $$invalidate(3, $framerSyncLayout = value));
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<MeasureContextProvider> was created without expected prop 'visualElement'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<MeasureContextProvider> was created without expected prop 'props'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<MeasureContextProvider> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["visualElement", "props", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<MeasureContextProvider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2) $$invalidate(6, props = $$props2.props);
    if ("isCustom" in $$props2) $$invalidate(7, isCustom = $$props2.isCustom);
  };
  $$self.$capture_state = () => ({
    getContext,
    SharedLayoutContext,
    FramerTreeLayoutContext,
    Measure: Measure_default,
    visualElement: visualElement2,
    props,
    isCustom,
    syncLayout,
    framerSyncLayout,
    update,
    $syncLayout,
    $framerSyncLayout
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2) $$invalidate(6, props = $$props2.props);
    if ("isCustom" in $$props2) $$invalidate(7, isCustom = $$props2.isCustom);
    if ("update" in $$props2) $$invalidate(1, update = $$props2.update);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    64) {
      $: $$invalidate(1, { update } = props, update);
    }
  };
  return [
    visualElement2,
    update,
    $syncLayout,
    $framerSyncLayout,
    syncLayout,
    framerSyncLayout,
    props,
    isCustom
  ];
}
var MeasureContextProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, { visualElement: 0, props: 6, isCustom: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MeasureContextProvider",
      options,
      id: create_fragment25.name
    });
  }
  get visualElement() {
    throw new Error("<MeasureContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<MeasureContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<MeasureContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<MeasureContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<MeasureContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<MeasureContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MeasureContextProvider_default = MeasureContextProvider;

// node_modules/svelte-motion/src/motion/features/layout/index.js
var layoutAnimations = {
  measureLayout: MeasureContextProvider_default,
  layoutAnimation: AnimateLayoutContextProvider_default
};

// node_modules/svelte-motion/src/motion/features/AnimationState.svelte
function create_fragment26(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnimationState", slots, []);
  let { visualElement: visualElement2, props } = $$props;
  let { animate: animate3 } = props;
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<AnimationState> was created without expected prop 'visualElement'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<AnimationState> was created without expected prop 'props'");
    }
  });
  const writable_props = ["visualElement", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<AnimationState> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2) $$invalidate(1, props = $$props2.props);
  };
  $$self.$capture_state = () => ({
    tick,
    createAnimationState,
    isAnimationControls,
    visualElement: visualElement2,
    props,
    animate: animate3
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2) $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2) $$invalidate(1, props = $$props2.props);
    if ("animate" in $$props2) $$invalidate(2, animate3 = $$props2.animate);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    2) {
      $: $$invalidate(2, { animate: animate3 } = props, animate3);
    }
    if ($$self.$$.dirty & /*visualElement*/
    1) {
      $: {
        $$invalidate(0, visualElement2.animationState = visualElement2.animationState || createAnimationState(visualElement2), visualElement2);
      }
    }
    if ($$self.$$.dirty & /*animate, visualElement*/
    5) {
      $: if (isAnimationControls(animate3)) {
        tick().then(() => animate3.subscribe(visualElement2));
      }
    }
  };
  return [visualElement2, props, animate3];
}
var AnimationState = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { visualElement: 0, props: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnimationState",
      options,
      id: create_fragment26.name
    });
  }
  get visualElement() {
    throw new Error("<AnimationState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<AnimationState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<AnimationState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<AnimationState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnimationState_default = AnimationState;

// node_modules/svelte-motion/src/motion/features/Exit.svelte
function create_fragment27(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let custom;
  let $presence;
  let $presenceContext;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Exit", slots, ["default"]);
  let { props, visualElement: visualElement2, isCustom } = $$props;
  const presenceContext = getContext(PresenceContext) || PresenceContext(isCustom);
  validate_store(presenceContext, "presenceContext");
  component_subscribe($$self, presenceContext, (value) => $$invalidate(9, $presenceContext = value));
  const presence = usePresence(isCustom);
  validate_store(presence, "presence");
  component_subscribe($$self, presence, (value) => $$invalidate(5, $presence = value));
  const effect = (pres) => {
    var _a;
    const [isPresent2, onExitComplete] = pres;
    const animation = (_a = visualElement2.animationState) == null ? void 0 : _a.setActive(AnimationType.Exit, !isPresent2, {
      custom: ($presenceContext == null ? void 0 : $presenceContext.custom) ?? custom
    });
    !isPresent2 && (animation == null ? void 0 : animation.then(onExitComplete));
    return "";
  };
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<Exit> was created without expected prop 'props'");
    }
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<Exit> was created without expected prop 'visualElement'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<Exit> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["props", "visualElement", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Exit> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2) $$invalidate(2, props = $$props2.props);
    if ("visualElement" in $$props2) $$invalidate(3, visualElement2 = $$props2.visualElement);
    if ("isCustom" in $$props2) $$invalidate(4, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    usePresence,
    getContext,
    PresenceContext,
    AnimationType,
    props,
    visualElement: visualElement2,
    isCustom,
    presenceContext,
    presence,
    effect,
    custom,
    $presence,
    $presenceContext
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2) $$invalidate(2, props = $$props2.props);
    if ("visualElement" in $$props2) $$invalidate(3, visualElement2 = $$props2.visualElement);
    if ("isCustom" in $$props2) $$invalidate(4, isCustom = $$props2.isCustom);
    if ("custom" in $$props2) custom = $$props2.custom;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    4) {
      $: ({ custom } = props);
    }
    if ($$self.$$.dirty & /*$presence*/
    32) {
      $: effect($presence);
    }
  };
  return [
    presenceContext,
    presence,
    props,
    visualElement2,
    isCustom,
    $presence,
    $$scope,
    slots
  ];
}
var Exit = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, { props: 2, visualElement: 3, isCustom: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Exit",
      options,
      id: create_fragment27.name
    });
  }
  get props() {
    throw new Error("<Exit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<Exit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualElement() {
    throw new Error("<Exit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<Exit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<Exit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<Exit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Exit_default = Exit;

// node_modules/svelte-motion/src/motion/features/animations.js
var animations = {
  animation: AnimationState_default,
  exit: Exit_default
};

// node_modules/svelte-motion/src/render/dom/featureBundle.js
var featureBundle = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layoutAnimations
};

// node_modules/svelte-motion/src/render/dom/motion.js
var motion = (
  //createMotionProxy(allMotionFeatures);
  createMotionClass(featureBundle)
);

// node_modules/svelte-motion/src/render/svg/lowercase-elements.js
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "tspan",
  "use",
  "view"
];

// node_modules/svelte-motion/src/render/dom/utils/is-svg-component.js
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component)
  ) {
    return true;
  }
  return false;
}

// node_modules/svelte-motion/src/render/dom/M.svelte
var file = "node_modules/svelte-motion/src/render/dom/M.svelte";
function create_dynamic_element(ctx) {
  let svelte_element;
  let motion_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let svelte_element_levels = [
    /*props*/
    ctx[4]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*___tag*/
        ctx[0]
      );
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*___tag*/
        (ctx[0] || "null").toUpperCase(),
        {}
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot) default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*___tag*/
        ctx[0]
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file, 6, 4, 147);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(motion_action = /*motion*/
        ctx[5].call(null, svelte_element));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*___tag*/
        ctx2[0]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*props*/
      16 && /*props*/
      ctx2[4]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(7:4) <svelte:element this={___tag} use:motion {...props}>",
    ctx
  });
  return block;
}
function create_default_slot9(ctx) {
  let previous_tag = (
    /*___tag*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*___tag*/
    ctx[0]
  );
  validate_void_dynamic_element(
    /*___tag*/
    ctx[0]
  );
  let svelte_element = (
    /*___tag*/
    ctx[0] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element) svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*___tag*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*___tag*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*___tag*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*___tag*/
            ctx2[0]
          );
          validate_void_dynamic_element(
            /*___tag*/
            ctx2[0]
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*___tag*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*___tag*/
        ctx2[0];
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element) svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(6:0) <Motion {...$$restProps} let:props let:motion>",
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let motion_1;
  let current;
  const motion_1_spread_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let motion_1_props = {
    $$slots: {
      default: [
        create_default_slot9,
        ({ props, motion: motion2 }) => ({ 4: props, 5: motion2 }),
        ({ props, motion: motion2 }) => (props ? 16 : 0) | (motion2 ? 32 : 0)
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < motion_1_spread_levels.length; i += 1) {
    motion_1_props = assign(motion_1_props, motion_1_spread_levels[i]);
  }
  motion_1 = new Motion_default({ props: motion_1_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(motion_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(motion_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(motion_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const motion_1_changes = dirty & /*$$restProps*/
      2 ? get_spread_update(motion_1_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[1]
      )]) : {};
      if (dirty & /*$$scope, props, ___tag*/
      25) {
        motion_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      motion_1.$set(motion_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(motion_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(motion_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(motion_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  const omit_props_names = ["___tag"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("M", slots, ["default"]);
  let { ___tag } = $$props;
  $$self.$$.on_mount.push(function() {
    if (___tag === void 0 && !("___tag" in $$props || $$self.$$.bound[$$self.$$.props["___tag"]])) {
      console.warn("<M> was created without expected prop '___tag'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("___tag" in $$new_props) $$invalidate(0, ___tag = $$new_props.___tag);
    if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Motion: Motion_default, ___tag });
  $$self.$inject_state = ($$new_props) => {
    if ("___tag" in $$props) $$invalidate(0, ___tag = $$new_props.___tag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [___tag, $$restProps, slots, $$scope];
}
var M = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, { ___tag: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "M",
      options,
      id: create_fragment28.name
    });
  }
  get ___tag() {
    throw new Error("<M>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ___tag(value) {
    throw new Error("<M>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var M_default = M;

// node_modules/svelte-motion/src/render/dom/motion-proxy.js
function createMotionProxy(defaultFeatures) {
  return new Proxy({}, {
    /**
     * Called when `motion` is referenced with a prop: `MotionDiv`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: function(_target, key) {
      let type = key;
      if (key.slice(0, 1) === key.slice(0, 1).toLowerCase()) {
        type = isSVGComponent(key) ? "SVG" : "DOM";
      }
      const ret = new Proxy(M_default, {
        construct(target, args) {
          if (!args || !args[0]) {
            args.push({});
          }
          if (!args[0].props) {
            args[0].props = { ___tag: key, isSVG: type === "SVG" };
          } else {
            args[0].props.___tag = key;
            args[0].props.isSVG = type === "SVG";
          }
          return new target(...args);
        }
      });
      return ret;
    }
  });
}
var M2 = createMotionProxy();

// node_modules/svelte-motion/src/motion/MotionSSR.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
var get_default_slot_changes11 = (dirty) => ({
  motion: dirty & /*motion*/
  16777216,
  props: dirty & /*renderProps*/
  33554432
});
var get_default_slot_context11 = (ctx) => ({
  motion: (
    /*motion*/
    ctx[24]
  ),
  props: (
    /*renderProps*/
    ctx[25]
  )
});
function create_default_slot_62(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context11
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, motion, renderProps*/
        50364416)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes11
            ),
            get_default_slot_context11
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_62.name,
    type: "slot",
    source: "(205:24) <UseRender                             {Component}                             props={motionProps}                             ref={useMotionRef(                                 visualState,                                 context.visualElement,                                 externalRef                             )}                             {visualState}                             {isStatic}                             {forwardMotionProps}                             let:motion                             let:props={renderProps}                             {targetEl}                         >",
    ctx
  });
  return block;
}
function create_default_slot_52(ctx) {
  let userender;
  let current;
  userender = new UseRender_default({
    props: {
      Component: (
        /*Component*/
        ctx[6]
      ),
      props: (
        /*motionProps*/
        ctx[5]
      ),
      ref: useMotionRef(
        /*visualState*/
        ctx[18],
        /*context*/
        ctx[17].visualElement,
        /*externalRef*/
        ctx[1]
      ),
      visualState: (
        /*visualState*/
        ctx[18]
      ),
      isStatic: (
        /*isStatic*/
        ctx[4]
      ),
      forwardMotionProps: (
        /*forwardMotionProps*/
        ctx[0]
      ),
      targetEl: (
        /*targetEl*/
        ctx[2]
      ),
      $$slots: {
        default: [
          create_default_slot_62,
          ({ motion: motion2, props: renderProps }) => ({ 24: motion2, 25: renderProps }),
          ({ motion: motion2, props: renderProps }) => (motion2 ? 16777216 : 0) | (renderProps ? 33554432 : 0)
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(userender.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(userender.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(userender, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const userender_changes = {};
      if (dirty & /*motionProps*/
      32) userender_changes.props = /*motionProps*/
      ctx2[5];
      if (dirty & /*visualState, context, externalRef*/
      393218) userender_changes.ref = useMotionRef(
        /*visualState*/
        ctx2[18],
        /*context*/
        ctx2[17].visualElement,
        /*externalRef*/
        ctx2[1]
      );
      if (dirty & /*visualState*/
      262144) userender_changes.visualState = /*visualState*/
      ctx2[18];
      if (dirty & /*isStatic*/
      16) userender_changes.isStatic = /*isStatic*/
      ctx2[4];
      if (dirty & /*forwardMotionProps*/
      1) userender_changes.forwardMotionProps = /*forwardMotionProps*/
      ctx2[0];
      if (dirty & /*targetEl*/
      4) userender_changes.targetEl = /*targetEl*/
      ctx2[2];
      if (dirty & /*$$scope, motion, renderProps*/
      50364416) {
        userender_changes.$$scope = { dirty, ctx: ctx2 };
      }
      userender.$set(userender_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(userender.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(userender.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(userender, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_52.name,
    type: "slot",
    source: "(204:20) <MotionContextProvider value={context} {isCustom}>",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*_features*/
    ctx[20]
  );
  const get_key = (ctx2) => (
    /*feat*/
    ctx2[21].key
  );
  validate_each_keys(ctx, each_value, get_each_context2, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*_features, isCustom*/
      1048704) {
        each_value = ensure_array_like_dev(
          /*_features*/
          ctx2[20]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block2, each_1_anchor, get_each_context2);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(224:20) {#if mounted}",
    ctx
  });
  return block;
}
function create_each_block2(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*feat*/
    ctx[21].Component
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        props: (
          /*feat*/
          ctx2[21].props
        ),
        visualElement: (
          /*feat*/
          ctx2[21].visualElement
        ),
        isCustom: (
          /*isCustom*/
          ctx2[7]
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*_features*/
      1048576 && switch_value !== (switch_value = /*feat*/
      ctx[21].Component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*_features*/
        1048576) switch_instance_changes.props = /*feat*/
        ctx[21].props;
        if (dirty & /*_features*/
        1048576) switch_instance_changes.visualElement = /*feat*/
        ctx[21].visualElement;
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(225:24) {#each _features as feat (feat.key)}",
    ctx
  });
  return block;
}
function create_default_slot_42(ctx) {
  let motioncontextprovider;
  let t;
  let if_block_anchor;
  let current;
  motioncontextprovider = new MotionContextProvider_default({
    props: {
      value: (
        /*context*/
        ctx[17]
      ),
      isCustom: (
        /*isCustom*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot_52] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block = (
    /*mounted*/
    ctx[3] && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      create_component(motioncontextprovider.$$.fragment);
      t = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(motioncontextprovider.$$.fragment, nodes);
      t = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(motioncontextprovider, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const motioncontextprovider_changes = {};
      if (dirty & /*context*/
      131072) motioncontextprovider_changes.value = /*context*/
      ctx2[17];
      if (dirty & /*$$scope, motionProps, visualState, context, externalRef, isStatic, forwardMotionProps, targetEl*/
      426039) {
        motioncontextprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      motioncontextprovider.$set(motioncontextprovider_changes);
      if (
        /*mounted*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*mounted*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(motioncontextprovider.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(motioncontextprovider.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      destroy_component(motioncontextprovider, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_42.name,
    type: "slot",
    source: "(199:16) <UseFeatures                     visualElement={setContext(context, visualElement)}                     props={motionProps}                     let:features={_features}                 >",
    ctx
  });
  return block;
}
function create_default_slot_32(ctx) {
  let usefeatures;
  let current;
  usefeatures = new UseFeatures_default({
    props: {
      visualElement: (
        /*setContext*/
        ctx[11](
          /*context*/
          ctx[17],
          /*visualElement*/
          ctx[19]
        )
      ),
      props: (
        /*motionProps*/
        ctx[5]
      ),
      $$slots: {
        default: [
          create_default_slot_42,
          ({ features: _features }) => ({ 20: _features }),
          ({ features: _features }) => _features ? 1048576 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usefeatures.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usefeatures.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usefeatures, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usefeatures_changes = {};
      if (dirty & /*context, visualElement*/
      655360) usefeatures_changes.visualElement = /*setContext*/
      ctx2[11](
        /*context*/
        ctx2[17],
        /*visualElement*/
        ctx2[19]
      );
      if (dirty & /*motionProps*/
      32) usefeatures_changes.props = /*motionProps*/
      ctx2[5];
      if (dirty & /*$$scope, _features, mounted, context, motionProps, visualState, externalRef, isStatic, forwardMotionProps, targetEl*/
      1474623) {
        usefeatures_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usefeatures.$set(usefeatures_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usefeatures.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usefeatures.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usefeatures, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_32.name,
    type: "slot",
    source: "(191:12) <UseVisualElement                 {Component}                 {visualState}                 {createVisualElement}                 props={motionProps}                 {isCustom}                 let:visualElement             >",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let usevisualelement;
  let current;
  usevisualelement = new UseVisualElement_default({
    props: {
      Component: (
        /*Component*/
        ctx[6]
      ),
      visualState: (
        /*visualState*/
        ctx[18]
      ),
      createVisualElement: (
        /*createVisualElement*/
        ctx[8]
      ),
      props: (
        /*motionProps*/
        ctx[5]
      ),
      isCustom: (
        /*isCustom*/
        ctx[7]
      ),
      $$slots: {
        default: [
          create_default_slot_32,
          ({ visualElement: visualElement2 }) => ({ 19: visualElement2 }),
          ({ visualElement: visualElement2 }) => visualElement2 ? 524288 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usevisualelement.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usevisualelement.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usevisualelement, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usevisualelement_changes = {};
      if (dirty & /*visualState*/
      262144) usevisualelement_changes.visualState = /*visualState*/
      ctx2[18];
      if (dirty & /*motionProps*/
      32) usevisualelement_changes.props = /*motionProps*/
      ctx2[5];
      if (dirty & /*$$scope, context, visualElement, motionProps, mounted, visualState, externalRef, isStatic, forwardMotionProps, targetEl*/
      950335) {
        usevisualelement_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usevisualelement.$set(usevisualelement_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usevisualelement.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usevisualelement.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usevisualelement, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: "(184:8) <UseVisualState             config={visualStateConfig}             props={motionProps}             {isStatic}             {isCustom}             let:state={visualState}         >",
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let usevisualstate;
  let current;
  usevisualstate = new UseVisualState_default({
    props: {
      config: (
        /*visualStateConfig*/
        ctx[9]
      ),
      props: (
        /*motionProps*/
        ctx[5]
      ),
      isStatic: (
        /*isStatic*/
        ctx[4]
      ),
      isCustom: (
        /*isCustom*/
        ctx[7]
      ),
      $$slots: {
        default: [
          create_default_slot_22,
          ({ state: visualState }) => ({ 18: visualState }),
          ({ state: visualState }) => visualState ? 262144 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usevisualstate.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usevisualstate.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usevisualstate, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usevisualstate_changes = {};
      if (dirty & /*motionProps*/
      32) usevisualstate_changes.props = /*motionProps*/
      ctx2[5];
      if (dirty & /*isStatic*/
      16) usevisualstate_changes.isStatic = /*isStatic*/
      ctx2[4];
      if (dirty & /*$$scope, visualState, motionProps, context, mounted, externalRef, isStatic, forwardMotionProps, targetEl*/
      426047) {
        usevisualstate_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usevisualstate.$set(usevisualstate_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usevisualstate.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usevisualstate.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usevisualstate, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: "(183:4) <UseCreateMotionContext props={motionProps} {isStatic} let:value={context}>",
    ctx
  });
  return block;
}
function create_default_slot10(ctx) {
  let usecreatemotioncontext;
  let current;
  usecreatemotioncontext = new UseCreateMotionContext_default({
    props: {
      props: (
        /*motionProps*/
        ctx[5]
      ),
      isStatic: (
        /*isStatic*/
        ctx[4]
      ),
      $$slots: {
        default: [
          create_default_slot_13,
          ({ value: context }) => ({ 17: context }),
          ({ value: context }) => context ? 131072 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usecreatemotioncontext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usecreatemotioncontext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usecreatemotioncontext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usecreatemotioncontext_changes = {};
      if (dirty & /*motionProps*/
      32) usecreatemotioncontext_changes.props = /*motionProps*/
      ctx2[5];
      if (dirty & /*isStatic*/
      16) usecreatemotioncontext_changes.isStatic = /*isStatic*/
      ctx2[4];
      if (dirty & /*$$scope, motionProps, isStatic, context, mounted, externalRef, forwardMotionProps, targetEl*/
      163903) {
        usecreatemotioncontext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usecreatemotioncontext.$set(usecreatemotioncontext_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(usecreatemotioncontext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usecreatemotioncontext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usecreatemotioncontext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(182:0) <ScaleCorrectionProvider {isCustom}>",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let scalecorrectionprovider;
  let current;
  scalecorrectionprovider = new ScaleCorrectionProvider_default({
    props: {
      isCustom: (
        /*isCustom*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scalecorrectionprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(scalecorrectionprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scalecorrectionprovider, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const scalecorrectionprovider_changes = {};
      if (dirty & /*$$scope, motionProps, isStatic, mounted, externalRef, forwardMotionProps, targetEl*/
      32831) {
        scalecorrectionprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scalecorrectionprovider.$set(scalecorrectionprovider_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(scalecorrectionprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scalecorrectionprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scalecorrectionprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  let motionProps;
  let isStatic;
  const omit_props_names = ["isSVG", "forwardMotionProps", "externalRef", "targetEl"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MotionSSR", slots, ["default"]);
  let { isSVG = false, forwardMotionProps = false, externalRef = void 0, targetEl = void 0 } = $$props;
  loadFeatures(featureBundle);
  let Component = isSVG ? "SVG" : "DOM";
  let isCustom = targetEl || false;
  let createVisualElement = createDomVisualElement;
  let visualStateConfig = isSVG ? svgMotionConfig : htmlMotionConfig;
  const a = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  validate_store(a, "a");
  component_subscribe($$self, a, (value) => $$invalidate(13, $a = value));
  let mounted = false;
  const setContext2 = (c, v) => {
    c.visualElement = v;
    return v;
  };
  onMount(() => {
    $$invalidate(3, mounted = true);
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isSVG" in $$new_props) $$invalidate(12, isSVG = $$new_props.isSVG);
    if ("forwardMotionProps" in $$new_props) $$invalidate(0, forwardMotionProps = $$new_props.forwardMotionProps);
    if ("externalRef" in $$new_props) $$invalidate(1, externalRef = $$new_props.externalRef);
    if ("targetEl" in $$new_props) $$invalidate(2, targetEl = $$new_props.targetEl);
    if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MotionConfigContext,
    UseVisualElement: UseVisualElement_default,
    UseFeatures: UseFeatures_default,
    MotionContextProvider: MotionContextProvider_default,
    getContext,
    onMount,
    UseRender: UseRender_default,
    createDomVisualElement,
    svgMotionConfig,
    htmlMotionConfig,
    UseCreateMotionContext: UseCreateMotionContext_default,
    UseVisualState: UseVisualState_default,
    useMotionRef,
    ScaleCorrectionProvider: ScaleCorrectionProvider_default,
    featureBundle,
    loadFeatures,
    isSVG,
    forwardMotionProps,
    externalRef,
    targetEl,
    Component,
    isCustom,
    createVisualElement,
    visualStateConfig,
    a,
    mounted,
    setContext: setContext2,
    isStatic,
    motionProps,
    $a
  });
  $$self.$inject_state = ($$new_props) => {
    if ("isSVG" in $$props) $$invalidate(12, isSVG = $$new_props.isSVG);
    if ("forwardMotionProps" in $$props) $$invalidate(0, forwardMotionProps = $$new_props.forwardMotionProps);
    if ("externalRef" in $$props) $$invalidate(1, externalRef = $$new_props.externalRef);
    if ("targetEl" in $$props) $$invalidate(2, targetEl = $$new_props.targetEl);
    if ("Component" in $$props) $$invalidate(6, Component = $$new_props.Component);
    if ("isCustom" in $$props) $$invalidate(7, isCustom = $$new_props.isCustom);
    if ("createVisualElement" in $$props) $$invalidate(8, createVisualElement = $$new_props.createVisualElement);
    if ("visualStateConfig" in $$props) $$invalidate(9, visualStateConfig = $$new_props.visualStateConfig);
    if ("mounted" in $$props) $$invalidate(3, mounted = $$new_props.mounted);
    if ("isStatic" in $$props) $$invalidate(4, isStatic = $$new_props.isStatic);
    if ("motionProps" in $$props) $$invalidate(5, motionProps = $$new_props.motionProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(5, motionProps = $$restProps);
    if ($$self.$$.dirty & /*$a*/
    8192) {
      $: $$invalidate(4, { isStatic } = $a || {}, isStatic);
    }
  };
  return [
    forwardMotionProps,
    externalRef,
    targetEl,
    mounted,
    isStatic,
    motionProps,
    Component,
    isCustom,
    createVisualElement,
    visualStateConfig,
    a,
    setContext2,
    isSVG,
    $a,
    slots,
    $$scope
  ];
}
var MotionSSR = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {
      isSVG: 12,
      forwardMotionProps: 0,
      externalRef: 1,
      targetEl: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MotionSSR",
      options,
      id: create_fragment29.name
    });
  }
  get isSVG() {
    throw new Error("<MotionSSR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSVG(value) {
    throw new Error("<MotionSSR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forwardMotionProps() {
    throw new Error("<MotionSSR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forwardMotionProps(value) {
    throw new Error("<MotionSSR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get externalRef() {
    throw new Error("<MotionSSR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set externalRef(value) {
    throw new Error("<MotionSSR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetEl() {
    throw new Error("<MotionSSR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetEl(value) {
    throw new Error("<MotionSSR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MotionSSR_default = MotionSSR;

// node_modules/svelte-motion/src/components/AnimatePresence/PresenceChild.svelte
function create_fragment30(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var presenceId = 0;
function getPresenceId() {
  const id = presenceId;
  presenceId++;
  return id;
}
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function instance30($$self, $$props, $$invalidate) {
  let refresh;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PresenceChild", slots, ["default"]);
  let { isPresent: isPresent2, onExitComplete = void 0, initial, custom = void 0, presenceAffectsLayout, isCustom } = $$props;
  const presenceChildren = new newChildrenMap();
  const id = getPresenceId();
  const memoContext = () => {
    return {
      id,
      initial,
      isPresent: isPresent2,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        let allComplete = true;
        presenceChildren.forEach((isComplete) => {
          if (!isComplete) allComplete = false;
        });
        allComplete && (onExitComplete == null ? void 0 : onExitComplete());
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    };
  };
  let context = PresenceContext();
  afterUpdate(() => {
    if (presenceAffectsLayout) {
      context.set(memoContext());
    }
  });
  const keyset = () => {
    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
  };
  setContext(PresenceContext, context);
  setDomContext("Presence", isCustom, context);
  $$self.$$.on_mount.push(function() {
    if (isPresent2 === void 0 && !("isPresent" in $$props || $$self.$$.bound[$$self.$$.props["isPresent"]])) {
      console.warn("<PresenceChild> was created without expected prop 'isPresent'");
    }
    if (initial === void 0 && !("initial" in $$props || $$self.$$.bound[$$self.$$.props["initial"]])) {
      console.warn("<PresenceChild> was created without expected prop 'initial'");
    }
    if (presenceAffectsLayout === void 0 && !("presenceAffectsLayout" in $$props || $$self.$$.bound[$$self.$$.props["presenceAffectsLayout"]])) {
      console.warn("<PresenceChild> was created without expected prop 'presenceAffectsLayout'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<PresenceChild> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = [
    "isPresent",
    "onExitComplete",
    "initial",
    "custom",
    "presenceAffectsLayout",
    "isCustom"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<PresenceChild> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("isPresent" in $$props2) $$invalidate(0, isPresent2 = $$props2.isPresent);
    if ("onExitComplete" in $$props2) $$invalidate(1, onExitComplete = $$props2.onExitComplete);
    if ("initial" in $$props2) $$invalidate(2, initial = $$props2.initial);
    if ("custom" in $$props2) $$invalidate(3, custom = $$props2.custom);
    if ("presenceAffectsLayout" in $$props2) $$invalidate(4, presenceAffectsLayout = $$props2.presenceAffectsLayout);
    if ("isCustom" in $$props2) $$invalidate(5, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2) $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    presenceId,
    getPresenceId,
    newChildrenMap,
    afterUpdate,
    setContext,
    tick,
    setDomContext,
    PresenceContext,
    isPresent: isPresent2,
    onExitComplete,
    initial,
    custom,
    presenceAffectsLayout,
    isCustom,
    presenceChildren,
    id,
    memoContext,
    context,
    keyset,
    refresh
  });
  $$self.$inject_state = ($$props2) => {
    if ("isPresent" in $$props2) $$invalidate(0, isPresent2 = $$props2.isPresent);
    if ("onExitComplete" in $$props2) $$invalidate(1, onExitComplete = $$props2.onExitComplete);
    if ("initial" in $$props2) $$invalidate(2, initial = $$props2.initial);
    if ("custom" in $$props2) $$invalidate(3, custom = $$props2.custom);
    if ("presenceAffectsLayout" in $$props2) $$invalidate(4, presenceAffectsLayout = $$props2.presenceAffectsLayout);
    if ("isCustom" in $$props2) $$invalidate(5, isCustom = $$props2.isCustom);
    if ("context" in $$props2) $$invalidate(12, context = $$props2.context);
    if ("refresh" in $$props2) $$invalidate(6, refresh = $$props2.refresh);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*presenceAffectsLayout, isPresent*/
    17) {
      $: $$invalidate(6, refresh = presenceAffectsLayout ? void 0 : isPresent2);
    }
    if ($$self.$$.dirty & /*refresh*/
    64) {
      $: context.set(memoContext(refresh));
    }
    if ($$self.$$.dirty & /*isPresent*/
    1) {
      $: keyset(isPresent2);
    }
    if ($$self.$$.dirty & /*isPresent, onExitComplete*/
    3) {
      $: tick().then(() => {
        !isPresent2 && !presenceChildren.size && (onExitComplete == null ? void 0 : onExitComplete());
      });
    }
  };
  return [
    isPresent2,
    onExitComplete,
    initial,
    custom,
    presenceAffectsLayout,
    isCustom,
    refresh,
    $$scope,
    slots
  ];
}
var PresenceChild = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      isPresent: 0,
      onExitComplete: 1,
      initial: 2,
      custom: 3,
      presenceAffectsLayout: 4,
      isCustom: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PresenceChild",
      options,
      id: create_fragment30.name
    });
  }
  get isPresent() {
    throw new Error("<PresenceChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isPresent(value) {
    throw new Error("<PresenceChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExitComplete() {
    throw new Error("<PresenceChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExitComplete(value) {
    throw new Error("<PresenceChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initial() {
    throw new Error("<PresenceChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initial(value) {
    throw new Error("<PresenceChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get custom() {
    throw new Error("<PresenceChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set custom(value) {
    throw new Error("<PresenceChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get presenceAffectsLayout() {
    throw new Error("<PresenceChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set presenceAffectsLayout(value) {
    throw new Error("<PresenceChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<PresenceChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<PresenceChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PresenceChild_default = PresenceChild;

// node_modules/svelte-motion/src/components/AnimatePresence/AnimatePresence.svelte
var { Map: Map_1 } = globals;
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
var get_default_slot_changes12 = (dirty) => ({ item: dirty & /*childrenToRender*/
16 });
var get_default_slot_context12 = (ctx) => ({ item: (
  /*child*/
  ctx[22].item
) });
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_default_slot_context12
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, childrenToRender*/
        262160)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_default_slot_changes12
            ),
            get_default_slot_context12
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(162:1) <PresenceChild         isPresent={child.present}         initial={initial ? undefined : false}         custom={child.onExit ? custom : undefined}         {presenceAffectsLayout}         onExitComplete={child.onExit}         {isCustom}     >",
    ctx
  });
  return block;
}
function create_each_block3(key_1, ctx) {
  let first;
  let presencechild;
  let current;
  presencechild = new PresenceChild_default({
    props: {
      isPresent: (
        /*child*/
        ctx[22].present
      ),
      initial: (
        /*initial*/
        ctx[1] ? void 0 : false
      ),
      custom: (
        /*child*/
        ctx[22].onExit ? (
          /*custom*/
          ctx[0]
        ) : void 0
      ),
      presenceAffectsLayout: (
        /*presenceAffectsLayout*/
        ctx[2]
      ),
      onExitComplete: (
        /*child*/
        ctx[22].onExit
      ),
      isCustom: (
        /*isCustom*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot11] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(presencechild.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(presencechild.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(presencechild, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const presencechild_changes = {};
      if (dirty & /*childrenToRender*/
      16) presencechild_changes.isPresent = /*child*/
      ctx[22].present;
      if (dirty & /*initial*/
      2) presencechild_changes.initial = /*initial*/
      ctx[1] ? void 0 : false;
      if (dirty & /*childrenToRender, custom*/
      17) presencechild_changes.custom = /*child*/
      ctx[22].onExit ? (
        /*custom*/
        ctx[0]
      ) : void 0;
      if (dirty & /*presenceAffectsLayout*/
      4) presencechild_changes.presenceAffectsLayout = /*presenceAffectsLayout*/
      ctx[2];
      if (dirty & /*childrenToRender*/
      16) presencechild_changes.onExitComplete = /*child*/
      ctx[22].onExit;
      if (dirty & /*isCustom*/
      8) presencechild_changes.isCustom = /*isCustom*/
      ctx[3];
      if (dirty & /*$$scope, childrenToRender*/
      262160) {
        presencechild_changes.$$scope = { dirty, ctx };
      }
      presencechild.$set(presencechild_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(presencechild.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(presencechild.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(presencechild, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(161:0) {#each childrenToRender as child (getChildKey(child)) }",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let each_blocks = [];
  let each_1_lookup = new Map_1();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*childrenToRender*/
    ctx[4]
  );
  const get_key = (ctx2) => getChildKey(
    /*child*/
    ctx2[22]
  );
  validate_each_keys(ctx, each_value, get_each_context3, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*childrenToRender, initial, undefined, custom, presenceAffectsLayout, isCustom, $$scope*/
      262175) {
        each_value = ensure_array_like_dev(
          /*childrenToRender*/
          ctx2[4]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context3, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block3, each_1_anchor, get_each_context3);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getChildKey(child) {
  return child.key || "";
}
function instance31($$self, $$props, $$invalidate) {
  let isl;
  let forceRender;
  let $layoutContext;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnimatePresence", slots, ["default"]);
  let { list = void 0, custom = void 0, initial = true, onExitComplete = void 0, exitBeforeEnter = void 0, presenceAffectsLayout = true, show = void 0, isCustom = false } = $$props;
  let _list = list !== void 0 ? list : show ? [{ key: 1 }] : [];
  const layoutContext = getContext(SharedLayoutContext) || SharedLayoutContext(isCustom);
  validate_store(layoutContext, "layoutContext");
  component_subscribe($$self, layoutContext, (value) => $$invalidate(16, $layoutContext = value));
  let isInitialRender = true;
  let filteredChildren = _list;
  let presentChildren = filteredChildren;
  let allChildren = /* @__PURE__ */ new Map();
  let exiting = /* @__PURE__ */ new Set();
  const updateChildLookup = (children2, allChild) => {
    children2.forEach((child) => {
      const key = getChildKey(child);
      allChild.set(key, child);
    });
  };
  let childrenToRender = [...filteredChildren.map((v) => ({ present: true, item: v, key: v.key }))];
  const writable_props = [
    "list",
    "custom",
    "initial",
    "onExitComplete",
    "exitBeforeEnter",
    "presenceAffectsLayout",
    "show",
    "isCustom"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<AnimatePresence> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("list" in $$props2) $$invalidate(6, list = $$props2.list);
    if ("custom" in $$props2) $$invalidate(0, custom = $$props2.custom);
    if ("initial" in $$props2) $$invalidate(1, initial = $$props2.initial);
    if ("onExitComplete" in $$props2) $$invalidate(7, onExitComplete = $$props2.onExitComplete);
    if ("exitBeforeEnter" in $$props2) $$invalidate(8, exitBeforeEnter = $$props2.exitBeforeEnter);
    if ("presenceAffectsLayout" in $$props2) $$invalidate(2, presenceAffectsLayout = $$props2.presenceAffectsLayout);
    if ("show" in $$props2) $$invalidate(9, show = $$props2.show);
    if ("isCustom" in $$props2) $$invalidate(3, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2) $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    SharedLayoutContext,
    isSharedLayout,
    PresenceChild: PresenceChild_default,
    list,
    custom,
    initial,
    onExitComplete,
    exitBeforeEnter,
    presenceAffectsLayout,
    show,
    isCustom,
    _list,
    layoutContext,
    getChildKey,
    isInitialRender,
    filteredChildren,
    presentChildren,
    allChildren,
    exiting,
    updateChildLookup,
    childrenToRender,
    forceRender,
    isl,
    $layoutContext
  });
  $$self.$inject_state = ($$props2) => {
    if ("list" in $$props2) $$invalidate(6, list = $$props2.list);
    if ("custom" in $$props2) $$invalidate(0, custom = $$props2.custom);
    if ("initial" in $$props2) $$invalidate(1, initial = $$props2.initial);
    if ("onExitComplete" in $$props2) $$invalidate(7, onExitComplete = $$props2.onExitComplete);
    if ("exitBeforeEnter" in $$props2) $$invalidate(8, exitBeforeEnter = $$props2.exitBeforeEnter);
    if ("presenceAffectsLayout" in $$props2) $$invalidate(2, presenceAffectsLayout = $$props2.presenceAffectsLayout);
    if ("show" in $$props2) $$invalidate(9, show = $$props2.show);
    if ("isCustom" in $$props2) $$invalidate(3, isCustom = $$props2.isCustom);
    if ("_list" in $$props2) $$invalidate(10, _list = $$props2._list);
    if ("isInitialRender" in $$props2) $$invalidate(11, isInitialRender = $$props2.isInitialRender);
    if ("filteredChildren" in $$props2) $$invalidate(12, filteredChildren = $$props2.filteredChildren);
    if ("presentChildren" in $$props2) $$invalidate(13, presentChildren = $$props2.presentChildren);
    if ("allChildren" in $$props2) $$invalidate(19, allChildren = $$props2.allChildren);
    if ("exiting" in $$props2) $$invalidate(20, exiting = $$props2.exiting);
    if ("childrenToRender" in $$props2) $$invalidate(4, childrenToRender = $$props2.childrenToRender);
    if ("forceRender" in $$props2) $$invalidate(14, forceRender = $$props2.forceRender);
    if ("isl" in $$props2) $$invalidate(15, isl = $$props2.isl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*list, show*/
    576) {
      $: $$invalidate(10, _list = list !== void 0 ? list : show ? [{ key: 1 }] : []);
    }
    if ($$self.$$.dirty & /*$layoutContext*/
    65536) {
      $: $$invalidate(15, isl = isSharedLayout($layoutContext));
    }
    if ($$self.$$.dirty & /*isl, $layoutContext, _list*/
    99328) {
      $: $$invalidate(14, forceRender = () => {
        if (isl) {
          $layoutContext.forceUpdate();
        }
        $$invalidate(10, _list = [..._list]);
      });
    }
    if ($$self.$$.dirty & /*_list*/
    1024) {
      $: $$invalidate(12, filteredChildren = _list);
    }
    if ($$self.$$.dirty & /*filteredChildren*/
    4096) {
      $: updateChildLookup(filteredChildren, allChildren);
    }
    if ($$self.$$.dirty & /*isInitialRender, filteredChildren, presentChildren, exitBeforeEnter, forceRender, onExitComplete, childrenToRender*/
    31120) {
      $: if (!isInitialRender) {
        $$invalidate(4, childrenToRender = [...filteredChildren.map((v) => ({ present: true, item: v, key: v.key }))]);
        const presentKeys = presentChildren.map(getChildKey);
        const targetKeys = filteredChildren.map(getChildKey);
        const numPresent = presentKeys.length;
        for (let i = 0; i < numPresent; i++) {
          const key = presentKeys[i];
          if (targetKeys.indexOf(key) === -1) {
            exiting.add(key);
          } else {
            exiting.delete(key);
          }
        }
        if (exitBeforeEnter && exiting.size) {
          $$invalidate(4, childrenToRender = []);
        }
        exiting.forEach((key) => {
          if (targetKeys.indexOf(key) !== -1) return;
          const child = allChildren.get(key);
          if (!child) return;
          const insertionIndex = presentKeys.indexOf(key);
          const onExit = () => {
            allChildren.delete(key);
            exiting.delete(key);
            const removeIndex = presentChildren.findIndex((presentChild) => presentChild.key === key);
            if (removeIndex < 0) {
              return;
            }
            presentChildren.splice(removeIndex, 1);
            if (!exiting.size) {
              $$invalidate(13, presentChildren = [...filteredChildren]);
              forceRender();
              onExitComplete && onExitComplete();
            }
          };
          childrenToRender.splice(insertionIndex, 0, {
            present: false,
            item: child,
            key: getChildKey(child),
            onExit
          });
        });
        $$invalidate(13, presentChildren = childrenToRender);
      } else {
        $$invalidate(11, isInitialRender = false);
      }
    }
  };
  return [
    custom,
    initial,
    presenceAffectsLayout,
    isCustom,
    childrenToRender,
    layoutContext,
    list,
    onExitComplete,
    exitBeforeEnter,
    show,
    _list,
    isInitialRender,
    filteredChildren,
    presentChildren,
    forceRender,
    isl,
    $layoutContext,
    slots,
    $$scope
  ];
}
var AnimatePresence = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      list: 6,
      custom: 0,
      initial: 1,
      onExitComplete: 7,
      exitBeforeEnter: 8,
      presenceAffectsLayout: 2,
      show: 9,
      isCustom: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnimatePresence",
      options,
      id: create_fragment31.name
    });
  }
  get list() {
    throw new Error("<AnimatePresence>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set list(value) {
    throw new Error("<AnimatePresence>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get custom() {
    throw new Error("<AnimatePresence>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set custom(value) {
    throw new Error("<AnimatePresence>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initial() {
    throw new Error("<AnimatePresence>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initial(value) {
    throw new Error("<AnimatePresence>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExitComplete() {
    throw new Error("<AnimatePresence>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExitComplete(value) {
    throw new Error("<AnimatePresence>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get exitBeforeEnter() {
    throw new Error("<AnimatePresence>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set exitBeforeEnter(value) {
    throw new Error("<AnimatePresence>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get presenceAffectsLayout() {
    throw new Error("<AnimatePresence>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set presenceAffectsLayout(value) {
    throw new Error("<AnimatePresence>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get show() {
    throw new Error("<AnimatePresence>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set show(value) {
    throw new Error("<AnimatePresence>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<AnimatePresence>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<AnimatePresence>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnimatePresence_default = AnimatePresence;

// node_modules/svelte-motion/src/animation/animate.js
function animate2(from, to, transition) {
  if (transition === void 0) {
    transition = {};
  }
  var value = isMotionValue(from) ? from : motionValue(from);
  startAnimation("", value, to, transition);
  return {
    stop: function() {
      return value.stop();
    }
  };
}

// node_modules/svelte-motion/src/components/AnimateSharedLayout/utils/crossfader.js
function createCrossfader() {
  var progress2 = motionValue(1);
  var options = {
    lead: void 0,
    follow: void 0,
    crossfadeOpacity: false,
    preserveFollowOpacity: false
  };
  var prevOptions = Object.assign({}, options);
  var leadState = {};
  var followState = {};
  var isActive = false;
  var finalCrossfadeFrame = null;
  var prevUpdate = 0;
  function startCrossfadeAnimation(target, transition) {
    var lead = options.lead, follow = options.follow;
    isActive = true;
    finalCrossfadeFrame = null;
    var hasUpdated = false;
    var onUpdate = function() {
      hasUpdated = true;
      lead && lead.scheduleRender();
      follow && follow.scheduleRender();
    };
    var onComplete = function() {
      isActive = false;
      finalCrossfadeFrame = getFrameData().timestamp;
    };
    transition = transition && getValueTransition(transition, "crossfade");
    return animate2(progress2, target, Object.assign(Object.assign({}, transition), { onUpdate, onComplete: function() {
      if (!hasUpdated) {
        progress2.set(target);
        es_default.read(onComplete);
      } else {
        onComplete();
      }
      onUpdate();
    } }));
  }
  function updateCrossfade() {
    var _a, _b;
    var timestamp = getFrameData().timestamp;
    var lead = options.lead, follow = options.follow;
    if (timestamp === prevUpdate || !lead)
      return;
    prevUpdate = timestamp;
    var latestLeadValues = lead.getLatestValues();
    Object.assign(leadState, latestLeadValues);
    var latestFollowValues = follow ? follow.getLatestValues() : options.prevValues;
    Object.assign(followState, latestFollowValues);
    var p = progress2.get();
    var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;
    var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;
    if (options.crossfadeOpacity && follow) {
      leadState.opacity = mix(
        /**
         * If the follow child has been completely hidden we animate
         * this opacity from its previous opacity, but otherwise from completely transparent.
         */
        follow.isVisible !== false ? 0 : followTargetOpacity,
        leadTargetOpacity,
        easeCrossfadeIn(p)
      );
      followState.opacity = options.preserveFollowOpacity ? followTargetOpacity : mix(followTargetOpacity, 0, easeCrossfadeOut(p));
    } else if (!follow) {
      leadState.opacity = mix(followTargetOpacity, leadTargetOpacity, p);
    }
    mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);
  }
  return {
    isActive: function() {
      return leadState && (isActive || getFrameData().timestamp === finalCrossfadeFrame);
    },
    fromLead: function(transition) {
      return startCrossfadeAnimation(0, transition);
    },
    toLead: function(transition) {
      var initialProgress = 0;
      if (!options.prevValues && !options.follow) {
        initialProgress = 1;
      } else if (prevOptions.lead === options.follow && prevOptions.follow === options.lead) {
        initialProgress = 1 - progress2.get();
      }
      progress2.set(initialProgress);
      return startCrossfadeAnimation(1, transition);
    },
    reset: function() {
      return progress2.set(1);
    },
    stop: function() {
      return progress2.stop();
    },
    getCrossfadeState: function(element2) {
      updateCrossfade();
      if (element2 === options.lead) {
        return leadState;
      } else if (element2 === options.follow) {
        return followState;
      }
    },
    setOptions: function(newOptions) {
      prevOptions = options;
      options = newOptions;
      leadState = {};
      followState = {};
    },
    getLatestValues: function() {
      return leadState;
    }
  };
}
var easeCrossfadeIn = compress(0, 0.5, circOut);
var easeCrossfadeOut = compress(0.5, 0.95, linear);
function compress(min, max, easing) {
  return function(p) {
    if (p < min)
      return 0;
    if (p > max)
      return 1;
    return easing(progress(min, max, p));
  };
}
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders.length;
function mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {
  for (var i = 0; i < numBorders; i++) {
    var borderLabel = "border" + borders[i] + "Radius";
    var followRadius = getRadius(latestFollowValues, borderLabel);
    var leadRadius = getRadius(latestLeadValues, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    if (typeof followRadius === "number" && typeof leadRadius === "number") {
      var radius = Math.max(mix(followRadius, leadRadius, p), 0);
      leadState[borderLabel] = followState[borderLabel] = radius;
    }
  }
  if (latestFollowValues.rotate || latestLeadValues.rotate) {
    var rotate = mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);
    leadState.rotate = followState.rotate = rotate;
  }
  if (!hasFollowElement && latestLeadValues.backgroundColor && latestFollowValues.backgroundColor) {
    leadState.backgroundColor = followState.backgroundColor = mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);
  }
}
function getRadius(values, radiusName) {
  var _a;
  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;
}

// node_modules/svelte-motion/src/components/AnimateSharedLayout/utils/stack.js
function layoutStack() {
  var stack = /* @__PURE__ */ new Set();
  var state = { leadIsExiting: false };
  var prevState = Object.assign({}, state);
  var prevValues;
  var prevViewportBox;
  var prevDragCursor;
  var crossfader = createCrossfader();
  var needsCrossfadeAnimation = false;
  function getFollowViewportBox() {
    return state.follow ? state.follow.prevViewportBox : prevViewportBox;
  }
  function getFollowLayout() {
    var _a;
    return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;
  }
  return {
    add: function(element2) {
      element2.setCrossfader(crossfader);
      stack.add(element2);
      if (prevDragCursor)
        element2.prevDragCursor = prevDragCursor;
      if (!state.lead)
        state.lead = element2;
    },
    remove: function(element2) {
      stack.delete(element2);
    },
    getLead: function() {
      return state.lead;
    },
    updateSnapshot: function() {
      if (!state.lead)
        return;
      prevValues = crossfader.isActive() ? crossfader.getLatestValues() : state.lead.getLatestValues();
      prevViewportBox = state.lead.prevViewportBox;
      var dragControls = elementDragControls.get(state.lead);
      if (dragControls && dragControls.isDragging) {
        prevDragCursor = dragControls.cursorProgress;
      }
    },
    clearSnapshot: function() {
      prevDragCursor = prevViewportBox = void 0;
    },
    updateLeadAndFollow: function() {
      var _a;
      prevState = Object.assign({}, state);
      var lead;
      var follow;
      var order2 = Array.from(stack);
      for (var i = order2.length; i--; i >= 0) {
        var element2 = order2[i];
        if (lead)
          follow !== null && follow !== void 0 ? follow : follow = element2;
        lead !== null && lead !== void 0 ? lead : lead = element2;
        if (lead && follow)
          break;
      }
      state.lead = lead;
      state.follow = follow;
      state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;
      crossfader.setOptions({
        lead,
        follow,
        prevValues,
        crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot)
      });
      if (
        // Don't crossfade if we've just animated back from lead and switched the
        // old follow to the new lead.
        state.lead !== prevState.follow && (prevState.lead !== state.lead || prevState.leadIsExiting !== state.leadIsExiting)
      ) {
        needsCrossfadeAnimation = true;
      }
    },
    animate: function(child, shouldCrossfade) {
      var _a;
      if (shouldCrossfade === void 0) {
        shouldCrossfade = false;
      }
      if (child === state.lead) {
        if (shouldCrossfade) {
          child.pointTo(state.lead);
        } else {
          child.setVisibility(true);
        }
        var config = {};
        var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();
        if (prevParent) {
          config.prevParent = prevParent;
        }
        if (child.presence === Presence.Entering) {
          config.originBox = getFollowViewportBox();
        } else if (child.presence === Presence.Exiting) {
          config.targetBox = getFollowLayout();
        }
        if (needsCrossfadeAnimation) {
          needsCrossfadeAnimation = false;
          var transition = child.getDefaultTransition();
          child.presence === Presence.Entering ? crossfader.toLead(transition) : crossfader.fromLead(transition);
        }
        child.notifyLayoutReady(config);
      } else {
        if (shouldCrossfade) {
          state.lead && child.pointTo(state.lead);
        } else {
          child.setVisibility(false);
        }
      }
    }
  };
}

// node_modules/svelte-motion/src/components/AnimateSharedLayout/utils/rotate.js
function resetRotate(child) {
  var hasRotate = false;
  var resetValues = {};
  for (var i = 0; i < transformAxes.length; i++) {
    var axis = transformAxes[i];
    var key = "rotate" + axis;
    if (!child.hasValue(key) || child.getStaticValue(key) === 0)
      continue;
    hasRotate = true;
    resetValues[key] = child.getStaticValue(key);
    child.setStaticValue(key, 0);
  }
  if (!hasRotate)
    return;
  child.syncRender();
  for (var key in resetValues) {
    child.setStaticValue(key, resetValues[key]);
  }
  child.scheduleRender();
}

// node_modules/svelte-motion/src/components/AnimateSharedLayout/AnimateSharedLayout.svelte
function create_fragment32(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnimateSharedLayout", slots, ["default"]);
  let { type = void 0, isCustom = false } = $$props;
  const context = getContext(MotionContext) || MotionContext(isCustom);
  let hasMounted = false;
  let children2 = /* @__PURE__ */ new Set();
  let stacks = /* @__PURE__ */ new Map();
  let updateScheduled = false;
  let renderScheduled = false;
  let forced = false;
  let syncContext = {
    ...createBatcher(),
    syncUpdate: (force) => scheduleUpdate(force),
    forceUpdate: () => {
      scheduleUpdate();
      forced = true;
    },
    register: (child) => addChild(child),
    remove: (child) => {
      removeChild(child);
    }
  };
  const startLayoutAnimation = () => {
    $$invalidate(2, renderScheduled = updateScheduled = false);
    children2.forEach((child) => {
      if (!child.isPresent) {
        child.presence = Presence.Exiting;
      } else if (child.presence !== Presence.Entering) {
        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;
      }
    });
    updateStacks();
    const handler = {
      measureLayout: (child) => child.updateLayoutMeasurement(),
      layoutReady: (child) => {
        if (child.getLayoutId() !== void 0) {
          const stack = getStack(child);
          stack.animate(child, type === "crossfade");
        } else {
          child.notifyLayoutReady();
        }
      },
      parent: get_store_value(context).visualElement
    };
    children2.forEach((child) => syncContext.add(child));
    syncContext.flush(handler);
    stacks.forEach((stack) => stack.clearSnapshot());
  };
  const updateStacks = () => {
    stacks.forEach((stack) => stack.updateLeadAndFollow());
  };
  const scheduleUpdate = (force = false) => {
    if (!(force || !updateScheduled)) return;
    updateScheduled = true;
    children2.forEach((child) => resetRotate(child));
    children2.forEach((child) => snapshotViewportBox(child));
    stacks.forEach((stack) => stack.updateSnapshot());
    if (force || !renderScheduled) {
      $$invalidate(2, renderScheduled = true);
      forced = true;
    }
  };
  const addChild = (child) => {
    children2.add(child);
    addToStack(child);
    child.presence = hasMounted ? Presence.Entering : Presence.Present;
  };
  const removeChild = (child) => {
    scheduleUpdate();
    children2.delete(child);
    removeFromStack(child);
  };
  const addToStack = (child) => {
    const stack = getStack(child);
    stack == null ? void 0 : stack.add(child);
  };
  const removeFromStack = (child) => {
    const stack = getStack(child);
    stack == null ? void 0 : stack.remove(child);
  };
  const getStack = (child) => {
    const id = child.getLayoutId();
    if (id === void 0) return;
    !stacks.has(id) && stacks.set(id, layoutStack());
    return stacks.get(id);
  };
  let sc = writable(syncContext);
  const setSyncContext = () => {
    syncContext = { ...syncContext };
    sc.set(syncContext);
  };
  setContext(SharedLayoutContext, sc);
  setDomContext("SharedLayout", isCustom, sc);
  onMount(() => {
    hasMounted = true;
  });
  const writable_props = ["type", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<AnimateSharedLayout> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2) $$invalidate(0, type = $$props2.type);
    if ("isCustom" in $$props2) $$invalidate(1, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Presence,
    createBatcher,
    SharedLayoutContext,
    layoutStack,
    resetRotate,
    getContext,
    onMount,
    setContext,
    tick,
    get: get_store_value,
    writable,
    MotionContext,
    snapshotViewportBox,
    setDomContext,
    type,
    isCustom,
    context,
    hasMounted,
    children: children2,
    stacks,
    updateScheduled,
    renderScheduled,
    forced,
    syncContext,
    startLayoutAnimation,
    updateStacks,
    scheduleUpdate,
    addChild,
    removeChild,
    addToStack,
    removeFromStack,
    getStack,
    sc,
    setSyncContext
  });
  $$self.$inject_state = ($$props2) => {
    if ("type" in $$props2) $$invalidate(0, type = $$props2.type);
    if ("isCustom" in $$props2) $$invalidate(1, isCustom = $$props2.isCustom);
    if ("hasMounted" in $$props2) hasMounted = $$props2.hasMounted;
    if ("children" in $$props2) children2 = $$props2.children;
    if ("stacks" in $$props2) stacks = $$props2.stacks;
    if ("updateScheduled" in $$props2) updateScheduled = $$props2.updateScheduled;
    if ("renderScheduled" in $$props2) $$invalidate(2, renderScheduled = $$props2.renderScheduled);
    if ("forced" in $$props2) forced = $$props2.forced;
    if ("syncContext" in $$props2) syncContext = $$props2.syncContext;
    if ("sc" in $$props2) sc = $$props2.sc;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*renderScheduled*/
    4) {
      $: if (renderScheduled) {
        tick().then(() => {
          startLayoutAnimation();
        });
      }
    }
  };
  return [type, isCustom, renderScheduled, $$scope, slots];
}
var AnimateSharedLayout = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, { type: 0, isCustom: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnimateSharedLayout",
      options,
      id: create_fragment32.name
    });
  }
  get type() {
    throw new Error("<AnimateSharedLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<AnimateSharedLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<AnimateSharedLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<AnimateSharedLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnimateSharedLayout_default = AnimateSharedLayout;

// node_modules/svelte-motion/src/value/use-combine-values.js
var useCombineMotionValues = (values, combineValues) => {
  let subscriptions = [];
  let vals = values;
  const unsubscribe = () => {
    subscriptions.forEach((unsubscribe2) => unsubscribe2());
  };
  const subscribe = () => {
    subscriptions = vals.map((val) => val.onChange(handler));
    updateValue();
  };
  const value = motionValue(combineValues(), () => {
    unsubscribe();
    subscribe();
    return unsubscribe;
  });
  let updateValue = () => {
    value.set(combineValues());
  };
  const handler = () => {
    es_default.update(updateValue, false, true);
  };
  value.reset = (_values, _combineValues) => {
    vals = _values;
    unsubscribe();
    updateValue = () => {
      value.set(_combineValues());
    };
    subscribe();
  };
  return value;
};

// node_modules/svelte-motion/src/value/use-motion-template.js
var useMotionTemplate = (fragments, ...values) => {
  let numFragments = fragments.length;
  const buildValue = () => {
    let output = ``;
    for (let i = 0; i < numFragments; i++) {
      output += fragments[i];
      const value2 = values[i];
      if (value2) output += values[i].get();
    }
    return output;
  };
  const value = useCombineMotionValues(values, buildValue);
  value.resetInner = value.reset;
  value.reset = (f, ...vs) => {
    numFragments = f.length;
    value.resetInner(vs, buildValue);
  };
  return value;
};

// node_modules/svelte-motion/src/utils/transform.js
var isCustomValueType = function(v) {
  return typeof v === "object" && v.mix;
};
var getMixer = function(v) {
  return isCustomValueType(v) ? v.mix : void 0;
};
function transform() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var useImmediate = !Array.isArray(args[0]);
  var argOffset = useImmediate ? 0 : -1;
  var inputValue = args[0 + argOffset];
  var inputRange = args[1 + argOffset];
  var outputRange = args[2 + argOffset];
  var options = args[3 + argOffset];
  var interpolator = interpolate(inputRange, outputRange, Object.assign({ mixer: getMixer(outputRange[0]) }, options));
  return useImmediate ? interpolator(inputValue) : interpolator;
}

// node_modules/svelte-motion/src/value/use-transform.js
var useTransform = (input, inputRangeOrTransformer, outputRange, options) => {
  let latest = [];
  const update = (input2, inputRangeOrTransformer2, outputRange2, options2) => {
    const transformer = typeof inputRangeOrTransformer2 === "function" ? inputRangeOrTransformer2 : transform(inputRangeOrTransformer2, outputRange2, options2);
    const values = Array.isArray(input2) ? input2 : [input2];
    const _transformer = Array.isArray(input2) ? transformer : ([latest2]) => transformer(latest2);
    return [values, () => {
      latest.length = 0;
      const numValues = values.length;
      for (let i = 0; i < numValues; i++) {
        latest[i] = values[i].get();
      }
      return _transformer(latest);
    }];
  };
  const comb = useCombineMotionValues(...update(
    input,
    inputRangeOrTransformer,
    outputRange,
    options
  ));
  comb.updateInner = comb.reset;
  comb.reset = (input2, inputRangeOrTransformer2, outputRange2, options2) => comb.updateInner(
    ...update(
      input2,
      inputRangeOrTransformer2,
      outputRange2,
      options2
    )
  );
  return comb;
};

// node_modules/svelte-motion/src/value/use-spring.js
var useSpring = (source, config = {}, isCustom = false) => {
  const mcc = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  let activeSpringAnimation = null;
  let value = motionValue(isMotionValue(source) ? source.get() : source);
  let cleanup;
  const update = (_source, _config) => {
    value.attach((v, set) => {
      const { isStatic } = get_store_value(mcc);
      if (isStatic) {
        return set(v);
      }
      if (activeSpringAnimation) {
        activeSpringAnimation.stop();
      }
      activeSpringAnimation = animate({
        from: value.get(),
        to: v,
        velocity: value.getVelocity(),
        ..._config,
        onUpdate: set
      });
      return value.get();
    });
    cleanup == null ? void 0 : cleanup();
    return isMotionValue(_source) ? _source.onChange((v) => value.set(parseFloat(v))) : void 0;
  };
  update(source, config);
  value.reset = update;
  return value;
};

// node_modules/svelte-motion/src/value/scroll/utils.js
function createScrollMotionValues(startStopNotifier) {
  const hasListener = { x: false, y: false, xp: false, yp: false };
  let stop;
  const jointNotifier = startStopNotifier ? (type) => () => {
    if (!hasListener.x && !hasListener.y && !hasListener.xp && !hasListener.yp) {
      stop = startStopNotifier();
    }
    hasListener[type] = true;
    return () => {
      hasListener[type] = false;
      if (!hasListener.x && !hasListener.y && !hasListener.xp && !hasListener.yp) {
        if (stop) {
          stop.then((v) => v());
        }
      }
    };
  } : () => () => {
  };
  const smvs = {
    scrollX: motionValue(0, jointNotifier("x")),
    scrollY: motionValue(0, jointNotifier("y")),
    scrollXProgress: motionValue(0, jointNotifier("xp")),
    scrollYProgress: motionValue(0, jointNotifier("yp"))
  };
  return smvs;
}
function setProgress(offset, maxOffset, value) {
  value.set(!offset || !maxOffset ? 0 : offset / maxOffset);
}
function createScrollUpdater(values, getOffsets) {
  var update = function() {
    var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;
    values.scrollX.set(xOffset);
    values.scrollY.set(yOffset);
    setProgress(xOffset, xMaxOffset, values.scrollXProgress);
    setProgress(yOffset, yMaxOffset, values.scrollYProgress);
  };
  update();
  return update;
}

// node_modules/svelte-motion/src/value/scroll/use-element-scroll.js
var getElementScrollOffsets = (element2) => () => {
  return {
    xOffset: element2.scrollLeft,
    yOffset: element2.scrollTop,
    xMaxOffset: element2.scrollWidth - element2.offsetWidth,
    yMaxOffset: element2.scrollHeight - element2.offsetHeight
  };
};
var useElementScroll = (ref) => {
  const values = {};
  const setScroll = async () => {
    if (typeof window === "undefined") return () => {
    };
    let times = 10;
    while ((!ref || !ref.current) && !values.ref) {
      if (times-- < 1) {
        return () => {
        };
      }
      ;
      await new Promise((r) => setTimeout(() => r(), 200));
    }
    const element2 = ref && ref.current ? ref : values.ref;
    const updateScrollValues = createScrollUpdater(
      values,
      getElementScrollOffsets(element2)
    );
    const scrollListener = addDomEvent(
      element2,
      "scroll",
      updateScrollValues,
      { passive: true }
    );
    const resizeListener = addDomEvent(
      element2,
      "resize",
      updateScrollValues
    );
    return () => {
      scrollListener && scrollListener();
      resizeListener && resizeListener();
    };
  };
  Object.assign(values, createScrollMotionValues(setScroll));
  return values;
};

// node_modules/svelte-motion/src/value/scroll/use-viewport-scroll.js
var viewportScrollValues;
function getViewportScrollOffsets() {
  return {
    xOffset: window.pageXOffset,
    yOffset: window.pageYOffset,
    xMaxOffset: document.body.clientWidth - window.innerWidth,
    yMaxOffset: document.body.clientHeight - window.innerHeight
  };
}
var hasListeners = false;
function addEventListeners() {
  hasListeners = true;
  if (typeof window === "undefined") return;
  const updateScrollValues = createScrollUpdater(
    viewportScrollValues,
    getViewportScrollOffsets
  );
  addDomEvent(window, "scroll", updateScrollValues, { passive: true });
  addDomEvent(window, "resize", updateScrollValues);
}
function useViewportScroll() {
  if (!viewportScrollValues) {
    viewportScrollValues = createScrollMotionValues();
  }
  tick().then((_) => {
    !hasListeners && addEventListeners();
  });
  return viewportScrollValues;
}

// node_modules/svelte-motion/src/utils/use-reduced-motion.js
var prefersReducedMotion;
function initPrefersReducedMotion() {
  prefersReducedMotion = motionValue(null);
  if (typeof window === "undefined") return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia(
      "(prefers-reduced-motion)"
    );
    const setReducedMotionPreferences = () => prefersReducedMotion.set(motionMediaQuery.matches);
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.set(false);
  }
}
var useReducedMotion = () => {
  !prefersReducedMotion && initPrefersReducedMotion();
  return derived(prefersReducedMotion, ($v) => $v);
};

// node_modules/svelte-motion/src/animation/UseAnimation.svelte
var get_default_slot_changes13 = (dirty) => ({});
var get_default_slot_context13 = (ctx) => ({ controls: (
  /*controls*/
  ctx[0]
) });
function create_fragment33(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_default_slot_context13
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_default_slot_changes13
            ),
            get_default_slot_context13
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseAnimation", slots, ["default"]);
  let controls = animationControls();
  onMount(controls.mount);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<UseAnimation> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ onMount, animationControls, controls });
  $$self.$inject_state = ($$props2) => {
    if ("controls" in $$props2) $$invalidate(0, controls = $$props2.controls);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [controls, $$scope, slots];
}
var UseAnimation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseAnimation",
      options,
      id: create_fragment33.name
    });
  }
};
var UseAnimation_default = UseAnimation;

// node_modules/svelte-motion/src/animation/use-animation.js
var useAnimation = () => {
  const controls = animationControls(() => {
    const cleanup = {};
    tick().then((v) => cleanup.clean = controls.mount());
    return () => {
      var _a;
      (_a = cleanup.clean) == null ? void 0 : _a.call(cleanup);
    };
  });
  return controls;
};

// node_modules/svelte-motion/src/utils/use-cycle.js
var useCycle = (...items) => {
  let index = 0;
  const x = writable(items[index]);
  const next = (i) => {
    index = typeof i !== "number" ? wrap(0, items.length, index + 1) : i;
    x.set(items[index]);
  };
  x.next = next;
  return x;
};

// node_modules/svelte-motion/src/gestures/drag/use-drag-controls.js
var DragControls = (
  /** @class */
  function() {
    function DragControls2() {
      this.componentControls = /* @__PURE__ */ new Set();
    }
    DragControls2.prototype.subscribe = function(controls) {
      var _this = this;
      this.componentControls.add(controls);
      return function() {
        return _this.componentControls.delete(controls);
      };
    };
    DragControls2.prototype.start = function(event, options) {
      this.componentControls.forEach(function(controls) {
        controls.start(event.nativeEvent || event, options);
      });
    };
    DragControls2.prototype.updateConstraints = function() {
      this.componentControls.forEach(function(controls) {
        controls.prepareBoundingBox();
        controls.resolveDragConstraints();
      });
    };
    return DragControls2;
  }()
);
var createDragControls = function() {
  return new DragControls();
};
var useDragControls = createDragControls;

// node_modules/svelte-motion/src/value/use-velocity.js
var useVelocity = (value) => {
  let val = value;
  let cleanup;
  const velocity = motionValue(value.getVelocity(), () => {
    cleanup == null ? void 0 : cleanup();
    cleanup = val.velocityUpdateSubscribers.add((newVelocity) => {
      velocity.set(newVelocity);
    });
    return () => {
      cleanup == null ? void 0 : cleanup();
    };
  });
  const reset = (valu) => {
    cleanup == null ? void 0 : cleanup();
    val = valu;
    cleanup = val.velocityUpdateSubscribers.add((newVelocity) => {
      velocity.set(newVelocity);
    });
  };
  velocity.reset = reset;
  return velocity;
};

// node_modules/svelte-motion/src/components/MotionDiv.svelte
var file2 = "node_modules/svelte-motion/src/components/MotionDiv.svelte";
function create_default_slot12(ctx) {
  let div_1;
  let m_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_1_levels = [
    /*props*/
    ctx[5],
    /*div*/
    ctx[0]
  ];
  let div_data = {};
  for (let i = 0; i < div_1_levels.length; i += 1) {
    div_data = assign(div_data, div_1_levels[i]);
  }
  const block = {
    c: function create() {
      div_1 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div_1 = claim_element(nodes, "DIV", {});
      var div_1_nodes = children(div_1);
      if (default_slot) default_slot.l(div_1_nodes);
      div_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div_1, div_data);
      add_location(div_1, file2, 6, 1, 150);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div_1, anchor);
      if (default_slot) {
        default_slot.m(div_1, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(m_action = /*m*/
        ctx[4].call(null, div_1));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div_1, div_data = get_spread_update(div_1_levels, [
        dirty & /*props*/
        32 && /*props*/
        ctx2[5],
        dirty & /*div*/
        1 && /*div*/
        ctx2[0]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div_1);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(6:0) <Motion {...$$restProps} let:motion={m} let:props>",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let motion2;
  let current;
  const motion_spread_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let motion_props = {
    $$slots: {
      default: [
        create_default_slot12,
        ({ motion: m, props }) => ({ 4: m, 5: props }),
        ({ motion: m, props }) => (m ? 16 : 0) | (props ? 32 : 0)
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < motion_spread_levels.length; i += 1) {
    motion_props = assign(motion_props, motion_spread_levels[i]);
  }
  motion2 = new MotionSSR_default({ props: motion_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(motion2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(motion2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(motion2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const motion_changes = dirty & /*$$restProps*/
      2 ? get_spread_update(motion_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[1]
      )]) : {};
      if (dirty & /*$$scope, props, div*/
      41) {
        motion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      motion2.$set(motion_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(motion2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(motion2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(motion2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  const omit_props_names = ["div"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MotionDiv", slots, ["default"]);
  let { div = {} } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("div" in $$new_props) $$invalidate(0, div = $$new_props.div);
    if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Motion: MotionSSR_default, div });
  $$self.$inject_state = ($$new_props) => {
    if ("div" in $$props) $$invalidate(0, div = $$new_props.div);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [div, $$restProps, slots, $$scope];
}
var MotionDiv = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, { div: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MotionDiv",
      options,
      id: create_fragment34.name
    });
  }
  get div() {
    throw new Error("<MotionDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set div(value) {
    throw new Error("<MotionDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MotionDiv_default = MotionDiv;
export {
  AnimatePresence_default as AnimatePresence,
  AnimateSharedLayout_default as AnimateSharedLayout,
  DragControls,
  FramerTreeLayoutContext,
  LayoutGroupContext,
  M2 as M,
  MotionDiv_default as Mdiv,
  motion as Motion,
  MotionConfig_default as MotionConfig,
  MotionConfigContext,
  MotionDiv_default as MotionDiv,
  MotionSSR_default as MotionSSR,
  MotionValue,
  PresenceContext,
  SharedLayoutContext,
  UseAnimation_default as UseAnimation,
  UseDomEvent_default as UseDomEvent,
  UseGestures_default as UseGestures,
  UsePanGesture_default as UsePanGesture,
  UseTapGesture_default as UseTapGesture,
  VisibilityAction2 as VisibilityAction,
  addScaleCorrection,
  animate2 as animate,
  animateVisualElement,
  animationControls,
  createBatcher,
  createCrossfader,
  createMotionComponent,
  isValidMotionProp,
  motionValue,
  resolveMotionValue,
  transform,
  useAnimation,
  useCycle,
  useDragControls,
  useElementScroll,
  useIsPresent,
  useMotionTemplate,
  motionValue as useMotionValue,
  usePresence,
  useReducedMotion,
  useSpring,
  useTransform,
  useVelocity,
  useViewportScroll,
  visualElement
};
//# sourceMappingURL=svelte-motion.js.map
