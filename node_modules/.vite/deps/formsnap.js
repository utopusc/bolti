import "./chunk-SA3VOP2B.js";
import {
  writable
} from "./chunk-PCTSVBTO.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  assign,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  group_outros,
  hasContext,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_maybe_contenteditable_dev,
  subscribe,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-L3FAA3FO.js";
import "./chunk-EKIRE5YT.js";
import "./chunk-MTI3AIJG.js";

// node_modules/formsnap/dist/context.js
var FORM_FIELD = Symbol("FORM_FIELD_CTX");
function setFormField(props) {
  setContext(FORM_FIELD, props);
  return props;
}
function getFormField() {
  if (!hasContext(FORM_FIELD)) {
    ctxError("Form.Field");
  }
  return getContext(FORM_FIELD);
}
var FORM_CONTROL = Symbol("FORM_CONTROL_CTX");
function setFormControl(props) {
  setContext(FORM_CONTROL, props);
  return props;
}
function getFormControl() {
  if (!hasContext(FORM_CONTROL)) {
    ctxError("<Control />");
  }
  return getContext(FORM_CONTROL);
}
function ctxError(ctx) {
  throw new Error(`Unable to find \`${ctx}\` context. Did you forget to wrap the component in a \`${ctx}\`?`);
}

// node_modules/formsnap/dist/internal/utils/attributes.js
function getAriaDescribedBy({ fieldErrorsId = void 0, descriptionId = void 0, errors }) {
  let describedBy = "";
  if (descriptionId) {
    describedBy += descriptionId + " ";
  }
  if (errors.length && fieldErrorsId) {
    describedBy += fieldErrorsId;
  }
  return describedBy ? describedBy.trim() : void 0;
}
function getAriaRequired(constraints) {
  if (!("required" in constraints))
    return void 0;
  return constraints.required ? "true" : void 0;
}
function getAriaInvalid(errors) {
  return errors && errors.length ? "true" : void 0;
}
function getDataFsError(errors) {
  return errors && errors.length ? "" : void 0;
}

// node_modules/formsnap/node_modules/nanoid/non-secure/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var nanoid = (size = 21) => {
  let id = "";
  let i = size;
  while (i--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};

// node_modules/formsnap/dist/internal/utils/id.js
function generateId() {
  return nanoid(5);
}

// node_modules/formsnap/dist/internal/utils/errors.js
function extractErrorArray(errors) {
  if (Array.isArray(errors))
    return errors;
  if (typeof errors === "object" && "_errors" in errors) {
    if (errors._errors !== void 0)
      return errors._errors;
  }
  return [];
}

// node_modules/formsnap/dist/components/description.svelte
var file = "node_modules/formsnap/dist/components/description.svelte";
var get_default_slot_changes_1 = (dirty) => ({
  descriptionAttrs: dirty & /*descriptionAttrs*/
  4
});
var get_default_slot_context_1 = (ctx) => ({
  descriptionAttrs: (
    /*descriptionAttrs*/
    ctx[2]
  )
});
var get_default_slot_changes = (dirty) => ({
  descriptionAttrs: dirty & /*descriptionAttrs*/
  4
});
var get_default_slot_context = (ctx) => ({
  descriptionAttrs: (
    /*descriptionAttrs*/
    ctx[2]
  )
});
function create_else_block(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_1
  );
  let div_levels = [
    /*descriptionAttrs*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 35, 1, 1151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[10](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, descriptionAttrs*/
        260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_1
            ),
            get_default_slot_context_1
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*descriptionAttrs*/
      4 && /*descriptionAttrs*/
      ctx2[2]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[10](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(35:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, descriptionAttrs*/
        260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(33:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let descriptionAttrs;
  const omit_props_names = ["id", "asChild", "el"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $errors;
  let $descriptionId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Description", slots, ["default"]);
  const { descriptionId, errors } = getFormField();
  validate_store(descriptionId, "descriptionId");
  component_subscribe($$self, descriptionId, (value) => $$invalidate(7, $descriptionId = value));
  validate_store(errors, "errors");
  component_subscribe($$self, errors, (value) => $$invalidate(6, $errors = value));
  let { id = generateId() } = $$props;
  let { asChild = false } = $$props;
  let { el = void 0 } = $$props;
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("el" in $$new_props) $$invalidate(0, el = $$new_props.el);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getFormField,
    getDataFsError,
    generateId,
    descriptionId,
    errors,
    id,
    asChild,
    el,
    descriptionAttrs,
    $errors,
    $descriptionId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
    if ("descriptionAttrs" in $$props) $$invalidate(2, descriptionAttrs = $$new_props.descriptionAttrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    32) {
      $: descriptionId.set(id);
    }
    $: $$invalidate(2, descriptionAttrs = {
      id: $descriptionId,
      "data-fs-error": getDataFsError($errors),
      "data-fs-description": "",
      ...$$restProps
    });
  };
  return [
    el,
    asChild,
    descriptionAttrs,
    descriptionId,
    errors,
    id,
    $errors,
    $descriptionId,
    $$scope,
    slots,
    div_binding
  ];
}
var Description = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { id: 5, asChild: 1, el: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Description",
      options,
      id: create_fragment.name
    });
  }
  get id() {
    throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get el() {
    throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set el(value) {
    throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var description_default = Description;

// node_modules/formsnap/dist/internal/utils/path.js
function getValueAtPath(path, obj) {
  const keys = path.split(/[[\].]/).filter(Boolean);
  let value = obj;
  for (const key of keys) {
    if (typeof value !== "object" || value === null) {
      return void 0;
    }
    value = value[key];
  }
  return value;
}

// node_modules/formsnap/dist/components/field.svelte
var get_default_slot_changes2 = (dirty) => ({
  value: dirty & /*$formData, name*/
  65,
  errors: dirty & /*$errors*/
  128,
  tainted: dirty & /*$tainted*/
  256,
  constraints: dirty & /*$formConstraints, name*/
  3
});
var get_default_slot_context2 = (ctx) => ({
  value: (
    /*$formData*/
    ctx[6][
      /*name*/
      ctx[0]
    ]
  ),
  errors: (
    /*$errors*/
    ctx[7]
  ),
  tainted: (
    /*$tainted*/
    ctx[8]
  ),
  constraints: (
    /*$formConstraints*/
    ctx[1][
      /*name*/
      ctx[0]
    ]
  )
});
function create_fragment2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $formData, name, $errors, $tainted, $formConstraints*/
        16835)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let formErrors;
  let formConstraints;
  let formTainted;
  let formData;
  let $formTainted, $$unsubscribe_formTainted = noop, $$subscribe_formTainted = () => ($$unsubscribe_formTainted(), $$unsubscribe_formTainted = subscribe(formTainted, ($$value) => $$invalidate(12, $formTainted = $$value)), formTainted);
  let $formConstraints, $$unsubscribe_formConstraints = noop, $$subscribe_formConstraints = () => ($$unsubscribe_formConstraints(), $$unsubscribe_formConstraints = subscribe(formConstraints, ($$value) => $$invalidate(1, $formConstraints = $$value)), formConstraints);
  let $formErrors, $$unsubscribe_formErrors = noop, $$subscribe_formErrors = () => ($$unsubscribe_formErrors(), $$unsubscribe_formErrors = subscribe(formErrors, ($$value) => $$invalidate(13, $formErrors = $$value)), formErrors);
  let $formData, $$unsubscribe_formData = noop, $$subscribe_formData = () => ($$unsubscribe_formData(), $$unsubscribe_formData = subscribe(formData, ($$value) => $$invalidate(6, $formData = $$value)), formData);
  let $errors;
  let $tainted;
  $$self.$$.on_destroy.push(() => $$unsubscribe_formTainted());
  $$self.$$.on_destroy.push(() => $$unsubscribe_formConstraints());
  $$self.$$.on_destroy.push(() => $$unsubscribe_formErrors());
  $$self.$$.on_destroy.push(() => $$unsubscribe_formData());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Field", slots, ["default"]);
  let { form } = $$props;
  let { name } = $$props;
  const field = {
    name: writable(name),
    errors: writable([]),
    constraints: writable({}),
    tainted: writable(false),
    fieldErrorsId: writable(),
    descriptionId: writable(),
    form
  };
  const { tainted, errors } = field;
  validate_store(tainted, "tainted");
  component_subscribe($$self, tainted, (value) => $$invalidate(8, $tainted = value));
  validate_store(errors, "errors");
  component_subscribe($$self, errors, (value) => $$invalidate(7, $errors = value));
  setFormField(field);
  $$self.$$.on_mount.push(function() {
    if (form === void 0 && !("form" in $$props || $$self.$$.bound[$$self.$$.props["form"]])) {
      console.warn("<Field> was created without expected prop 'form'");
    }
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<Field> was created without expected prop 'name'");
    }
  });
  const writable_props = ["form", "name"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Field> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("form" in $$props2) $$invalidate(11, form = $$props2.form);
    if ("name" in $$props2) $$invalidate(0, name = $$props2.name);
    if ("$$scope" in $$props2) $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getValueAtPath,
    setFormField,
    writable,
    extractErrorArray,
    form,
    name,
    field,
    tainted,
    errors,
    formData,
    formTainted,
    formConstraints,
    formErrors,
    $formTainted,
    $formConstraints,
    $formErrors,
    $formData,
    $errors,
    $tainted
  });
  $$self.$inject_state = ($$props2) => {
    if ("form" in $$props2) $$invalidate(11, form = $$props2.form);
    if ("name" in $$props2) $$invalidate(0, name = $$props2.name);
    if ("formData" in $$props2) $$subscribe_formData($$invalidate(2, formData = $$props2.formData));
    if ("formTainted" in $$props2) $$subscribe_formTainted($$invalidate(3, formTainted = $$props2.formTainted));
    if ("formConstraints" in $$props2) $$subscribe_formConstraints($$invalidate(4, formConstraints = $$props2.formConstraints));
    if ("formErrors" in $$props2) $$subscribe_formErrors($$invalidate(5, formErrors = $$props2.formErrors));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*form*/
    2048) {
      $: $$subscribe_formErrors($$invalidate(5, { errors: formErrors, constraints: formConstraints, tainted: formTainted, form: formData } = form, formErrors, $$subscribe_formConstraints($$invalidate(4, formConstraints)), $$subscribe_formTainted($$invalidate(3, formTainted)), $$subscribe_formData($$invalidate(2, formData))));
    }
    if ($$self.$$.dirty & /*name*/
    1) {
      $: field.name.set(name);
    }
    if ($$self.$$.dirty & /*name, $formErrors*/
    8193) {
      $: field.errors.set(extractErrorArray(getValueAtPath(name, $formErrors)));
    }
    if ($$self.$$.dirty & /*name, $formConstraints*/
    3) {
      $: field.constraints.set(getValueAtPath(name, $formConstraints) ?? {});
    }
    if ($$self.$$.dirty & /*$formTainted, name*/
    4097) {
      $: field.tainted.set($formTainted ? getValueAtPath(name, $formTainted) === true : false);
    }
  };
  return [
    name,
    $formConstraints,
    formData,
    formTainted,
    formConstraints,
    formErrors,
    $formData,
    $errors,
    $tainted,
    tainted,
    errors,
    form,
    $formTainted,
    $formErrors,
    $$scope,
    slots
  ];
}
var Field = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { form: 11, name: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Field",
      options,
      id: create_fragment2.name
    });
  }
  get form() {
    throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set form(value) {
    throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var field_default = Field;

// node_modules/formsnap/dist/components/control.svelte
var get_default_slot_changes3 = (dirty) => ({ attrs: dirty & /*attrs*/
1 });
var get_default_slot_context3 = (ctx) => ({ attrs: (
  /*attrs*/
  ctx[0]
) });
function create_fragment3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context3
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, attrs*/
        65537)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let errorAttr;
  let attrs;
  let labelAttrs;
  let $idStore;
  let $constraints;
  let $errors;
  let $descriptionId;
  let $fieldErrorsId;
  let $name;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Control", slots, ["default"]);
  let { id = generateId() } = $$props;
  const { name, fieldErrorsId, descriptionId, errors, constraints } = getFormField();
  validate_store(name, "name");
  component_subscribe($$self, name, (value) => $$invalidate(15, $name = value));
  validate_store(fieldErrorsId, "fieldErrorsId");
  component_subscribe($$self, fieldErrorsId, (value) => $$invalidate(14, $fieldErrorsId = value));
  validate_store(descriptionId, "descriptionId");
  component_subscribe($$self, descriptionId, (value) => $$invalidate(13, $descriptionId = value));
  validate_store(errors, "errors");
  component_subscribe($$self, errors, (value) => $$invalidate(12, $errors = value));
  validate_store(constraints, "constraints");
  component_subscribe($$self, constraints, (value) => $$invalidate(11, $constraints = value));
  const controlContext = {
    id: writable(id),
    attrs: writable(),
    labelAttrs: writable()
  };
  const { id: idStore } = controlContext;
  validate_store(idStore, "idStore");
  component_subscribe($$self, idStore, (value) => $$invalidate(10, $idStore = value));
  setFormControl(controlContext);
  const writable_props = ["id"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Control> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(7, id = $$props2.id);
    if ("$$scope" in $$props2) $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getFormField,
    setFormControl,
    getAriaDescribedBy,
    getAriaRequired,
    getDataFsError,
    generateId,
    getAriaInvalid,
    writable,
    id,
    name,
    fieldErrorsId,
    descriptionId,
    errors,
    constraints,
    controlContext,
    idStore,
    labelAttrs,
    attrs,
    errorAttr,
    $idStore,
    $constraints,
    $errors,
    $descriptionId,
    $fieldErrorsId,
    $name
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(7, id = $$props2.id);
    if ("labelAttrs" in $$props2) $$invalidate(8, labelAttrs = $$props2.labelAttrs);
    if ("attrs" in $$props2) $$invalidate(0, attrs = $$props2.attrs);
    if ("errorAttr" in $$props2) $$invalidate(9, errorAttr = $$props2.errorAttr);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    128) {
      $: controlContext.id.set(id);
    }
    if ($$self.$$.dirty & /*$errors*/
    4096) {
      $: $$invalidate(9, errorAttr = getDataFsError($errors));
    }
    if ($$self.$$.dirty & /*$name, $idStore, errorAttr, $fieldErrorsId, $descriptionId, $errors, $constraints*/
    65024) {
      $: $$invalidate(0, attrs = {
        name: $name,
        id: $idStore,
        "data-fs-error": errorAttr,
        "aria-describedby": getAriaDescribedBy({
          fieldErrorsId: $fieldErrorsId,
          descriptionId: $descriptionId,
          errors: $errors
        }),
        "aria-invalid": getAriaInvalid($errors),
        "aria-required": getAriaRequired($constraints),
        "data-fs-control": ""
      });
    }
    if ($$self.$$.dirty & /*$idStore, errorAttr*/
    1536) {
      $: $$invalidate(8, labelAttrs = {
        for: $idStore,
        "data-fs-label": "",
        "data-fs-error": errorAttr
      });
    }
    if ($$self.$$.dirty & /*attrs*/
    1) {
      $: controlContext.attrs.set(attrs);
    }
    if ($$self.$$.dirty & /*labelAttrs*/
    256) {
      $: controlContext.labelAttrs.set(labelAttrs);
    }
  };
  return [
    attrs,
    name,
    fieldErrorsId,
    descriptionId,
    errors,
    constraints,
    idStore,
    id,
    labelAttrs,
    errorAttr,
    $idStore,
    $constraints,
    $errors,
    $descriptionId,
    $fieldErrorsId,
    $name,
    $$scope,
    slots
  ];
}
var Control = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { id: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Control",
      options,
      id: create_fragment3.name
    });
  }
  get id() {
    throw new Error("<Control>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Control>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var control_default = Control;

// node_modules/formsnap/dist/components/label.svelte
var file2 = "node_modules/formsnap/dist/components/label.svelte";
var get_default_slot_changes_12 = (dirty) => ({
  labelAttrs: dirty & /*localLabelAttrs*/
  4
});
var get_default_slot_context_12 = (ctx) => ({ labelAttrs: (
  /*localLabelAttrs*/
  ctx[2]
) });
var get_default_slot_changes4 = (dirty) => ({
  labelAttrs: dirty & /*localLabelAttrs*/
  4
});
var get_default_slot_context4 = (ctx) => ({ labelAttrs: (
  /*localLabelAttrs*/
  ctx[2]
) });
function create_else_block2(ctx) {
  let label;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context_12
  );
  let label_levels = [
    /*localLabelAttrs*/
    ctx[2]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", {});
      var label_nodes = children(label);
      if (default_slot) default_slot.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(label, label_data);
      add_location(label, file2, 35, 1, 1010);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      ctx[7](label);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, localLabelAttrs*/
        36)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes_12
            ),
            get_default_slot_context_12
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [dirty & /*localLabelAttrs*/
      4 && /*localLabelAttrs*/
      ctx2[2]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[7](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(35:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context4
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, localLabelAttrs*/
        36)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes4
            ),
            get_default_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(33:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let localLabelAttrs;
  const omit_props_names = ["asChild", "el"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $labelAttrsStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, ["default"]);
  let { asChild = false } = $$props;
  let { el = void 0 } = $$props;
  const { labelAttrs: labelAttrsStore } = getFormControl();
  validate_store(labelAttrsStore, "labelAttrsStore");
  component_subscribe($$self, labelAttrsStore, (value) => $$invalidate(4, $labelAttrsStore = value));
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("el" in $$new_props) $$invalidate(0, el = $$new_props.el);
    if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getFormControl,
    asChild,
    el,
    labelAttrsStore,
    localLabelAttrs,
    $labelAttrsStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
    if ("localLabelAttrs" in $$props) $$invalidate(2, localLabelAttrs = $$new_props.localLabelAttrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(2, localLabelAttrs = { ...$labelAttrsStore, ...$$restProps });
  };
  return [
    el,
    asChild,
    localLabelAttrs,
    labelAttrsStore,
    $labelAttrsStore,
    $$scope,
    slots,
    label_binding
  ];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { asChild: 1, el: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment4.name
    });
  }
  get asChild() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get el() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set el(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var label_default = Label;

// node_modules/formsnap/dist/components/field-errors.svelte
var file3 = "node_modules/formsnap/dist/components/field-errors.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
var get_default_slot_changes_13 = (dirty) => ({
  errors: dirty & /*$errors*/
  4,
  fieldErrorsAttrs: dirty & /*fieldErrorsAttrs*/
  16,
  errorAttrs: dirty & /*errorAttrs*/
  8
});
var get_default_slot_context_13 = (ctx) => ({
  errors: (
    /*$errors*/
    ctx[2]
  ),
  fieldErrorsAttrs: (
    /*fieldErrorsAttrs*/
    ctx[4]
  ),
  errorAttrs: (
    /*errorAttrs*/
    ctx[3]
  )
});
var get_default_slot_changes5 = (dirty) => ({
  errors: dirty & /*$errors*/
  4,
  fieldErrorsAttrs: dirty & /*fieldErrorsAttrs*/
  16,
  errorAttrs: dirty & /*errorAttrs*/
  8
});
var get_default_slot_context5 = (ctx) => ({
  errors: (
    /*$errors*/
    ctx[2]
  ),
  fieldErrorsAttrs: (
    /*fieldErrorsAttrs*/
    ctx[4]
  ),
  errorAttrs: (
    /*errorAttrs*/
    ctx[3]
  )
});
function create_else_block3(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context_13
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  let div_levels = [
    /*fieldErrorsAttrs*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot_or_fallback) default_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file3, 45, 1, 1625);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      ctx[12](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $errors, fieldErrorsAttrs, errorAttrs*/
        1052)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes_13
            ),
            get_default_slot_context_13
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*$errors, errorAttrs*/
        12)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*fieldErrorsAttrs*/
      16 && /*fieldErrorsAttrs*/
      ctx2[4]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      ctx[12](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(45:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context5
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $errors, fieldErrorsAttrs, errorAttrs*/
        1052)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes5
            ),
            get_default_slot_context5
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(43:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let div;
  let t_value = (
    /*error*/
    ctx[14] + ""
  );
  let t;
  let div_levels = [
    /*errorAttrs*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file3, 48, 4, 1758);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$errors*/
      4 && t_value !== (t_value = /*error*/
      ctx2[14] + "")) set_data_maybe_contenteditable_dev(t, t_value, div_data["contenteditable"]);
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*errorAttrs*/
      8 && /*errorAttrs*/
      ctx2[3]]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(48:3) {#each $errors as error}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like_dev(
    /*$errors*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*errorAttrs, $errors*/
      12) {
        each_value = ensure_array_like_dev(
          /*$errors*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(47:57)     ",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let errorAttr;
  let fieldErrorsAttrs;
  let errorAttrs;
  const omit_props_names = ["id", "asChild", "el"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $fieldErrorsId;
  let $errors;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Field_errors", slots, ["default"]);
  const { fieldErrorsId, errors } = getFormField();
  validate_store(fieldErrorsId, "fieldErrorsId");
  component_subscribe($$self, fieldErrorsId, (value) => $$invalidate(9, $fieldErrorsId = value));
  validate_store(errors, "errors");
  component_subscribe($$self, errors, (value) => $$invalidate(2, $errors = value));
  let { id = generateId() } = $$props;
  let { asChild = false } = $$props;
  let { el = void 0 } = $$props;
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("el" in $$new_props) $$invalidate(0, el = $$new_props.el);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getFormField,
    getDataFsError,
    generateId,
    fieldErrorsId,
    errors,
    id,
    asChild,
    el,
    errorAttr,
    errorAttrs,
    fieldErrorsAttrs,
    $fieldErrorsId,
    $errors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props) $$invalidate(7, id = $$new_props.id);
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
    if ("errorAttr" in $$props) $$invalidate(8, errorAttr = $$new_props.errorAttr);
    if ("errorAttrs" in $$props) $$invalidate(3, errorAttrs = $$new_props.errorAttrs);
    if ("fieldErrorsAttrs" in $$props) $$invalidate(4, fieldErrorsAttrs = $$new_props.fieldErrorsAttrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$errors*/
    4) {
      $: $$invalidate(8, errorAttr = getDataFsError($errors));
    }
    if ($$self.$$.dirty & /*id*/
    128) {
      $: fieldErrorsId.set(id);
    }
    $: $$invalidate(4, fieldErrorsAttrs = {
      id: $fieldErrorsId,
      "data-fs-error": errorAttr,
      "data-fs-field-errors": "",
      "aria-live": "assertive",
      ...$$restProps
    });
    if ($$self.$$.dirty & /*errorAttr*/
    256) {
      $: $$invalidate(3, errorAttrs = {
        "data-fs-field-error": "",
        "data-fs-error": errorAttr
      });
    }
  };
  return [
    el,
    asChild,
    $errors,
    errorAttrs,
    fieldErrorsAttrs,
    fieldErrorsId,
    errors,
    id,
    errorAttr,
    $fieldErrorsId,
    $$scope,
    slots,
    div_binding
  ];
}
var Field_errors = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { id: 7, asChild: 1, el: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Field_errors",
      options,
      id: create_fragment5.name
    });
  }
  get id() {
    throw new Error("<Field_errors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Field_errors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Field_errors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Field_errors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get el() {
    throw new Error("<Field_errors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set el(value) {
    throw new Error("<Field_errors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var field_errors_default = Field_errors;

// node_modules/formsnap/dist/components/fieldset.svelte
var file4 = "node_modules/formsnap/dist/components/fieldset.svelte";
var get_default_slot_changes_14 = (dirty) => ({
  fieldsetAttrs: dirty & /*fieldsetAttrs*/
  16,
  value: dirty & /*value*/
  512,
  errors: dirty & /*errors*/
  1024,
  tainted: dirty & /*tainted*/
  2048,
  constraints: dirty & /*constraints*/
  4096
});
var get_default_slot_context_14 = (ctx) => ({
  fieldsetAttrs: (
    /*fieldsetAttrs*/
    ctx[4]
  ),
  value: (
    /*value*/
    ctx[9]
  ),
  errors: (
    /*errors*/
    ctx[10]
  ),
  tainted: (
    /*tainted*/
    ctx[11]
  ),
  constraints: (
    /*constraints*/
    ctx[12]
  )
});
var get_default_slot_changes6 = (dirty) => ({
  fieldsetAttrs: dirty & /*fieldsetAttrs*/
  16,
  value: dirty & /*value*/
  512,
  errors: dirty & /*errors*/
  1024,
  tainted: dirty & /*tainted*/
  2048,
  constraints: dirty & /*constraints*/
  4096
});
var get_default_slot_context6 = (ctx) => ({
  fieldsetAttrs: (
    /*fieldsetAttrs*/
    ctx[4]
  ),
  value: (
    /*value*/
    ctx[9]
  ),
  errors: (
    /*errors*/
    ctx[10]
  ),
  tainted: (
    /*tainted*/
    ctx[11]
  ),
  constraints: (
    /*constraints*/
    ctx[12]
  )
});
function create_else_block4(ctx) {
  let fieldset;
  let fieldset_data_fs_error_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_14
  );
  let fieldset_levels = [
    /*fieldsetAttrs*/
    ctx[4],
    {
      "data-fs-error": fieldset_data_fs_error_value = getDataFsError(
        /*errors*/
        ctx[10]
      )
    }
  ];
  let fieldset_data = {};
  for (let i = 0; i < fieldset_levels.length; i += 1) {
    fieldset_data = assign(fieldset_data, fieldset_levels[i]);
  }
  const block = {
    c: function create() {
      fieldset = element("fieldset");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      fieldset = claim_element(nodes, "FIELDSET", { "data-fs-error": true });
      var fieldset_nodes = children(fieldset);
      if (default_slot) default_slot.l(fieldset_nodes);
      fieldset_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(fieldset, fieldset_data);
      add_location(fieldset, file4, 39, 2, 1397);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, fieldset, anchor);
      if (default_slot) {
        default_slot.m(fieldset, null);
      }
      ctx[6](fieldset);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, fieldsetAttrs, value, errors, tainted, constraints*/
        7824)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_14
            ),
            get_default_slot_context_14
          );
        }
      }
      set_attributes(fieldset, fieldset_data = get_spread_update(fieldset_levels, [
        dirty & /*fieldsetAttrs*/
        16 && /*fieldsetAttrs*/
        ctx2[4],
        (!current || dirty & /*errors*/
        1024 && fieldset_data_fs_error_value !== (fieldset_data_fs_error_value = getDataFsError(
          /*errors*/
          ctx2[10]
        ))) && {
          "data-fs-error": fieldset_data_fs_error_value
        }
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(fieldset);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[6](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(39:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context6
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, fieldsetAttrs, value, errors, tainted, constraints*/
        7824)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes6
            ),
            get_default_slot_context6
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(37:1) {#if asChild}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block4, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[3]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(36:0) <Field {form} {name} let:value let:errors let:tainted let:constraints>",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let field;
  let current;
  field = new field_default({
    props: {
      form: (
        /*form*/
        ctx[1]
      ),
      name: (
        /*name*/
        ctx[2]
      ),
      $$slots: {
        default: [
          create_default_slot,
          ({ value, errors, tainted, constraints }) => ({
            9: value,
            10: errors,
            11: tainted,
            12: constraints
          }),
          ({ value, errors, tainted, constraints }) => (value ? 512 : 0) | (errors ? 1024 : 0) | (tainted ? 2048 : 0) | (constraints ? 4096 : 0)
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(field.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(field.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(field, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const field_changes = {};
      if (dirty & /*form*/
      2) field_changes.form = /*form*/
      ctx2[1];
      if (dirty & /*name*/
      4) field_changes.name = /*name*/
      ctx2[2];
      if (dirty & /*$$scope, fieldsetAttrs, value, errors, tainted, constraints, asChild, el*/
      7833) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(field.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(field.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(field, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let fieldsetAttrs;
  const omit_props_names = ["form", "name", "asChild", "el"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fieldset", slots, ["default"]);
  let { form } = $$props;
  let { name } = $$props;
  let { asChild = false } = $$props;
  let { el = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (form === void 0 && !("form" in $$props || $$self.$$.bound[$$self.$$.props["form"]])) {
      console.warn("<Fieldset> was created without expected prop 'form'");
    }
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<Fieldset> was created without expected prop 'name'");
    }
  });
  function fieldset_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("form" in $$new_props) $$invalidate(1, form = $$new_props.form);
    if ("name" in $$new_props) $$invalidate(2, name = $$new_props.name);
    if ("asChild" in $$new_props) $$invalidate(3, asChild = $$new_props.asChild);
    if ("el" in $$new_props) $$invalidate(0, el = $$new_props.el);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getDataFsError,
    Field: field_default,
    form,
    name,
    asChild,
    el,
    fieldsetAttrs
  });
  $$self.$inject_state = ($$new_props) => {
    if ("form" in $$props) $$invalidate(1, form = $$new_props.form);
    if ("name" in $$props) $$invalidate(2, name = $$new_props.name);
    if ("asChild" in $$props) $$invalidate(3, asChild = $$new_props.asChild);
    if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
    if ("fieldsetAttrs" in $$props) $$invalidate(4, fieldsetAttrs = $$new_props.fieldsetAttrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(4, fieldsetAttrs = { "data-fs-fieldset": "", ...$$restProps });
  };
  return [el, form, name, asChild, fieldsetAttrs, slots, fieldset_binding, $$scope];
}
var Fieldset = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { form: 1, name: 2, asChild: 3, el: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fieldset",
      options,
      id: create_fragment6.name
    });
  }
  get form() {
    throw new Error("<Fieldset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set form(value) {
    throw new Error("<Fieldset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Fieldset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Fieldset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asChild() {
    throw new Error("<Fieldset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Fieldset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get el() {
    throw new Error("<Fieldset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set el(value) {
    throw new Error("<Fieldset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var fieldset_default = Fieldset;

// node_modules/formsnap/dist/components/legend.svelte
var file5 = "node_modules/formsnap/dist/components/legend.svelte";
var get_default_slot_changes_15 = (dirty) => ({ legendAttrs: dirty & /*legendAttrs*/
4 });
var get_default_slot_context_15 = (ctx) => ({ legendAttrs: (
  /*legendAttrs*/
  ctx[2]
) });
var get_default_slot_changes7 = (dirty) => ({ legendAttrs: dirty & /*legendAttrs*/
4 });
var get_default_slot_context7 = (ctx) => ({ legendAttrs: (
  /*legendAttrs*/
  ctx[2]
) });
function create_else_block5(ctx) {
  let legend;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context_15
  );
  let legend_levels = [
    /*legendAttrs*/
    ctx[2]
  ];
  let legend_data = {};
  for (let i = 0; i < legend_levels.length; i += 1) {
    legend_data = assign(legend_data, legend_levels[i]);
  }
  const block = {
    c: function create() {
      legend = element("legend");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      legend = claim_element(nodes, "LEGEND", {});
      var legend_nodes = children(legend);
      if (default_slot) default_slot.l(legend_nodes);
      legend_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(legend, legend_data);
      add_location(legend, file5, 29, 1, 919);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, legend, anchor);
      if (default_slot) {
        default_slot.m(legend, null);
      }
      ctx[7](legend);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, legendAttrs*/
        36)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes_15
            ),
            get_default_slot_context_15
          );
        }
      }
      set_attributes(legend, legend_data = get_spread_update(legend_levels, [dirty & /*legendAttrs*/
      4 && /*legendAttrs*/
      ctx2[2]]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(legend);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[7](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(29:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context7
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, legendAttrs*/
        36)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes7
            ),
            get_default_slot_context7
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(27:0) {#if asChild}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*asChild*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let legendAttrs;
  const omit_props_names = ["asChild", "el"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $errors;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Legend", slots, ["default"]);
  let { asChild = false } = $$props;
  let { el = void 0 } = $$props;
  const { errors } = getFormField();
  validate_store(errors, "errors");
  component_subscribe($$self, errors, (value) => $$invalidate(4, $errors = value));
  function legend_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("asChild" in $$new_props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("el" in $$new_props) $$invalidate(0, el = $$new_props.el);
    if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getFormField,
    getDataFsError,
    asChild,
    el,
    errors,
    legendAttrs,
    $errors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("asChild" in $$props) $$invalidate(1, asChild = $$new_props.asChild);
    if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
    if ("legendAttrs" in $$props) $$invalidate(2, legendAttrs = $$new_props.legendAttrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$invalidate(2, legendAttrs = {
      "data-fs-legend": "",
      "data-fs-error": getDataFsError($errors),
      ...$$restProps
    });
  };
  return [el, asChild, legendAttrs, errors, $errors, $$scope, slots, legend_binding];
}
var Legend = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { asChild: 1, el: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Legend",
      options,
      id: create_fragment7.name
    });
  }
  get asChild() {
    throw new Error("<Legend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asChild(value) {
    throw new Error("<Legend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get el() {
    throw new Error("<Legend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set el(value) {
    throw new Error("<Legend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var legend_default = Legend;

// node_modules/formsnap/dist/components/element-field.svelte
var get_default_slot_changes8 = (dirty) => ({
  value: dirty & /*value*/
  4,
  errors: dirty & /*$errors*/
  128,
  tainted: dirty & /*$tainted*/
  256,
  constraints: dirty & /*$formConstraints, name*/
  3
});
var get_default_slot_context8 = (ctx) => ({
  value: (
    /*value*/
    ctx[2]
  ),
  errors: (
    /*$errors*/
    ctx[7]
  ),
  tainted: (
    /*$tainted*/
    ctx[8]
  ),
  constraints: (
    /*$formConstraints*/
    ctx[1][
      /*name*/
      ctx[0]
    ]
  )
});
function create_fragment8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_default_slot_context8
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, value, $errors, $tainted, $formConstraints, name*/
        1048967)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_default_slot_changes8
            ),
            get_default_slot_context8
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function splitArrayPath(name2) {
  const [path2, index] = name2.split(/[[\]]/);
  return [path2, index];
}
function instance8($$self, $$props, $$invalidate) {
  let formErrors;
  let formConstraints;
  let formTainted;
  let formData;
  let path;
  let value;
  let $formData, $$unsubscribe_formData = noop, $$subscribe_formData = () => ($$unsubscribe_formData(), $$unsubscribe_formData = subscribe(formData, ($$value) => $$invalidate(15, $formData = $$value)), formData);
  let $parentDescriptionId;
  let $descriptionId;
  let $formTainted, $$unsubscribe_formTainted = noop, $$subscribe_formTainted = () => ($$unsubscribe_formTainted(), $$unsubscribe_formTainted = subscribe(formTainted, ($$value) => $$invalidate(18, $formTainted = $$value)), formTainted);
  let $formConstraints, $$unsubscribe_formConstraints = noop, $$subscribe_formConstraints = () => ($$unsubscribe_formConstraints(), $$unsubscribe_formConstraints = subscribe(formConstraints, ($$value) => $$invalidate(1, $formConstraints = $$value)), formConstraints);
  let $formErrors, $$unsubscribe_formErrors = noop, $$subscribe_formErrors = () => ($$unsubscribe_formErrors(), $$unsubscribe_formErrors = subscribe(formErrors, ($$value) => $$invalidate(19, $formErrors = $$value)), formErrors);
  let $errors;
  let $tainted;
  $$self.$$.on_destroy.push(() => $$unsubscribe_formData());
  $$self.$$.on_destroy.push(() => $$unsubscribe_formTainted());
  $$self.$$.on_destroy.push(() => $$unsubscribe_formConstraints());
  $$self.$$.on_destroy.push(() => $$unsubscribe_formErrors());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Element_field", slots, ["default"]);
  let { form } = $$props;
  let { name } = $$props;
  const { descriptionId: parentDescriptionId } = getFormField();
  validate_store(parentDescriptionId, "parentDescriptionId");
  component_subscribe($$self, parentDescriptionId, (value2) => $$invalidate(16, $parentDescriptionId = value2));
  const elementField = {
    name: writable(path),
    errors: writable([]),
    constraints: writable({}),
    tainted: writable(false),
    fieldErrorsId: writable(),
    descriptionId: writable($parentDescriptionId),
    form
  };
  const { tainted, errors, descriptionId } = elementField;
  validate_store(tainted, "tainted");
  component_subscribe($$self, tainted, (value2) => $$invalidate(8, $tainted = value2));
  validate_store(errors, "errors");
  component_subscribe($$self, errors, (value2) => $$invalidate(7, $errors = value2));
  validate_store(descriptionId, "descriptionId");
  component_subscribe($$self, descriptionId, (value2) => $$invalidate(17, $descriptionId = value2));
  setFormField(elementField);
  $$self.$$.on_mount.push(function() {
    if (form === void 0 && !("form" in $$props || $$self.$$.bound[$$self.$$.props["form"]])) {
      console.warn("<Element_field> was created without expected prop 'form'");
    }
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<Element_field> was created without expected prop 'name'");
    }
  });
  const writable_props = ["form", "name"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Element_field> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("form" in $$props2) $$invalidate(13, form = $$props2.form);
    if ("name" in $$props2) $$invalidate(0, name = $$props2.name);
    if ("$$scope" in $$props2) $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getValueAtPath,
    setFormField,
    getFormField,
    writable,
    extractErrorArray,
    form,
    name,
    parentDescriptionId,
    elementField,
    tainted,
    errors,
    descriptionId,
    splitArrayPath,
    value,
    path,
    formData,
    formTainted,
    formConstraints,
    formErrors,
    $formData,
    $parentDescriptionId,
    $descriptionId,
    $formTainted,
    $formConstraints,
    $formErrors,
    $errors,
    $tainted
  });
  $$self.$inject_state = ($$props2) => {
    if ("form" in $$props2) $$invalidate(13, form = $$props2.form);
    if ("name" in $$props2) $$invalidate(0, name = $$props2.name);
    if ("value" in $$props2) $$invalidate(2, value = $$props2.value);
    if ("path" in $$props2) $$invalidate(14, path = $$props2.path);
    if ("formData" in $$props2) $$subscribe_formData($$invalidate(3, formData = $$props2.formData));
    if ("formTainted" in $$props2) $$subscribe_formTainted($$invalidate(4, formTainted = $$props2.formTainted));
    if ("formConstraints" in $$props2) $$subscribe_formConstraints($$invalidate(5, formConstraints = $$props2.formConstraints));
    if ("formErrors" in $$props2) $$subscribe_formErrors($$invalidate(6, formErrors = $$props2.formErrors));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*form*/
    8192) {
      $: $$subscribe_formErrors($$invalidate(6, { errors: formErrors, constraints: formConstraints, tainted: formTainted, form: formData } = form, formErrors, $$subscribe_formConstraints($$invalidate(5, formConstraints)), $$subscribe_formTainted($$invalidate(4, formTainted)), $$subscribe_formData($$invalidate(3, formData))));
    }
    if ($$self.$$.dirty & /*name*/
    1) {
      $: $$invalidate(14, [path] = splitArrayPath(name), path);
    }
    if ($$self.$$.dirty & /*path*/
    16384) {
      $: elementField.name.set(path);
    }
    if ($$self.$$.dirty & /*name, $formErrors*/
    524289) {
      $: errors.set(extractErrorArray(getValueAtPath(name, $formErrors)));
    }
    if ($$self.$$.dirty & /*name, $formConstraints*/
    3) {
      $: elementField.constraints.set(getValueAtPath(name, $formConstraints) ?? {});
    }
    if ($$self.$$.dirty & /*$formTainted, name*/
    262145) {
      $: tainted.set($formTainted ? getValueAtPath(name, $formTainted) === true ? true : false : false);
    }
    if ($$self.$$.dirty & /*$descriptionId, $parentDescriptionId*/
    196608) {
      $: if (!$descriptionId && $parentDescriptionId) {
        elementField.descriptionId.set($parentDescriptionId);
      }
    }
    if ($$self.$$.dirty & /*name, $formData*/
    32769) {
      $: $$invalidate(2, value = getValueAtPath(name, $formData));
    }
  };
  return [
    name,
    $formConstraints,
    value,
    formData,
    formTainted,
    formConstraints,
    formErrors,
    $errors,
    $tainted,
    parentDescriptionId,
    tainted,
    errors,
    descriptionId,
    form,
    path,
    $formData,
    $parentDescriptionId,
    $descriptionId,
    $formTainted,
    $formErrors,
    $$scope,
    slots
  ];
}
var Element_field = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { form: 13, name: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Element_field",
      options,
      id: create_fragment8.name
    });
  }
  get form() {
    throw new Error("<Element_field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set form(value) {
    throw new Error("<Element_field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Element_field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Element_field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var element_field_default = Element_field;
export {
  control_default as Control,
  description_default as Description,
  element_field_default as ElementField,
  field_default as Field,
  field_errors_default as FieldErrors,
  fieldset_default as Fieldset,
  label_default as Label,
  legend_default as Legend,
  getFormControl,
  getFormField,
  setFormControl,
  setFormField
};
//# sourceMappingURL=formsnap.js.map
