{
  "version": 3,
  "sources": ["../../svelte-inview/dist/index.mjs"],
  "sourcesContent": ["function run(fn) {\n    return fn();\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\n\nconst dirty_components = [];\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (flushidx < dirty_components.length) {\n            const component = dirty_components[flushidx];\n            flushidx++;\n            update(component.$$);\n        }\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nconst defaultOptions = {\r\n    root: null,\r\n    rootMargin: '0px',\r\n    threshold: 0,\r\n    unobserveOnEnter: false,\r\n};\r\nconst createEvent = (name, detail) => new CustomEvent(name, { detail });\r\nfunction inview(node, options = {}) {\r\n    const { root, rootMargin, threshold, unobserveOnEnter } = Object.assign(Object.assign({}, defaultOptions), options);\r\n    let prevPos = {\r\n        x: undefined,\r\n        y: undefined,\r\n    };\r\n    let scrollDirection = {\r\n        vertical: undefined,\r\n        horizontal: undefined,\r\n    };\r\n    if (typeof IntersectionObserver !== 'undefined' && node) {\r\n        const observer = new IntersectionObserver((entries, _observer) => {\r\n            entries.forEach((singleEntry) => {\r\n                if (prevPos.y > singleEntry.boundingClientRect.y) {\r\n                    scrollDirection.vertical = 'up';\r\n                }\r\n                else {\r\n                    scrollDirection.vertical = 'down';\r\n                }\r\n                if (prevPos.x > singleEntry.boundingClientRect.x) {\r\n                    scrollDirection.horizontal = 'left';\r\n                }\r\n                else {\r\n                    scrollDirection.horizontal = 'right';\r\n                }\r\n                prevPos = {\r\n                    y: singleEntry.boundingClientRect.y,\r\n                    x: singleEntry.boundingClientRect.x,\r\n                };\r\n                const detail = {\r\n                    inView: singleEntry.isIntersecting,\r\n                    entry: singleEntry,\r\n                    scrollDirection,\r\n                    node,\r\n                    observer: _observer,\r\n                };\r\n                node.dispatchEvent(createEvent('inview_change', detail));\r\n                //@ts-expect-error only for backward compatibility\r\n                node.dispatchEvent(createEvent('change', detail));\r\n                if (singleEntry.isIntersecting) {\r\n                    node.dispatchEvent(createEvent('inview_enter', detail));\r\n                    //@ts-expect-error only for backward compatibility\r\n                    node.dispatchEvent(createEvent('enter', detail));\r\n                    unobserveOnEnter && _observer.unobserve(node);\r\n                }\r\n                else {\r\n                    node.dispatchEvent(createEvent('inview_leave', detail));\r\n                    //@ts-expect-error only for backward compatibility\r\n                    node.dispatchEvent(createEvent('leave', detail));\r\n                }\r\n            });\r\n        }, {\r\n            root,\r\n            rootMargin,\r\n            threshold,\r\n        });\r\n        tick().then(() => {\r\n            node.dispatchEvent(createEvent('inview_init', { observer, node }));\r\n            node.dispatchEvent(\r\n            //@ts-expect-error only for backward compatibility\r\n            createEvent('init', { observer, node }));\r\n        });\r\n        observer.observe(node);\r\n        return {\r\n            destroy() {\r\n                observer.unobserve(node);\r\n            },\r\n        };\r\n    }\r\n}\n\nexport { inview };\n"],
  "mappings": "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",
  "names": []
}
