import "./chunk-MTI3AIJG.js";

// node_modules/svelte-inview/dist/index.mjs
function run(fn) {
  return fn();
}
function run_all(fns) {
  fns.forEach(run);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      update(component.$$);
    }
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var defaultOptions = {
  root: null,
  rootMargin: "0px",
  threshold: 0,
  unobserveOnEnter: false
};
var createEvent = (name, detail) => new CustomEvent(name, { detail });
function inview(node, options = {}) {
  const { root, rootMargin, threshold, unobserveOnEnter } = Object.assign(Object.assign({}, defaultOptions), options);
  let prevPos = {
    x: void 0,
    y: void 0
  };
  let scrollDirection = {
    vertical: void 0,
    horizontal: void 0
  };
  if (typeof IntersectionObserver !== "undefined" && node) {
    const observer = new IntersectionObserver((entries, _observer) => {
      entries.forEach((singleEntry) => {
        if (prevPos.y > singleEntry.boundingClientRect.y) {
          scrollDirection.vertical = "up";
        } else {
          scrollDirection.vertical = "down";
        }
        if (prevPos.x > singleEntry.boundingClientRect.x) {
          scrollDirection.horizontal = "left";
        } else {
          scrollDirection.horizontal = "right";
        }
        prevPos = {
          y: singleEntry.boundingClientRect.y,
          x: singleEntry.boundingClientRect.x
        };
        const detail = {
          inView: singleEntry.isIntersecting,
          entry: singleEntry,
          scrollDirection,
          node,
          observer: _observer
        };
        node.dispatchEvent(createEvent("inview_change", detail));
        node.dispatchEvent(createEvent("change", detail));
        if (singleEntry.isIntersecting) {
          node.dispatchEvent(createEvent("inview_enter", detail));
          node.dispatchEvent(createEvent("enter", detail));
          unobserveOnEnter && _observer.unobserve(node);
        } else {
          node.dispatchEvent(createEvent("inview_leave", detail));
          node.dispatchEvent(createEvent("leave", detail));
        }
      });
    }, {
      root,
      rootMargin,
      threshold
    });
    tick().then(() => {
      node.dispatchEvent(createEvent("inview_init", { observer, node }));
      node.dispatchEvent(
        //@ts-expect-error only for backward compatibility
        createEvent("init", { observer, node })
      );
    });
    observer.observe(node);
    return {
      destroy() {
        observer.unobserve(node);
      }
    };
  }
}
export {
  inview
};
//# sourceMappingURL=svelte-inview.js.map
