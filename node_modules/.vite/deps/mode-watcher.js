import "./chunk-SA3VOP2B.js";
import {
  derived,
  writable
} from "./chunk-PCTSVBTO.js";
import "./chunk-X7HCJ7ZS.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  attr_dev,
  claim_element,
  claim_html_tag,
  component_subscribe,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_store_value,
  head_selector,
  init,
  insert_hydration_dev,
  noop,
  onMount,
  safe_not_equal,
  validate_slots,
  validate_store
} from "./chunk-L3FAA3FO.js";
import "./chunk-EKIRE5YT.js";
import "./chunk-MTI3AIJG.js";

// node_modules/mode-watcher/dist/without-transition.js
var timeoutAction;
var timeoutEnable;
function withoutTransition(action) {
  if (typeof document === "undefined")
    return;
  clearTimeout(timeoutAction);
  clearTimeout(timeoutEnable);
  const style = document.createElement("style");
  const css = document.createTextNode(`* {
     -webkit-transition: none !important;
     -moz-transition: none !important;
     -o-transition: none !important;
     -ms-transition: none !important;
     transition: none !important;
  }`);
  style.appendChild(css);
  const disable = () => document.head.appendChild(style);
  const enable = () => document.head.removeChild(style);
  if (typeof window.getComputedStyle !== "undefined") {
    disable();
    action();
    window.getComputedStyle(style).opacity;
    enable();
    return;
  }
  if (typeof window.requestAnimationFrame !== "undefined") {
    disable();
    action();
    window.requestAnimationFrame(enable);
    return;
  }
  disable();
  timeoutAction = window.setTimeout(() => {
    action();
    timeoutEnable = window.setTimeout(enable, 120);
  }, 120);
}

// node_modules/mode-watcher/dist/utils.js
function sanitizeClassNames(classNames) {
  return classNames.filter((className) => className.length > 0);
}

// node_modules/mode-watcher/dist/stores.js
var noopStorage = {
  getItem: (_key) => null,
  setItem: (_key, _value) => {
  }
};
var isBrowser = typeof document !== "undefined";
var modes = ["dark", "light", "system"];
var modeStorageKey = writable("mode-watcher-mode");
var themeStorageKey = writable("mode-watcher-theme");
var userPrefersMode = createUserPrefersMode();
var systemPrefersMode = createSystemMode();
var themeColors = writable(void 0);
var theme = createCustomTheme();
var disableTransitions = writable(true);
var darkClassNames = writable([]);
var lightClassNames = writable([]);
var derivedMode = createDerivedMode();
var derivedTheme = createDerivedTheme();
function createUserPrefersMode() {
  const defaultValue = "system";
  const storage = isBrowser ? localStorage : noopStorage;
  const initialValue = storage.getItem(getModeStorageKey());
  let value = isValidMode(initialValue) ? initialValue : defaultValue;
  function getModeStorageKey() {
    return get_store_value(modeStorageKey);
  }
  const { subscribe, set: _set } = writable(value, () => {
    if (!isBrowser)
      return;
    const handler = (e) => {
      if (e.key !== getModeStorageKey())
        return;
      const newValue = e.newValue;
      if (isValidMode(newValue)) {
        _set(value = newValue);
      } else {
        _set(value = defaultValue);
      }
    };
    addEventListener("storage", handler);
    return () => removeEventListener("storage", handler);
  });
  function set(v) {
    _set(value = v);
    storage.setItem(getModeStorageKey(), value);
  }
  return {
    subscribe,
    set
  };
}
function createCustomTheme() {
  const storage = isBrowser ? localStorage : noopStorage;
  const initialValue = storage.getItem(getThemeStorageKey());
  let value = initialValue === null || initialValue === void 0 ? "" : initialValue;
  function getThemeStorageKey() {
    return get_store_value(themeStorageKey);
  }
  const { subscribe, set: _set } = writable(value, () => {
    if (!isBrowser)
      return;
    const handler = (e) => {
      if (e.key !== getThemeStorageKey())
        return;
      const newValue = e.newValue;
      if (newValue === null) {
        _set(value = "");
      } else {
        _set(value = newValue);
      }
    };
    addEventListener("storage", handler);
    return () => removeEventListener("storage", handler);
  });
  function set(v) {
    _set(value = v);
    storage.setItem(getThemeStorageKey(), value);
  }
  return {
    subscribe,
    set
  };
}
function createSystemMode() {
  const defaultValue = void 0;
  let track = true;
  const { subscribe, set } = writable(defaultValue, () => {
    if (!isBrowser)
      return;
    const handler = (e) => {
      if (!track)
        return;
      set(e.matches ? "light" : "dark");
    };
    const mediaQueryState = window.matchMedia("(prefers-color-scheme: light)");
    mediaQueryState.addEventListener("change", handler);
    return () => mediaQueryState.removeEventListener("change", handler);
  });
  function query() {
    if (!isBrowser)
      return;
    const mediaQueryState = window.matchMedia("(prefers-color-scheme: light)");
    set(mediaQueryState.matches ? "light" : "dark");
  }
  function tracking(active) {
    track = active;
  }
  return {
    subscribe,
    query,
    tracking
  };
}
function createDerivedMode() {
  const { subscribe } = derived([
    userPrefersMode,
    systemPrefersMode,
    themeColors,
    disableTransitions,
    darkClassNames,
    lightClassNames
  ], ([$userPrefersMode, $systemPrefersMode, $themeColors, $disableTransitions, $darkClassNames, $lightClassNames]) => {
    if (!isBrowser)
      return void 0;
    const derivedMode2 = $userPrefersMode === "system" ? $systemPrefersMode : $userPrefersMode;
    const sanitizedDarkClassNames = sanitizeClassNames($darkClassNames);
    const sanitizedLightClassNames = sanitizeClassNames($lightClassNames);
    function update() {
      const htmlEl = document.documentElement;
      const themeColorEl = document.querySelector('meta[name="theme-color"]');
      if (derivedMode2 === "light") {
        if (sanitizedDarkClassNames.length)
          htmlEl.classList.remove(...sanitizedDarkClassNames);
        if (sanitizedLightClassNames.length)
          htmlEl.classList.add(...sanitizedLightClassNames);
        htmlEl.style.colorScheme = "light";
        if (themeColorEl && $themeColors) {
          themeColorEl.setAttribute("content", $themeColors.light);
        }
      } else {
        if (sanitizedLightClassNames.length)
          htmlEl.classList.remove(...sanitizedLightClassNames);
        if (sanitizedDarkClassNames.length)
          htmlEl.classList.add(...sanitizedDarkClassNames);
        htmlEl.style.colorScheme = "dark";
        if (themeColorEl && $themeColors) {
          themeColorEl.setAttribute("content", $themeColors.dark);
        }
      }
    }
    if ($disableTransitions) {
      withoutTransition(update);
    } else {
      update();
    }
    return derivedMode2;
  });
  return {
    subscribe
  };
}
function createDerivedTheme() {
  const { subscribe } = derived([theme, disableTransitions], ([$theme, $disableTransitions]) => {
    if (!isBrowser)
      return void 0;
    function update() {
      const htmlEl = document.documentElement;
      htmlEl.setAttribute("data-theme", $theme);
    }
    if ($disableTransitions) {
      withoutTransition(update);
    } else {
      update();
    }
    return $theme;
  });
  return {
    subscribe
  };
}
function isValidMode(value) {
  if (typeof value !== "string")
    return false;
  return modes.includes(value);
}

// node_modules/mode-watcher/dist/mode.js
function toggleMode() {
  userPrefersMode.set(get_store_value(derivedMode) === "dark" ? "light" : "dark");
}
function setMode(mode) {
  userPrefersMode.set(mode);
}
function resetMode() {
  userPrefersMode.set("system");
}
function setTheme(theme2) {
  theme.set(theme2);
}
function defineConfig(config) {
  return config;
}
function setInitialMode({ defaultMode, themeColors: themeColors2, darkClassNames: darkClassNames2 = ["dark"], lightClassNames: lightClassNames2 = [], defaultTheme = "" }) {
  const rootEl = document.documentElement;
  const mode = localStorage.getItem("mode-watcher-mode") || defaultMode;
  const theme2 = localStorage.getItem("mode-watcher-theme") || defaultTheme;
  const light = mode === "light" || mode === "system" && window.matchMedia("(prefers-color-scheme: light)").matches;
  if (light) {
    if (darkClassNames2.length)
      rootEl.classList.remove(...darkClassNames2);
    if (lightClassNames2.length)
      rootEl.classList.add(...lightClassNames2);
  } else {
    if (lightClassNames2.length)
      rootEl.classList.remove(...lightClassNames2);
    if (darkClassNames2.length)
      rootEl.classList.add(...darkClassNames2);
  }
  rootEl.style.colorScheme = light ? "light" : "dark";
  if (themeColors2) {
    const themeMetaEl = document.querySelector('meta[name="theme-color"]');
    if (themeMetaEl) {
      themeMetaEl.setAttribute("content", mode === "light" ? themeColors2.light : themeColors2.dark);
    }
  }
  if (theme2) {
    rootEl.setAttribute("data-theme", theme2);
    localStorage.setItem("mode-watcher-theme", theme2);
  }
  localStorage.setItem("mode-watcher-mode", mode);
}

// node_modules/mode-watcher/dist/mode-watcher.svelte
var file = "node_modules/mode-watcher/dist/mode-watcher.svelte";
function create_if_block_1(ctx) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "theme-color");
      attr_dev(meta, "content", meta_content_value = /*themeColors*/
      ctx[0].dark);
      add_location(meta, file, 64, 2, 1959);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*themeColors*/
      1 && meta_content_value !== (meta_content_value = /*themeColors*/
      ctx2[0].dark)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(61:1) {#if themeColors}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let html_tag;
  let raw_value = `<script>(` + setInitialMode.toString() + `)(` + JSON.stringify(
    /*initConfig*/
    ctx[2]
  ) + `);<\/script>`;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(75:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let html_tag;
  let raw_value = `<script nonce=${/*trueNonce*/
  ctx[1]}>(` + setInitialMode.toString() + `)(` + JSON.stringify(
    /*initConfig*/
    ctx[2]
  ) + `);<\/script>`;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*trueNonce*/
      2 && raw_value !== (raw_value = `<script nonce=${/*trueNonce*/
      ctx2[1]}>(` + setInitialMode.toString() + `)(` + JSON.stringify(
        /*initConfig*/
        ctx2[2]
      ) + `);<\/script>`)) html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(68:1) {#if trueNonce}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block0_anchor;
  let if_block1_anchor;
  let if_block0 = (
    /*themeColors*/
    ctx[0] && create_if_block_1(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*trueNonce*/
      ctx2[1]
    ) return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type(ctx);
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      if_block0_anchor = empty();
      if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector("svelte-1nen96w", document.head);
      if (if_block0) if_block0.l(head_nodes);
      if_block0_anchor = empty();
      if_block1.l(head_nodes);
      if_block1_anchor = empty();
      head_nodes.forEach(detach_dev);
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(document.head, null);
      append_hydration_dev(document.head, if_block0_anchor);
      if_block1.m(document.head, null);
      append_hydration_dev(document.head, if_block1_anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*themeColors*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block0) if_block0.d(detaching);
      detach_dev(if_block0_anchor);
      if_block1.d(detaching);
      detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let trueNonce;
  let $themeStorageKeyStore;
  let $modeStorageKeyStore;
  validate_store(themeStorageKey, "themeStorageKeyStore");
  component_subscribe($$self, themeStorageKey, ($$value) => $$invalidate(12, $themeStorageKeyStore = $$value));
  validate_store(modeStorageKey, "modeStorageKeyStore");
  component_subscribe($$self, modeStorageKey, ($$value) => $$invalidate(13, $modeStorageKeyStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Mode_watcher", slots, []);
  let { track = true } = $$props;
  let { defaultMode = "system" } = $$props;
  let { themeColors: themeColors2 = void 0 } = $$props;
  let { disableTransitions: disableTransitions2 = true } = $$props;
  let { darkClassNames: darkClassNames2 = ["dark"] } = $$props;
  let { lightClassNames: lightClassNames2 = [] } = $$props;
  let { defaultTheme = "" } = $$props;
  let { nonce = "" } = $$props;
  let { themeStorageKey: themeStorageKey2 = "mode-watcher-theme" } = $$props;
  let { modeStorageKey: modeStorageKey2 = "mode-watcher-mode" } = $$props;
  onMount(() => {
    const unsubscriber = derivedMode.subscribe(() => {
    });
    systemPrefersMode.tracking(track);
    systemPrefersMode.query();
    const localStorageMode = localStorage.getItem($modeStorageKeyStore);
    setMode(isValidMode(localStorageMode) ? localStorageMode : defaultMode);
    const localStorageTheme = localStorage.getItem($themeStorageKeyStore);
    setTheme(localStorageTheme || defaultTheme);
    return () => {
      unsubscriber();
    };
  });
  const initConfig = defineConfig({
    defaultMode,
    themeColors: themeColors2,
    darkClassNames: darkClassNames2,
    lightClassNames: lightClassNames2,
    defaultTheme,
    modeStorageKey: modeStorageKey2,
    themeStorageKey: themeStorageKey2
  });
  const writable_props = [
    "track",
    "defaultMode",
    "themeColors",
    "disableTransitions",
    "darkClassNames",
    "lightClassNames",
    "defaultTheme",
    "nonce",
    "themeStorageKey",
    "modeStorageKey"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Mode_watcher> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("track" in $$props2) $$invalidate(3, track = $$props2.track);
    if ("defaultMode" in $$props2) $$invalidate(4, defaultMode = $$props2.defaultMode);
    if ("themeColors" in $$props2) $$invalidate(0, themeColors2 = $$props2.themeColors);
    if ("disableTransitions" in $$props2) $$invalidate(5, disableTransitions2 = $$props2.disableTransitions);
    if ("darkClassNames" in $$props2) $$invalidate(6, darkClassNames2 = $$props2.darkClassNames);
    if ("lightClassNames" in $$props2) $$invalidate(7, lightClassNames2 = $$props2.lightClassNames);
    if ("defaultTheme" in $$props2) $$invalidate(8, defaultTheme = $$props2.defaultTheme);
    if ("nonce" in $$props2) $$invalidate(9, nonce = $$props2.nonce);
    if ("themeStorageKey" in $$props2) $$invalidate(10, themeStorageKey2 = $$props2.themeStorageKey);
    if ("modeStorageKey" in $$props2) $$invalidate(11, modeStorageKey2 = $$props2.modeStorageKey);
  };
  $$self.$capture_state = () => ({
    onMount,
    defineConfig,
    disableTransitionsStore: disableTransitions,
    mode: derivedMode,
    setInitialMode,
    setMode,
    setTheme,
    systemPrefersMode,
    themeColorsStore: themeColors,
    darkClassNamesStore: darkClassNames,
    isValidMode,
    lightClassNamesStore: lightClassNames,
    modeStorageKeyStore: modeStorageKey,
    themeStorageKeyStore: themeStorageKey,
    track,
    defaultMode,
    themeColors: themeColors2,
    disableTransitions: disableTransitions2,
    darkClassNames: darkClassNames2,
    lightClassNames: lightClassNames2,
    defaultTheme,
    nonce,
    themeStorageKey: themeStorageKey2,
    modeStorageKey: modeStorageKey2,
    initConfig,
    trueNonce,
    $themeStorageKeyStore,
    $modeStorageKeyStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("track" in $$props2) $$invalidate(3, track = $$props2.track);
    if ("defaultMode" in $$props2) $$invalidate(4, defaultMode = $$props2.defaultMode);
    if ("themeColors" in $$props2) $$invalidate(0, themeColors2 = $$props2.themeColors);
    if ("disableTransitions" in $$props2) $$invalidate(5, disableTransitions2 = $$props2.disableTransitions);
    if ("darkClassNames" in $$props2) $$invalidate(6, darkClassNames2 = $$props2.darkClassNames);
    if ("lightClassNames" in $$props2) $$invalidate(7, lightClassNames2 = $$props2.lightClassNames);
    if ("defaultTheme" in $$props2) $$invalidate(8, defaultTheme = $$props2.defaultTheme);
    if ("nonce" in $$props2) $$invalidate(9, nonce = $$props2.nonce);
    if ("themeStorageKey" in $$props2) $$invalidate(10, themeStorageKey2 = $$props2.themeStorageKey);
    if ("modeStorageKey" in $$props2) $$invalidate(11, modeStorageKey2 = $$props2.modeStorageKey);
    if ("trueNonce" in $$props2) $$invalidate(1, trueNonce = $$props2.trueNonce);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*disableTransitions*/
    32) {
      $: disableTransitions.set(disableTransitions2);
    }
    if ($$self.$$.dirty & /*themeColors*/
    1) {
      $: themeColors.set(themeColors2);
    }
    if ($$self.$$.dirty & /*darkClassNames*/
    64) {
      $: darkClassNames.set(darkClassNames2);
    }
    if ($$self.$$.dirty & /*lightClassNames*/
    128) {
      $: lightClassNames.set(lightClassNames2);
    }
    if ($$self.$$.dirty & /*modeStorageKey*/
    2048) {
      $: modeStorageKey.set(modeStorageKey2);
    }
    if ($$self.$$.dirty & /*themeStorageKey*/
    1024) {
      $: themeStorageKey.set(themeStorageKey2);
    }
    if ($$self.$$.dirty & /*nonce*/
    512) {
      $: $$invalidate(1, trueNonce = typeof window === "undefined" ? nonce : "");
    }
  };
  return [
    themeColors2,
    trueNonce,
    initConfig,
    track,
    defaultMode,
    disableTransitions2,
    darkClassNames2,
    lightClassNames2,
    defaultTheme,
    nonce,
    themeStorageKey2,
    modeStorageKey2
  ];
}
var Mode_watcher = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      track: 3,
      defaultMode: 4,
      themeColors: 0,
      disableTransitions: 5,
      darkClassNames: 6,
      lightClassNames: 7,
      defaultTheme: 8,
      nonce: 9,
      themeStorageKey: 10,
      modeStorageKey: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Mode_watcher",
      options,
      id: create_fragment.name
    });
  }
  get track() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set track(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultMode() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultMode(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get themeColors() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set themeColors(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableTransitions() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableTransitions(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get darkClassNames() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set darkClassNames(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lightClassNames() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lightClassNames(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultTheme() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultTheme(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonce() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonce(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get themeStorageKey() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set themeStorageKey(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get modeStorageKey() {
    throw new Error("<Mode_watcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set modeStorageKey(value) {
    throw new Error("<Mode_watcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var mode_watcher_default = Mode_watcher;
export {
  mode_watcher_default as ModeWatcher,
  derivedMode as mode,
  modeStorageKey,
  resetMode,
  setMode,
  setTheme,
  systemPrefersMode,
  derivedTheme as theme,
  themeStorageKey,
  toggleMode,
  userPrefersMode
};
//# sourceMappingURL=mode-watcher.js.map
