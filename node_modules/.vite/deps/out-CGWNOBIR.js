import {
  __publicField
} from "./chunk-MTI3AIJG.js";

// node_modules/@ark/util/out/arrays.js
var arrayFrom = (data) => Array.isArray(data) ? data : [data];
var spliterate = (list, by) => {
  const result = [[], []];
  for (const item of list) {
    if (by(item))
      result[0].push(item);
    else
      result[1].push(item);
  }
  return result;
};
var ReadonlyArray = Array;
var includes = (array, element) => array.includes(element);
var append = (to, value, opts) => {
  if (to === void 0) {
    return value === void 0 ? [] : Array.isArray(value) ? value : [value];
  }
  if (opts == null ? void 0 : opts.prepend)
    Array.isArray(value) ? to.unshift(...value) : to.unshift(value);
  else
    Array.isArray(value) ? to.push(...value) : to.push(value);
  return to;
};
var appendUnique = (to, value, opts) => {
  if (to === void 0)
    return Array.isArray(value) ? value : [value];
  const isEqual = (opts == null ? void 0 : opts.isEqual) ?? ((l, r) => l === r);
  arrayFrom(value).forEach((v) => {
    if (!to.some((existing) => isEqual(existing, v)))
      to.push(v);
  });
  return to;
};
var groupBy = (array, discriminant) => array.reduce((result, item) => {
  const key = item[discriminant];
  result[key] = append(result[key], item);
  return result;
}, {});
var arrayEquals = (l, r, opts) => l.length === r.length && l.every((opts == null ? void 0 : opts.isEqual) ? (lItem, i) => opts.isEqual(lItem, r[i]) : (lItem, i) => lItem === r[i]);

// node_modules/@ark/util/out/errors.js
var InternalArktypeError = class extends Error {
};
var throwInternalError = (message) => throwError(message, InternalArktypeError);
var throwError = (message, ctor = Error) => {
  throw new ctor(message);
};
var ParseError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ParseError");
  }
};
var throwParseError = (message) => throwError(message, ParseError);

// node_modules/@ark/util/out/flatMorph.js
function flatMorph(o, flatMapEntry) {
  var _a5;
  const inputIsArray = Array.isArray(o);
  const entries = Object.entries(o).flatMap((entry, i) => {
    const result = inputIsArray ? flatMapEntry(i, entry[1]) : flatMapEntry(...entry, i);
    const entrySet = Array.isArray(result[0]) || result.length === 0 ? (
      // if we have an empty array (for filtering) or an array with
      // another array as its first element, treat it as a list of
      result
    ) : [result];
    return entrySet;
  });
  const objectResult = Object.fromEntries(entries);
  return typeof ((_a5 = entries[0]) == null ? void 0 : _a5[0]) === "number" ? Object.values(objectResult) : objectResult;
}

// node_modules/@ark/util/out/records.js
var entriesOf = (o) => Object.entries(o);
var isKeyOf = (k, o) => k in o;
var InnerDynamicBase = class {
  constructor(properties) {
    Object.assign(this, properties);
  }
};
var DynamicBase = class extends InnerDynamicBase {
};
var NoopBase = class {
};
var CastableBase = class extends NoopBase {
};
var splitByKeys = (o, leftKeys) => {
  const l = {};
  const r = {};
  let k;
  for (k in o) {
    if (k in leftKeys)
      l[k] = o[k];
    else
      r[k] = o[k];
  }
  return [l, r];
};
var pick = (o, keys) => splitByKeys(o, keys)[0];
var omit = (o, keys) => splitByKeys(o, keys)[1];
var isEmptyObject = (o) => Object.keys(o).length === 0;
var stringAndSymbolicEntriesOf = (o) => [
  ...Object.entries(o),
  ...Object.getOwnPropertySymbols(o).map((k) => [k, o[k]])
];
var defineProperties = (base, merged) => (
  // declared like this to avoid https://github.com/microsoft/TypeScript/issues/55049
  Object.defineProperties(base, Object.getOwnPropertyDescriptors(merged))
);
var unset = Symbol("represents an uninitialized value");

// node_modules/@ark/util/out/functions.js
var bound = (target, ctx) => {
  ctx.addInitializer(function() {
    this[ctx.name] = this[ctx.name].bind(this);
  });
};
var cached = (target, context) => function() {
  const value = target.call(this);
  Object.defineProperty(this, context.name, context.kind === "getter" ? { value } : {
    value: () => value,
    enumerable: false
  });
  return value;
};
var cachedThunk = (thunk) => {
  let result = unset;
  return () => result === unset ? result = thunk() : result;
};
var isThunk = (value) => typeof value === "function" && value.length === 0;
var DynamicFunction = class extends Function {
  constructor(...args) {
    const params = args.slice(0, -1);
    const body = args.at(-1);
    try {
      super(...params, body);
    } catch (e) {
      return throwInternalError(`Encountered an unexpected error while compiling your definition:
                Message: ${e} 
                Source: (${args.slice(0, -1)}) => {
                    ${args.at(-1)}
                }`);
    }
  }
};
var Callable = class extends NoopBase {
  constructor(f, opts) {
    super();
    return Object.assign(Object.setPrototypeOf(f.bind((opts == null ? void 0 : opts.bind) ?? this), this.constructor.prototype), opts == null ? void 0 : opts.attach);
  }
};
var envHasCsp = cachedThunk(() => {
  try {
    return new Function("return false")();
  } catch (e) {
    return true;
  }
});

// node_modules/@ark/util/out/domain.js
var hasDomain = (data, kind) => domainOf(data) === kind;
var domainOf = (data) => {
  const builtinType = typeof data;
  return builtinType === "object" ? data === null ? "null" : "object" : builtinType === "function" ? "object" : builtinType;
};
var enumerableDomainDescriptions = {
  boolean: "boolean",
  null: "null",
  undefined: "undefined"
};
var nonEnumerableDomainDescriptions = {
  bigint: "a bigint",
  number: "a number",
  object: "an object",
  string: "a string",
  symbol: "a symbol"
};
var domainDescriptions = {
  ...nonEnumerableDomainDescriptions,
  ...enumerableDomainDescriptions
};

// node_modules/@ark/util/out/objectKinds.js
var builtinConstructors = {
  Array,
  Date,
  Error,
  Function,
  Map,
  RegExp,
  Set,
  String,
  Number,
  Boolean,
  WeakMap,
  WeakSet,
  Promise
};
var objectKindOf = (data) => {
  var _a5;
  let prototype = Object.getPrototypeOf(data);
  while ((prototype == null ? void 0 : prototype.constructor) && (!isKeyOf(prototype.constructor.name, builtinConstructors) || !(data instanceof builtinConstructors[prototype.constructor.name])))
    prototype = Object.getPrototypeOf(prototype);
  const name = (_a5 = prototype == null ? void 0 : prototype.constructor) == null ? void 0 : _a5.name;
  if (name === void 0 || name === "Object")
    return void 0;
  return name;
};
var objectKindOrDomainOf = (data) => typeof data === "object" && data !== null ? objectKindOf(data) ?? "object" : domainOf(data);
var isArray = (data) => Array.isArray(data);
var objectKindDescriptions = {
  Array: "an array",
  Function: "a function",
  Date: "a Date",
  RegExp: "a RegExp",
  Error: "an Error",
  Map: "a Map",
  Set: "a Set",
  String: "a String object",
  Number: "a Number object",
  Boolean: "a Boolean object",
  Promise: "a Promise",
  WeakMap: "a WeakMap",
  WeakSet: "a WeakSet"
};
var getExactBuiltinConstructorName = (ctor) => {
  const constructorName = Object(ctor).name ?? null;
  return constructorName && isKeyOf(constructorName, builtinConstructors) && builtinConstructors[constructorName] === ctor ? constructorName : null;
};
var prototypeKeysOf = (value) => {
  const result = [];
  let curr = value;
  while (curr !== Object.prototype && curr !== null && curr !== void 0) {
    for (const k of Object.getOwnPropertyNames(curr))
      if (k !== "constructor" && !result.includes(k))
        result.push(k);
    for (const symbol of Object.getOwnPropertySymbols(curr))
      if (!result.includes(symbol))
        result.push(symbol);
    curr = Object.getPrototypeOf(curr);
  }
  return result;
};
var baseKeysByDomain = {
  bigint: prototypeKeysOf(0n),
  boolean: prototypeKeysOf(false),
  null: [],
  number: prototypeKeysOf(0),
  // TS doesn't include the Object prototype in keyof, so keyof object is never
  object: [],
  string: prototypeKeysOf(""),
  symbol: prototypeKeysOf(Symbol()),
  undefined: []
};
var getBaseDomainKeys = (domain) => [...baseKeysByDomain[domain]];
var constructorExtends = (ctor, base) => {
  let current = ctor.prototype;
  while (current !== null) {
    if (current === base.prototype)
      return true;
    current = Object.getPrototypeOf(current);
  }
  return false;
};

// node_modules/@ark/util/out/primitive.js
var serializePrimitive = (value) => typeof value === "string" ? JSON.stringify(value) : typeof value === "bigint" ? `${value}n` : `${value}`;

// node_modules/@ark/util/out/registry.js
if ("$ark" in globalThis) {
  throwError(`Tried to initialize an $ark registry but one already existed.
This probably means you are either depending on multiple versions of an arktype package,
or importing the same package from both ESM and CJS.
Review package.json versions across your repo to ensure consistency.`);
}
var registry = {};
globalThis.$ark = registry;
var namesByResolution = /* @__PURE__ */ new WeakMap();
var nameCounts = {};
var register = (value) => {
  const existingName = namesByResolution.get(value);
  if (existingName)
    return existingName;
  let name = baseNameFor(value);
  if (nameCounts[name])
    name = `${name}${nameCounts[name]++}`;
  else
    nameCounts[name] = 1;
  registry[name] = value;
  namesByResolution.set(value, name);
  return name;
};
var reference = (name) => `$ark.${name}`;
var registeredReference = (value) => reference(register(value));
var isDotAccessible = (keyName) => /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(keyName);
var compileSerializedValue = (value) => hasDomain(value, "object") || typeof value === "symbol" ? registeredReference(value) : serializePrimitive(value);
var baseNameFor = (value) => {
  switch (typeof value) {
    case "object": {
      if (value === null)
        break;
      const prefix = objectKindOf(value) ?? "object";
      return prefix[0].toLowerCase() + prefix.slice(1);
    }
    case "function":
      return isDotAccessible(value.name) ? value.name : "fn";
    case "symbol":
      return value.description && isDotAccessible(value.description) ? value.description : "symbol";
  }
  return throwInternalError(`Unexpected attempt to register serializable value of type ${domainOf(value)}`);
};

// node_modules/@ark/util/out/compilation.js
var CompiledFunction = class extends CastableBase {
  constructor(...args) {
    super();
    __publicField(this, "argNames");
    __publicField(this, "body", "");
    __publicField(this, "indentation", 0);
    this.argNames = args;
    for (const arg of args) {
      if (arg in this) {
        throw new Error(`Arg name '${arg}' would overwrite an existing property on FunctionBody`);
      }
      ;
      this[arg] = arg;
    }
  }
  indent() {
    this.indentation += 4;
    return this;
  }
  dedent() {
    this.indentation -= 4;
    return this;
  }
  prop(key, optional = false) {
    return compileLiteralPropAccess(key, optional);
  }
  index(key, optional = false) {
    return indexPropAccess(`${key}`, optional);
  }
  line(statement) {
    ;
    this.body += `${" ".repeat(this.indentation)}${statement}
`;
    return this;
  }
  const(identifier, expression) {
    this.line(`const ${identifier} = ${expression}`);
    return this;
  }
  let(identifier, expression) {
    return this.line(`let ${identifier} = ${expression}`);
  }
  set(identifier, expression) {
    return this.line(`${identifier} = ${expression}`);
  }
  if(condition, then) {
    return this.block(`if (${condition})`, then);
  }
  elseIf(condition, then) {
    return this.block(`else if (${condition})`, then);
  }
  else(then) {
    return this.block("else", then);
  }
  /** Current index is "i" */
  for(until, body, initialValue = 0) {
    return this.block(`for (let i = ${initialValue}; ${until}; i++)`, body);
  }
  /** Current key is "k" */
  forIn(object, body) {
    return this.block(`for (const k in ${object})`, body);
  }
  block(prefix, contents, suffix = "") {
    this.line(`${prefix} {`);
    this.indent();
    contents(this);
    this.dedent();
    return this.line(`}${suffix}`);
  }
  return(expression = "") {
    return this.line(`return ${expression}`);
  }
  compile() {
    return new DynamicFunction(...this.argNames, this.body);
  }
};
var compileLiteralPropAccess = (key, optional = false) => {
  if (typeof key === "string" && isDotAccessible(key))
    return `${optional ? "?" : ""}.${key}`;
  return indexPropAccess(serializeLiteralKey(key), optional);
};
var serializeLiteralKey = (key) => typeof key === "symbol" ? registeredReference(key) : JSON.stringify(key);
var indexPropAccess = (key, optional = false) => `${optional ? "?." : ""}[${key}]`;

// node_modules/@ark/util/out/generics.js
var id = Symbol("id");

// node_modules/@ark/util/out/hkt.js
var Hkt;
(function(Hkt2) {
  class Kind {
  }
  Hkt2.Kind = Kind;
  class Instantiable {
  }
  Hkt2.Instantiable = Instantiable;
  Hkt2.reify = (def) => def.hkt;
  class UnaryKind {
  }
  Hkt2.UnaryKind = UnaryKind;
  Hkt2.pipe = (...kinds) => (In) => kinds.reduce((out, kind) => kind.hkt(out), In);
})(Hkt || (Hkt = {}));

// node_modules/@ark/util/out/numericLiterals.js
var wellFormedNumberMatcher = /^(?!^-0$)-?(?:0|[1-9]\d*)(?:\.\d*[1-9])?$/;
var isWellFormedNumber = wellFormedNumberMatcher.test.bind(wellFormedNumberMatcher);
var numberLikeMatcher = /^-?\d*\.?\d*$/;
var isNumberLike = (s) => s.length !== 0 && numberLikeMatcher.test(s);
var wellFormedIntegerMatcher = /^(?:0|(?:-?[1-9]\d*))$/;
var isWellFormedInteger = wellFormedIntegerMatcher.test.bind(wellFormedIntegerMatcher);
var integerLikeMatcher = /^-?\d+$/;
var isIntegerLike = integerLikeMatcher.test.bind(integerLikeMatcher);
var numericLiteralDescriptions = {
  number: "a number",
  bigint: "a bigint",
  integer: "an integer"
};
var writeMalformedNumericLiteralMessage = (def, kind) => `'${def}' was parsed as ${numericLiteralDescriptions[kind]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`;
var isWellFormed = (def, kind) => kind === "number" ? isWellFormedNumber(def) : isWellFormedInteger(def);
var parseKind = (def, kind) => kind === "number" ? Number(def) : Number.parseInt(def);
var isKindLike = (def, kind) => kind === "number" ? isNumberLike(def) : isIntegerLike(def);
var tryParseNumber = (token, options) => parseNumeric(token, "number", options);
var tryParseWellFormedNumber = (token, options) => parseNumeric(token, "number", { ...options, strict: true });
var tryParseInteger = (token, options) => parseNumeric(token, "integer", options);
var parseNumeric = (token, kind, options) => {
  const value = parseKind(token, kind);
  if (!Number.isNaN(value)) {
    if (isKindLike(token, kind)) {
      if (options == null ? void 0 : options.strict) {
        return isWellFormed(token, kind) ? value : throwParseError(writeMalformedNumericLiteralMessage(token, kind));
      }
      return value;
    }
  }
  return (options == null ? void 0 : options.errorOnFail) ? throwParseError((options == null ? void 0 : options.errorOnFail) === true ? `Failed to parse ${numericLiteralDescriptions[kind]} from '${token}'` : options == null ? void 0 : options.errorOnFail) : void 0;
};
var tryParseWellFormedBigint = (def) => {
  if (def[def.length - 1] !== "n")
    return;
  const maybeIntegerLiteral = def.slice(0, -1);
  let value;
  try {
    value = BigInt(maybeIntegerLiteral);
  } catch {
    return;
  }
  if (wellFormedIntegerMatcher.test(maybeIntegerLiteral))
    return value;
  if (integerLikeMatcher.test(maybeIntegerLiteral)) {
    return throwParseError(writeMalformedNumericLiteralMessage(def, "bigint"));
  }
};

// node_modules/@ark/util/out/serialize.js
var printable = (data, indent) => {
  switch (domainOf(data)) {
    case "object":
      const o = data;
      const ctorName = o.constructor.name;
      return ctorName === "Object" || ctorName === "Array" ? JSON.stringify(_serialize(o, printableOpts, []), null, indent) : o instanceof Date ? o.toDateString() : typeof o.expression === "string" ? o.expression : ctorName;
    case "symbol":
      return printableOpts.onSymbol(data);
    default:
      return serializePrimitive(data);
  }
};
var printableOpts = {
  onCycle: () => "(cycle)",
  onSymbol: (v) => `Symbol(${register(v)})`,
  onFunction: (v) => `Function(${register(v)})`
};
var _serialize = (data, opts, seen) => {
  switch (domainOf(data)) {
    case "object": {
      if (typeof data === "function")
        return printableOpts.onFunction(data);
      if (seen.includes(data))
        return "(cycle)";
      const nextSeen = [...seen, data];
      if (Array.isArray(data))
        return data.map((item) => _serialize(item, opts, nextSeen));
      if (data instanceof Date)
        return data.toDateString();
      const result = {};
      for (const k in data)
        result[k] = _serialize(data[k], opts, nextSeen);
      return result;
    }
    case "symbol":
      return printableOpts.onSymbol(data);
    case "bigint":
      return `${data}n`;
    case "undefined":
      return opts.onUndefined ?? "undefined";
    default:
      return data;
  }
};

// node_modules/@ark/util/out/strings.js
var capitalize = (s) => s[0].toUpperCase() + s.slice(1);
var escapeToken = "\\";
var whiteSpaceTokens = {
  " ": true,
  "\n": true,
  "	": true
};

// node_modules/@ark/util/out/traits.js
var implementedTraits = Symbol("implementedTraits");

// node_modules/@ark/schema/out/shared/utils.js
var makeRootAndArrayPropertiesMutable = (o) => (
  // this cast should not be required, but it seems TS is referencing
  // the wrong parameters here?
  flatMorph(o, (k, v) => [k, isArray(v) ? [...v] : v])
);
var pathToPropString = (path, ...[opts]) => {
  const stringifySymbol = (opts == null ? void 0 : opts.stringifySymbol) ?? printable;
  const propAccessChain = path.reduce((s, k) => {
    switch (typeof k) {
      case "string":
        return isDotAccessible(k) ? `${s}.${k}` : `${s}[${JSON.stringify(k)}]`;
      case "number":
        return `${s}[${k}]`;
      case "symbol":
        return `${s}[${stringifySymbol(k)}]`;
      default:
        if (opts == null ? void 0 : opts.stringifyNonKey)
          return `${s}[${opts.stringifyNonKey(k)}]`;
        throwParseError(`${printable(k)} must be a PropertyKey or stringifyNonKey must be passed to options`);
    }
  }, "");
  return propAccessChain[0] === "." ? propAccessChain.slice(1) : propAccessChain;
};
var arkKind = Symbol("ArkTypeInternalKind");
var hasArkKind = (value, kind) => (value == null ? void 0 : value[arkKind]) === kind;
var isNode = (value) => hasArkKind(value, "root") || hasArkKind(value, "constraint");
var inferred = Symbol("inferred");

// node_modules/@ark/schema/out/shared/implement.js
var basisKinds = ["unit", "proto", "domain"];
var structuralKinds = [
  "required",
  "optional",
  "index",
  "sequence"
];
var refinementKinds = [
  "pattern",
  "divisor",
  "exactLength",
  "max",
  "min",
  "maxLength",
  "minLength",
  "before",
  "after"
];
var constraintKinds = [
  ...refinementKinds,
  ...structuralKinds,
  "structure",
  "predicate"
];
var rootKinds = [
  "alias",
  "union",
  "morph",
  "unit",
  "intersection",
  "proto",
  "domain"
];
var nodeKinds = [...rootKinds, ...constraintKinds];
var constraintKeys = flatMorph(constraintKinds, (i, kind) => [kind, 1]);
var structureKeys = flatMorph([...structuralKinds, "undeclared"], (i, k) => [k, 1]);
var precedenceByKind = flatMorph(nodeKinds, (i, kind) => [kind, i]);
var isNodeKind = (value) => typeof value === "string" && value in precedenceByKind;
var precedenceOfKind = (kind) => precedenceByKind[kind];
var schemaKindsRightOf = (kind) => rootKinds.slice(precedenceOfKind(kind) + 1);
var defaultValueSerializer = (v) => {
  if (typeof v === "string" || typeof v === "boolean" || typeof v === "number" || v === null)
    return v;
  return compileSerializedValue(v);
};
var compileErrorContext = (ctx) => {
  let result = "{ ";
  for (const [k, v] of Object.entries(ctx))
    result += `${k}: ${compileSerializedValue(v)}, `;
  return result + " }";
};
var baseKeys = {
  description: { meta: true }
};
var implementNode = (_) => {
  var _a5, _b3, _c, _d;
  const implementation = _;
  if (implementation.hasAssociatedError) {
    (_a5 = implementation.defaults).expected ?? (_a5.expected = (ctx) => "description" in ctx ? ctx.description : implementation.defaults.description(ctx));
    (_b3 = implementation.defaults).actual ?? (_b3.actual = (data) => printable(data));
    (_c = implementation.defaults).problem ?? (_c.problem = (ctx) => `must be ${ctx.expected}${ctx.actual ? ` (was ${ctx.actual})` : ""}`);
    (_d = implementation.defaults).message ?? (_d.message = (ctx) => {
      if (ctx.path.length === 0)
        return ctx.problem;
      const problemWithLocation = `${ctx.propString} ${ctx.problem}`;
      if (problemWithLocation[0] === "[") {
        return `value at ${problemWithLocation}`;
      }
      return problemWithLocation;
    });
  }
  Object.assign(implementation.keys, baseKeys);
  return implementation;
};

// node_modules/@ark/schema/out/config.js
$ark.config = {};
var mergeConfigs = (base, extensions) => {
  const result = { ...base };
  let k;
  for (k in extensions) {
    result[k] = isNodeKind(k) ? {
      ...base[k],
      ...extensions[k]
    } : extensions[k];
  }
  return result;
};
var nonInheritedKeys = [
  "intrinsic",
  "prereducedAliases"
];
var extendConfig = (base, extension) => {
  if (!extension)
    return base;
  const result = mergeConfigs(base, extension);
  nonInheritedKeys.forEach((k) => {
    if (!(k in extension))
      delete result[k];
  });
  return result;
};
var resolveConfig = (config) => extendConfig(extendConfig($ark.defaultConfig, $ark.config), config);

// node_modules/@ark/schema/out/shared/errors.js
var _a, _b;
var ArkError = class extends (_b = CastableBase, _a = arkKind, _b) {
  constructor(input, ctx) {
    super();
    __publicField(this, "input");
    __publicField(this, _a, "error");
    __publicField(this, "path");
    __publicField(this, "data");
    __publicField(this, "nodeConfig");
    this.input = input;
    defineProperties(this, input);
    const data = ctx.data;
    if (input.code === "union") {
      input.errors = input.errors.flatMap((e) => e.hasCode("union") ? e.errors : e);
    }
    this.nodeConfig = ctx.config[this.code];
    this.path = input.path ?? [...ctx.path];
    if (input.relativePath)
      this.path.push(...input.relativePath);
    this.data = "data" in input ? input.data : data;
  }
  hasCode(code) {
    return this.code === code;
  }
  get propString() {
    return pathToPropString(this.path);
  }
  get expected() {
    var _a5, _b3;
    return this.input.expected ?? ((_b3 = (_a5 = this.nodeConfig).expected) == null ? void 0 : _b3.call(_a5, this.input));
  }
  get actual() {
    var _a5, _b3;
    return this.input.actual !== void 0 ? this.input.actual : (_b3 = (_a5 = this.nodeConfig).actual) == null ? void 0 : _b3.call(_a5, this.data);
  }
  get problem() {
    return this.input.problem ?? this.nodeConfig.problem(this);
  }
  get message() {
    return this.input.message ?? this.nodeConfig.message(this);
  }
  toString() {
    return this.message;
  }
  throw() {
    throw this;
  }
};
var ArkErrors = class extends ReadonlyArray {
  constructor(ctx) {
    super();
    __publicField(this, "ctx");
    __publicField(this, "byPath", {});
    __publicField(this, "count", 0);
    __publicField(this, "mutable", this);
    this.ctx = ctx;
  }
  add(error) {
    const existing = this.byPath[error.propString];
    if (existing) {
      const errorIntersection = new ArkError({
        code: "intersection",
        errors: existing.hasCode("intersection") ? [...existing.errors, error] : [existing, error]
      }, this.ctx);
      const existingIndex = this.indexOf(existing);
      this.mutable[existingIndex === -1 ? this.length : existingIndex] = errorIntersection;
      this.byPath[error.propString] = errorIntersection;
    } else {
      this.byPath[error.propString] = error;
      this.mutable.push(error);
    }
    this.count++;
  }
  get summary() {
    return this.toString();
  }
  get message() {
    return this.toString();
  }
  toString() {
    return this.join("\n");
  }
  throw() {
    throw new AggregateError(this, this.message);
  }
};

// node_modules/@ark/schema/out/shared/traversal.js
var TraversalContext = class {
  constructor(root2, config) {
    __publicField(this, "root");
    __publicField(this, "config");
    __publicField(this, "path", []);
    __publicField(this, "queuedMorphs", []);
    __publicField(this, "errors", new ArkErrors(this));
    __publicField(this, "branches", []);
    __publicField(this, "seen", {});
    this.root = root2;
    this.config = config;
  }
  get currentBranch() {
    return this.branches.at(-1);
  }
  queueMorphs(morphs) {
    var _a5;
    const input = {
      path: [...this.path],
      morphs
    };
    ((_a5 = this.currentBranch) == null ? void 0 : _a5.queuedMorphs.push(input)) ?? this.queuedMorphs.push(input);
  }
  finalize() {
    if (this.hasError())
      return this.errors;
    while (this.queuedMorphs.length) {
      const { path, morphs } = this.queuedMorphs.shift();
      const key = path.at(-1);
      let parent;
      if (key !== void 0) {
        parent = this.root;
        for (let pathIndex = 0; pathIndex < path.length - 1; pathIndex++)
          parent = parent[path[pathIndex]];
      }
      this.path = path;
      for (const morph of morphs) {
        const result = morph(parent === void 0 ? this.root : parent[key], this);
        if (result instanceof ArkErrors)
          return result;
        if (this.hasError())
          return this.errors;
        if (result instanceof ArkError) {
          this.error(result);
          return this.errors;
        }
        if (parent === void 0)
          this.root = result;
        else
          parent[key] = result;
      }
    }
    return this.root;
  }
  get currentErrorCount() {
    return this.currentBranch ? this.currentBranch.error ? 1 : 0 : this.errors.count;
  }
  hasError() {
    return this.currentErrorCount !== 0;
  }
  get failFast() {
    return this.branches.length !== 0;
  }
  error(input) {
    const errCtx = typeof input === "object" ? input.code ? input : { ...input, code: "predicate" } : { code: "predicate", expected: input };
    const error = new ArkError(errCtx, this);
    if (this.currentBranch)
      this.currentBranch.error = error;
    else
      this.errors.add(error);
    return error;
  }
  get data() {
    let result = this.root;
    for (const segment of this.path)
      result = result == null ? void 0 : result[segment];
    return result;
  }
  reject(input) {
    this.error(input);
    return false;
  }
  mustBe(expected) {
    this.error(expected);
    return false;
  }
  pushBranch() {
    this.branches.push({
      error: void 0,
      queuedMorphs: []
    });
  }
  popBranch() {
    return this.branches.pop();
  }
};

// node_modules/@ark/schema/out/node.js
var __runInitializers = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var BaseNode = (() => {
  var _a5;
  let _classSuper = Callable;
  let _instanceExtraInitializers = [];
  let _get_description_decorators;
  let _get_shallowReferences_decorators;
  let _get_shallowMorphs_decorators;
  let _get_flatRefs_decorators;
  let _get_in_decorators;
  let _get_out_decorators;
  return _a5 = class extends _classSuper {
    constructor(attachments, $2) {
      super(
        // pipedFromCtx allows us internally to reuse TraversalContext
        // through pipes and keep track of piped paths. It is not exposed
        (data, pipedFromCtx) => {
          if (!this.includesMorph && !this.allowsRequiresContext && this.allows(data))
            return data;
          if (pipedFromCtx) {
            this.traverseApply(data, pipedFromCtx);
            return pipedFromCtx.data;
          }
          const ctx = new TraversalContext(data, this.$.resolvedConfig);
          this.traverseApply(data, ctx);
          return ctx.finalize();
        },
        { attach: attachments }
      );
      __publicField(this, "attachments", __runInitializers(this, _instanceExtraInitializers));
      __publicField(this, "$");
      __publicField(this, "includesMorph", this.kind === "morph" || this.hasKind("optional") && this.hasDefault() || this.hasKind("structure") && this.undeclared === "delete" || this.children.some((child) => child.includesMorph));
      // if a predicate accepts exactly one arg, we can safely skip passing context
      __publicField(this, "allowsRequiresContext", this.hasKind("predicate") && this.inner.predicate.length !== 1 || this.kind === "alias" || this.children.some((child) => child.allowsRequiresContext));
      __publicField(this, "referencesById", this.children.reduce((result, child) => Object.assign(result, child.referencesById), { [this.id]: this }));
      __publicField(this, "precedence", precedenceOfKind(this.kind));
      __publicField(this, "jit", false);
      __publicField(this, "allows", (data) => {
        if (this.allowsRequiresContext) {
          return this.traverseAllows(data, new TraversalContext(data, this.$.resolvedConfig));
        }
        return this.traverseAllows(data);
      });
      this.attachments = attachments;
      this.$ = $2;
    }
    bindScope($2) {
      if (this.$ === $2)
        return this;
      return new this.constructor(this.attachments, $2);
    }
    get description() {
      var _a6, _b3;
      const writer = ((_a6 = this.$) == null ? void 0 : _a6.resolvedConfig[this.kind].description) ?? ((_b3 = $ark.config[this.kind]) == null ? void 0 : _b3.description) ?? $ark.defaultConfig[this.kind].description;
      return this.inner.description ?? writer(this);
    }
    // we don't cache this currently since it can be updated once a scope finishes
    // resolving cyclic references, although it may be possible to ensure it is cached safely
    get references() {
      return Object.values(this.referencesById).filter((ref) => !ref.id.startsWith("this"));
    }
    get shallowReferences() {
      return this.hasKind("structure") ? [this, ...this.children] : this.children.reduce((acc, child) => appendUniqueNodes(acc, child.shallowReferences), [this]);
    }
    get shallowMorphs() {
      return this.shallowReferences.filter((n) => n.hasKind("morph")).sort((l, r) => l.expression < r.expression ? -1 : 1);
    }
    // overriden by structural kinds so that only the root at each path is added
    get flatRefs() {
      return this.children.reduce((acc, child) => appendUniqueFlatRefs(acc, child.flatRefs), []).sort((l, r) => l.path.length > r.path.length ? 1 : l.path.length < r.path.length ? -1 : l.propString > r.propString ? 1 : l.propString < r.propString ? -1 : l.node.expression < r.node.expression ? -1 : 1);
    }
    traverse(data) {
      return this(data);
    }
    get in() {
      return this.getIo("in");
    }
    get out() {
      return this.getIo("out");
    }
    // Should be refactored to use transform
    // https://github.com/arktypeio/arktype/issues/1020
    getIo(kind) {
      if (!this.includesMorph)
        return this;
      const ioInner = {};
      for (const [k, v] of this.entries) {
        const keySchemaImplementation = this.impl.keys[k];
        if (keySchemaImplementation.meta)
          continue;
        if (keySchemaImplementation.child) {
          const childValue = v;
          ioInner[k] = isArray(childValue) ? childValue.map((child) => child[kind]) : childValue[kind];
        } else
          ioInner[k] = v;
      }
      return this.$.node(this.kind, ioInner);
    }
    toJSON() {
      return this.json;
    }
    toString() {
      return this.expression;
    }
    equals(other) {
      return this.typeHash === other.typeHash;
    }
    assertHasKind(kind) {
      if (!this.kind === kind)
        throwError(`${this.kind} node was not of asserted kind ${kind}`);
      return this;
    }
    hasKind(kind) {
      return this.kind === kind;
    }
    isBasis() {
      return includes(basisKinds, this.kind);
    }
    isConstraint() {
      return includes(constraintKinds, this.kind);
    }
    isStructural() {
      return includes(structuralKinds, this.kind);
    }
    isRefinement() {
      return includes(refinementKinds, this.kind);
    }
    isRoot() {
      return includes(rootKinds, this.kind);
    }
    hasUnit(value) {
      return this.hasKind("unit") && this.allows(value);
    }
    hasOpenIntersection() {
      return this.impl.intersectionIsOpen;
    }
    get nestableExpression() {
      return this.expression;
    }
    firstReference(filter) {
      return this.references.find((n) => n !== this && filter(n));
    }
    firstReferenceOrThrow(filter) {
      return this.firstReference(filter) ?? throwError(`${this.id} had no references matching predicate ${filter}`);
    }
    firstReferenceOfKind(kind) {
      return this.firstReference((node2) => node2.hasKind(kind));
    }
    firstReferenceOfKindOrThrow(kind) {
      return this.firstReference((node2) => node2.kind === kind) ?? throwError(`${this.id} had no ${kind} references`);
    }
    transform(mapper, opts) {
      return this._transform(mapper, {
        ...opts,
        seen: {},
        path: [],
        parseOptions: {
          prereduced: (opts == null ? void 0 : opts.prereduced) ?? false
        }
      });
    }
    _transform(mapper, ctx) {
      var _a6, _b3;
      const $2 = ((_a6 = ctx.bindScope) == null ? void 0 : _a6.internal) ?? this.$;
      if (ctx.seen[this.id])
        return this.$.lazilyResolve(ctx.seen[this.id]);
      if (((_b3 = ctx.shouldTransform) == null ? void 0 : _b3.call(ctx, this, ctx)) === false)
        return this;
      let transformedNode;
      ctx.seen[this.id] = () => transformedNode;
      const innerWithTransformedChildren = flatMorph(this.inner, (k, v) => {
        if (!this.impl.keys[k].child)
          return [k, v];
        const children = v;
        if (!isArray(children)) {
          const transformed2 = children._transform(mapper, ctx);
          return transformed2 ? [k, transformed2] : [];
        }
        if (children.length === 0)
          return [k, v];
        const transformed = children.flatMap((n) => {
          const transformedChild = n._transform(mapper, ctx);
          return transformedChild ?? [];
        });
        return transformed.length ? [k, transformed] : [];
      });
      delete ctx.seen[this.id];
      const transformedInner = mapper(this.kind, innerWithTransformedChildren, ctx);
      if (transformedInner === null)
        return null;
      if (isNode(transformedInner))
        return transformedNode = transformedInner;
      if (isEmptyObject(transformedInner) && // if inner was previously an empty object (e.g. unknown) ensure it is not pruned
      !isEmptyObject(this.inner))
        return null;
      if ((this.kind === "required" || this.kind === "optional" || this.kind === "index") && !("value" in transformedInner))
        return null;
      if (this.kind === "morph") {
        ;
        transformedInner.in ?? (transformedInner.in = $ark.intrinsic.unknown);
      }
      return transformedNode = $2.node(this.kind, transformedInner, ctx.parseOptions);
    }
    configureShallowDescendants(configOrDescription) {
      const config = typeof configOrDescription === "string" ? { description: configOrDescription } : configOrDescription;
      return this.transform((kind, inner) => ({ ...inner, ...config }), {
        shouldTransform: (node2) => node2.kind !== "structure"
      });
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _get_description_decorators = [cached];
    _get_shallowReferences_decorators = [cached];
    _get_shallowMorphs_decorators = [cached];
    _get_flatRefs_decorators = [cached];
    _get_in_decorators = [cached];
    _get_out_decorators = [cached];
    __esDecorate(_a5, null, _get_description_decorators, { kind: "getter", name: "description", static: false, private: false, access: { has: (obj) => "description" in obj, get: (obj) => obj.description }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a5, null, _get_shallowReferences_decorators, { kind: "getter", name: "shallowReferences", static: false, private: false, access: { has: (obj) => "shallowReferences" in obj, get: (obj) => obj.shallowReferences }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a5, null, _get_shallowMorphs_decorators, { kind: "getter", name: "shallowMorphs", static: false, private: false, access: { has: (obj) => "shallowMorphs" in obj, get: (obj) => obj.shallowMorphs }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a5, null, _get_flatRefs_decorators, { kind: "getter", name: "flatRefs", static: false, private: false, access: { has: (obj) => "flatRefs" in obj, get: (obj) => obj.flatRefs }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a5, null, _get_in_decorators, { kind: "getter", name: "in", static: false, private: false, access: { has: (obj) => "in" in obj, get: (obj) => obj.in }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a5, null, _get_out_decorators, { kind: "getter", name: "out", static: false, private: false, access: { has: (obj) => "out" in obj, get: (obj) => obj.out }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_a5, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a5;
})();
var typePathToPropString = (path) => pathToPropString(path, {
  stringifyNonKey: (node2) => node2.expression
});
var flatRef = (path, node2) => ({
  path,
  node: node2,
  propString: typePathToPropString(path)
});
var flatRefsAreEqual = (l, r) => l.propString === r.propString && l.node.equals(r.node);
var appendUniqueFlatRefs = (existing, refs) => appendUnique(existing, refs, {
  isEqual: flatRefsAreEqual
});
var appendUniqueNodes = (existing, refs) => appendUnique(existing, refs, {
  isEqual: (l, r) => l.equals(r)
});

// node_modules/@ark/schema/out/shared/disjoint.js
var Disjoint = class _Disjoint extends Array {
  static init(kind, l, r, ctx) {
    return new _Disjoint({
      kind,
      l,
      r,
      path: (ctx == null ? void 0 : ctx.path) ?? [],
      optional: (ctx == null ? void 0 : ctx.optional) ?? false
    });
  }
  add(kind, l, r, ctx) {
    this.push({
      kind,
      l,
      r,
      path: (ctx == null ? void 0 : ctx.path) ?? [],
      optional: (ctx == null ? void 0 : ctx.optional) ?? false
    });
    return this;
  }
  describeReasons() {
    if (this.length === 1) {
      const { path, l, r } = this[0];
      const pathString = pathToPropString(path);
      return `Intersection${pathString && ` at ${pathString}`} of ${describeReasons(l, r)} results in an unsatisfiable type`;
    }
    return `The following intersections result in unsatisfiable types:
• ${this.map(({ path, l, r }) => `${path}: ${describeReasons(l, r)}`).join("\n• ")}`;
  }
  throw() {
    return throwParseError(this.describeReasons());
  }
  invert() {
    return this.map((entry) => ({
      ...entry,
      l: entry.r,
      r: entry.l
    }));
  }
  withPrefixKey(key, kind) {
    return this.map((entry) => ({
      ...entry,
      path: [key, ...entry.path],
      optional: entry.optional || kind === "optional"
    }));
  }
};
var describeReasons = (l, r) => `${describeReason(l)} and ${describeReason(r)}`;
var describeReason = (value) => hasArkKind(value, "root") ? value.expression : isArray(value) ? value.map(describeReason).join(" | ") : String(value);

// node_modules/@ark/schema/out/shared/intersections.js
var intersectionCache = {};
var intersectNodesRoot = (l, r, $2) => intersectNodes(l, r, {
  $: $2,
  invert: false,
  pipe: false
});
var pipeNodesRoot = (l, r, $2) => intersectNodes(l, r, {
  $: $2,
  invert: false,
  pipe: true
});
var intersectNodes = (l, r, ctx) => {
  const operator = ctx.pipe ? "|>" : "&";
  const lrCacheKey = `${l.typeHash}${operator}${r.typeHash}`;
  if (intersectionCache[lrCacheKey] !== void 0)
    return intersectionCache[lrCacheKey];
  if (!ctx.pipe) {
    const rlCacheKey = `${r.typeHash}${operator}${l.typeHash}`;
    if (intersectionCache[rlCacheKey] !== void 0) {
      const rlResult = intersectionCache[rlCacheKey];
      const lrResult = rlResult instanceof Disjoint ? rlResult.invert() : rlResult;
      intersectionCache[lrCacheKey] = lrResult;
      return lrResult;
    }
  }
  if (l.equals(r))
    return l;
  let result;
  if (ctx.pipe && l.kind !== "union" && r.kind !== "union") {
    if (l.includesMorph) {
      if (l.hasKind("morph")) {
        result = ctx.invert ? pipeToMorph(r, l, ctx) : pipeFromMorph(l, r, ctx);
      } else {
        result = ctx.$.node("morph", {
          morphs: [r],
          in: l
        });
      }
    } else if (r.includesMorph) {
      if (!r.hasKind("morph")) {
        result = ctx.$.node("morph", {
          morphs: [r],
          in: l
        });
      } else {
        result = ctx.invert ? pipeFromMorph(r, l, ctx) : pipeToMorph(l, r, ctx);
      }
    }
  }
  if (!result) {
    const leftmostKind = l.precedence < r.precedence ? l.kind : r.kind;
    const implementation = l.impl.intersections[r.kind] ?? r.impl.intersections[l.kind];
    if (implementation === void 0) {
      result = null;
    } else if (leftmostKind === l.kind)
      result = implementation(l, r, ctx);
    else {
      result = implementation(r, l, { ...ctx, invert: !ctx.invert });
      if (result instanceof Disjoint)
        result = result.invert();
    }
  }
  if (isNode(result)) {
    if (l.equals(result))
      result = l;
    else if (r.equals(result))
      result = r;
  }
  intersectionCache[lrCacheKey] = result;
  return result;
};
var pipeFromMorph = (from, to, ctx) => {
  const morphs = [...from.morphs];
  if (from.validatedOut) {
    const outIntersection = intersectNodes(from.validatedOut, to, ctx);
    if (outIntersection instanceof Disjoint)
      return outIntersection;
    morphs[morphs.length - 1] = outIntersection;
  } else
    morphs.push(to);
  return ctx.$.node("morph", {
    morphs,
    in: from.in
  });
};
var pipeToMorph = (from, to, ctx) => {
  const result = intersectNodes(from, to.in, ctx);
  if (result instanceof Disjoint)
    return result;
  return ctx.$.node("morph", {
    morphs: to.morphs,
    in: result
  });
};

// node_modules/@ark/schema/out/constraint.js
var _a2, _b2;
var BaseConstraint = class extends (_b2 = BaseNode, _a2 = arkKind, _b2) {
  constructor() {
    super(...arguments);
    __publicField(this, _a2, "constraint");
    __publicField(this, "impliedSiblings");
  }
  intersect(r) {
    return intersectNodesRoot(this, r, this.$);
  }
};
var RawPrimitiveConstraint = class extends BaseConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "traverseApply", (data, ctx) => {
      if (!this.traverseAllows(data, ctx))
        ctx.error(this.errorContext);
    });
  }
  compile(js) {
    if (js.traversalKind === "Allows")
      js.return(this.compiledCondition);
    else {
      js.if(this.compiledNegation, () => js.line(`${js.ctx}.error(${this.compiledErrorContext})`));
    }
  }
  get errorContext() {
    return { code: this.kind, description: this.description, ...this.inner };
  }
  get compiledErrorContext() {
    return compileErrorContext(this.errorContext);
  }
};
var constraintKeyParser = (kind) => (schema2, ctx) => {
  if (isArray(schema2)) {
    if (schema2.length === 0) {
      return;
    }
    const nodes = schema2.map((schema3) => ctx.$.node(kind, schema3));
    if (kind === "predicate")
      return nodes;
    return nodes.sort((l, r) => l.innerHash < r.innerHash ? -1 : 1);
  }
  const child = ctx.$.node(kind, schema2);
  return child.hasOpenIntersection() ? [child] : child;
};
var intersectConstraints = (s) => {
  var _a5;
  const head = s.r.shift();
  if (!head) {
    let result = s.l.length === 0 && s.kind === "structure" ? $ark.intrinsic.unknown.internal : s.ctx.$.node(s.kind, Object.assign(s.baseInner, unflattenConstraints(s.l)), { prereduced: true });
    for (const root2 of s.roots) {
      if (result instanceof Disjoint)
        return result;
      result = intersectNodes(root2, result, s.ctx);
    }
    return result;
  }
  let matched = false;
  for (let i = 0; i < s.l.length; i++) {
    const result = intersectNodes(s.l[i], head, s.ctx);
    if (result === null)
      continue;
    if (result instanceof Disjoint)
      return result;
    if (!matched) {
      if (result.isRoot()) {
        s.roots.push(result);
        s.l.splice(i);
        return intersectConstraints(s);
      }
      s.l[i] = result;
      matched = true;
    } else if (!s.l.includes(result)) {
      return throwInternalError(`Unexpectedly encountered multiple distinct intersection results for refinement ${result}`);
    }
  }
  if (!matched)
    s.l.push(head);
  if (s.kind === "intersection")
    (_a5 = head.impliedSiblings) == null ? void 0 : _a5.forEach((node2) => appendUnique(s.r, node2));
  return intersectConstraints(s);
};
var flattenConstraints = (inner) => {
  const result = Object.entries(inner).flatMap(([k, v]) => k in constraintKeys ? v : []).sort((l, r) => l.precedence < r.precedence ? -1 : l.precedence > r.precedence ? 1 : l.kind === "predicate" && r.kind === "predicate" ? 0 : l.innerHash < r.innerHash ? -1 : 1);
  return result;
};
var unflattenConstraints = (constraints) => {
  const inner = {};
  for (const constraint of constraints) {
    if (constraint.hasOpenIntersection()) {
      inner[constraint.kind] = append(inner[constraint.kind], constraint);
    } else {
      if (inner[constraint.kind]) {
        return throwInternalError(`Unexpected intersection of closed refinements of kind ${constraint.kind}`);
      }
      inner[constraint.kind] = constraint;
    }
  }
  return inner;
};
var throwInvalidOperandError = (...args) => throwParseError(writeInvalidOperandMessage(...args));
var writeInvalidOperandMessage = (kind, expected, actual) => `${capitalize(kind)} operand must be ${expected.description} (was ${actual.exclude(expected).description})`;

// node_modules/@ark/schema/out/generic.js
var __runInitializers2 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate2 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var parseGeneric = (paramDefs, bodyDef, $2) => new GenericRoot(paramDefs, bodyDef, $2, $2);
var LazyGenericRoot = class extends Callable {
};
var GenericRoot = (() => {
  var _a5, _b3, _c;
  let _classSuper = Callable;
  let _instanceExtraInitializers = [];
  let _get_params_decorators;
  let _get_names_decorators;
  let _get_constraints_decorators;
  let _get_baseInstantiation_decorators;
  return _c = class extends (_b3 = _classSuper, _a5 = arkKind, _b3) {
    constructor(paramDefs, bodyDef, _$, _arg$) {
      super((...args) => {
        const argNodes = flatMorph(this.names, (i, name) => {
          const arg = this.arg$.parseRoot(args[i]);
          if (!arg.extends(this.constraints[i])) {
            throwParseError(writeUnsatisfiedParameterConstraintMessage(name, this.constraints[i].expression, arg.expression));
          }
          return [name, arg];
        });
        if (bodyDef instanceof LazyGenericRoot)
          return this.$.parseRoot(bodyDef(argNodes));
        return this.$.parseRoot(bodyDef, { args: argNodes });
      });
      __publicField(this, "paramDefs", __runInitializers2(this, _instanceExtraInitializers));
      __publicField(this, "bodyDef");
      __publicField(this, "_$");
      __publicField(this, "_arg$");
      __publicField(this, _a5, "generic");
      this.paramDefs = paramDefs;
      this.bodyDef = bodyDef;
      this._$ = _$;
      this._arg$ = _arg$;
      if (!isThunk(this._$))
        this.validateBaseInstantiation();
    }
    get $() {
      return isThunk(this._$) ? this._$() : this._$;
    }
    get arg$() {
      return isThunk(this._arg$) ? this._arg$() : this._arg$;
    }
    bindScope($2) {
      if (this.arg$ === $2)
        return this;
      return new _c(this.params, this.bodyDef, this.$, $2);
    }
    get params() {
      return this.paramDefs.map((param) => typeof param === "string" ? [param, $ark.intrinsic.unknown] : [param[0], this.$.parseRoot(param[1])]);
    }
    get names() {
      return this.params.map((e) => e[0]);
    }
    get constraints() {
      return this.params.map((e) => e[1]);
    }
    get baseInstantiation() {
      return this(...this.constraints);
    }
    validateBaseInstantiation() {
      this.baseInstantiation;
      return this;
    }
    get internal() {
      return this;
    }
    get references() {
      return this.baseInstantiation.internal.references;
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _get_params_decorators = [cached];
    _get_names_decorators = [cached];
    _get_constraints_decorators = [cached];
    _get_baseInstantiation_decorators = [cached];
    __esDecorate2(_c, null, _get_params_decorators, { kind: "getter", name: "params", static: false, private: false, access: { has: (obj) => "params" in obj, get: (obj) => obj.params }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_c, null, _get_names_decorators, { kind: "getter", name: "names", static: false, private: false, access: { has: (obj) => "names" in obj, get: (obj) => obj.names }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_c, null, _get_constraints_decorators, { kind: "getter", name: "constraints", static: false, private: false, access: { has: (obj) => "constraints" in obj, get: (obj) => obj.constraints }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_c, null, _get_baseInstantiation_decorators, { kind: "getter", name: "baseInstantiation", static: false, private: false, access: { has: (obj) => "baseInstantiation" in obj, get: (obj) => obj.baseInstantiation }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_c, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _c;
})();
var writeUnsatisfiedParameterConstraintMessage = (name, constraint, arg) => `${name} must be assignable to ${constraint} (was ${arg})`;

// node_modules/@ark/schema/out/predicate.js
var predicateImplementation = implementNode({
  kind: "predicate",
  hasAssociatedError: true,
  collapsibleKey: "predicate",
  keys: {
    predicate: {}
  },
  normalize: (schema2) => typeof schema2 === "function" ? { predicate: schema2 } : schema2,
  defaults: {
    description: (node2) => `valid according to ${node2.predicate.name || "an anonymous predicate"}`
  },
  intersectionIsOpen: true,
  intersections: {
    // as long as the narrows in l and r are individually safe to check
    // in the order they're specified, checking them in the order
    // resulting from this intersection should also be safe.
    predicate: () => null
  }
});
var PredicateNode = class extends BaseConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "serializedPredicate", registeredReference(this.predicate));
    __publicField(this, "compiledCondition", `${this.serializedPredicate}(data, ctx)`);
    __publicField(this, "compiledNegation", `!${this.compiledCondition}`);
    __publicField(this, "impliedBasis", null);
    __publicField(this, "expression", this.serializedPredicate);
    __publicField(this, "traverseAllows", this.predicate);
    __publicField(this, "errorContext", {
      code: "predicate",
      description: this.description
    });
    __publicField(this, "compiledErrorContext", compileErrorContext(this.errorContext));
    __publicField(this, "traverseApply", (data, ctx) => {
      if (!this.predicate(data, ctx) && !ctx.hasError())
        ctx.error(this.errorContext);
    });
  }
  compile(js) {
    if (js.traversalKind === "Allows") {
      js.return(this.compiledCondition);
      return;
    }
    js.if(`${this.compiledNegation} && !ctx.hasError()`, () => js.line(`ctx.error(${this.compiledErrorContext})`));
  }
};

// node_modules/@ark/schema/out/refinements/divisor.js
var divisorImplementation = implementNode({
  kind: "divisor",
  collapsibleKey: "rule",
  keys: {
    rule: {}
  },
  normalize: (schema2) => typeof schema2 === "number" ? { rule: schema2 } : schema2,
  hasAssociatedError: true,
  defaults: {
    description: (node2) => node2.rule === 1 ? "an integer" : `a multiple of ${node2.rule}`
  },
  intersections: {
    divisor: (l, r, ctx) => ctx.$.node("divisor", {
      rule: Math.abs(l.rule * r.rule / greatestCommonDivisor(l.rule, r.rule))
    })
  }
});
var DivisorNode = class extends RawPrimitiveConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "traverseAllows", (data) => data % this.rule === 0);
    __publicField(this, "compiledCondition", `data % ${this.rule} === 0`);
    __publicField(this, "compiledNegation", `data % ${this.rule} !== 0`);
    __publicField(this, "impliedBasis", $ark.intrinsic.number);
    __publicField(this, "expression", `% ${this.rule}`);
  }
};
var greatestCommonDivisor = (l, r) => {
  let previous;
  let greatestCommonDivisor2 = l;
  let current = r;
  while (current !== 0) {
    previous = current;
    current = greatestCommonDivisor2 % current;
    greatestCommonDivisor2 = previous;
  }
  return greatestCommonDivisor2;
};

// node_modules/@ark/schema/out/refinements/range.js
var BaseRange = class extends RawPrimitiveConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "boundOperandKind", operandKindsByBoundKind[this.kind]);
    __publicField(this, "compiledActual", this.boundOperandKind === "value" ? `data` : this.boundOperandKind === "length" ? `data.length` : `data.valueOf()`);
    __publicField(this, "comparator", compileComparator(this.kind, this.exclusive));
    __publicField(this, "numericLimit", this.rule.valueOf());
    __publicField(this, "expression", `${this.comparator} ${this.rule}`);
    __publicField(this, "compiledCondition", `${this.compiledActual} ${this.comparator} ${this.numericLimit}`);
    __publicField(this, "compiledNegation", `${this.compiledActual} ${negatedComparators[this.comparator]} ${this.numericLimit}`);
    // we need to compute stringLimit before errorContext, which references it
    // transitively through description for date bounds
    __publicField(this, "stringLimit", this.boundOperandKind === "date" ? dateLimitToString(this.numericLimit) : `${this.numericLimit}`);
    __publicField(this, "limitKind", this.comparator["0"] === "<" ? "upper" : "lower");
  }
  isStricterThan(r) {
    const thisLimitIsStricter = this.limitKind === "upper" ? this.numericLimit < r.numericLimit : this.numericLimit > r.numericLimit;
    return thisLimitIsStricter || this.numericLimit === r.numericLimit && this.exclusive === true && !r.exclusive;
  }
  overlapsRange(r) {
    if (this.isStricterThan(r))
      return false;
    if (this.numericLimit === r.numericLimit && (this.exclusive || r.exclusive))
      return false;
    return true;
  }
  overlapIsUnit(r) {
    return this.numericLimit === r.numericLimit && !this.exclusive && !r.exclusive;
  }
};
var negatedComparators = {
  "<": ">=",
  "<=": ">",
  ">": "<=",
  ">=": "<"
};
var boundKindPairsByLower = {
  min: "max",
  minLength: "maxLength",
  after: "before"
};
var parseExclusiveKey = {
  // omit key with value false since it is the default
  parse: (flag) => flag || void 0
};
var parseDateLimit = (limit) => typeof limit === "string" || typeof limit === "number" ? new Date(limit) : limit;
var operandKindsByBoundKind = {
  min: "value",
  max: "value",
  minLength: "length",
  maxLength: "length",
  after: "date",
  before: "date"
};
var compileComparator = (kind, exclusive) => `${isKeyOf(kind, boundKindPairsByLower) ? ">" : "<"}${exclusive ? "" : "="}`;
var dateLimitToString = (limit) => typeof limit === "string" ? limit : new Date(limit).toLocaleString();
var writeUnboundableMessage = (root2) => `Bounded expression ${root2} must be a number, string, Array, or Date`;

// node_modules/@ark/schema/out/refinements/after.js
var afterImplementation = implementNode({
  kind: "after",
  collapsibleKey: "rule",
  hasAssociatedError: true,
  keys: {
    rule: {
      parse: parseDateLimit,
      serialize: (schema2) => schema2.toISOString()
    },
    exclusive: parseExclusiveKey
  },
  normalize: (schema2) => typeof schema2 === "number" || typeof schema2 === "string" || schema2 instanceof Date ? { rule: schema2 } : schema2,
  defaults: {
    description: (node2) => node2.exclusive ? `after ${node2.stringLimit}` : `${node2.stringLimit} or later`,
    actual: (data) => data.toLocaleString()
  },
  intersections: {
    after: (l, r) => l.isStricterThan(r) ? l : r
  }
});
var AfterNode = class extends BaseRange {
  constructor() {
    super(...arguments);
    __publicField(this, "impliedBasis", $ark.intrinsic.Date);
    __publicField(this, "traverseAllows", this.exclusive ? (data) => data > this.rule : (data) => data >= this.rule);
  }
};

// node_modules/@ark/schema/out/refinements/before.js
var beforeImplementation = implementNode({
  kind: "before",
  collapsibleKey: "rule",
  hasAssociatedError: true,
  keys: {
    rule: {
      parse: parseDateLimit,
      serialize: (schema2) => schema2.toISOString()
    },
    exclusive: parseExclusiveKey
  },
  normalize: (schema2) => typeof schema2 === "number" || typeof schema2 === "string" || schema2 instanceof Date ? { rule: schema2 } : schema2,
  defaults: {
    description: (node2) => node2.exclusive ? `before ${node2.stringLimit}` : `${node2.stringLimit} or earlier`,
    actual: (data) => data.toLocaleString()
  },
  intersections: {
    before: (l, r) => l.isStricterThan(r) ? l : r,
    after: (before, after, ctx) => before.overlapsRange(after) ? before.overlapIsUnit(after) ? ctx.$.node("unit", { unit: before.rule }) : null : Disjoint.init("range", before, after)
  }
});
var BeforeNode = class extends BaseRange {
  constructor() {
    super(...arguments);
    __publicField(this, "traverseAllows", this.exclusive ? (data) => data < this.rule : (data) => data <= this.rule);
    __publicField(this, "impliedBasis", $ark.intrinsic.Date);
  }
};

// node_modules/@ark/schema/out/refinements/exactLength.js
var exactLengthImplementation = implementNode({
  kind: "exactLength",
  collapsibleKey: "rule",
  keys: {
    rule: {}
  },
  normalize: (schema2) => typeof schema2 === "number" ? { rule: schema2 } : schema2,
  hasAssociatedError: true,
  defaults: {
    description: (node2) => `exactly length ${node2.rule}`,
    actual: (data) => `${data.length}`
  },
  intersections: {
    exactLength: (l, r, ctx) => Disjoint.init("unit", ctx.$.node("unit", { unit: l.rule }), ctx.$.node("unit", { unit: r.rule }), { path: ["length"] }),
    minLength: (exactLength, minLength) => (minLength.exclusive ? exactLength.rule > minLength.rule : exactLength.rule >= minLength.rule) ? exactLength : Disjoint.init("range", exactLength, minLength),
    maxLength: (exactLength, maxLength) => (maxLength.exclusive ? exactLength.rule < maxLength.rule : exactLength.rule <= maxLength.rule) ? exactLength : Disjoint.init("range", exactLength, maxLength)
  }
});
var ExactLengthNode = class extends RawPrimitiveConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "traverseAllows", (data) => data.length === this.rule);
    __publicField(this, "compiledCondition", `data.length === ${this.rule}`);
    __publicField(this, "compiledNegation", `data.length !== ${this.rule}`);
    __publicField(this, "impliedBasis", $ark.intrinsic.lengthBoundable);
    __publicField(this, "expression", `{ length: ${this.rule} }`);
  }
};

// node_modules/@ark/schema/out/refinements/max.js
var maxImplementation = implementNode({
  kind: "max",
  collapsibleKey: "rule",
  hasAssociatedError: true,
  keys: {
    rule: {},
    exclusive: parseExclusiveKey
  },
  normalize: (schema2) => typeof schema2 === "number" ? { rule: schema2 } : schema2,
  defaults: {
    description: (node2) => `${node2.exclusive ? "less than" : "at most"} ${node2.rule}`
  },
  intersections: {
    max: (l, r) => l.isStricterThan(r) ? l : r,
    min: (max, min, ctx) => max.overlapsRange(min) ? max.overlapIsUnit(min) ? ctx.$.node("unit", { unit: max.rule }) : null : Disjoint.init("range", max, min)
  }
});
var MaxNode = class extends BaseRange {
  constructor() {
    super(...arguments);
    __publicField(this, "impliedBasis", $ark.intrinsic.number);
    __publicField(this, "traverseAllows", this.exclusive ? (data) => data < this.rule : (data) => data <= this.rule);
  }
};

// node_modules/@ark/schema/out/refinements/maxLength.js
var maxLengthImplementation = implementNode({
  kind: "maxLength",
  collapsibleKey: "rule",
  hasAssociatedError: true,
  keys: {
    rule: {},
    exclusive: parseExclusiveKey
  },
  normalize: (schema2) => typeof schema2 === "number" ? { rule: schema2 } : schema2,
  defaults: {
    description: (node2) => node2.exclusive ? `less than length ${node2.rule}` : `at most length ${node2.rule}`,
    actual: (data) => `${data.length}`
  },
  intersections: {
    maxLength: (l, r) => l.isStricterThan(r) ? l : r,
    minLength: (max, min, ctx) => max.overlapsRange(min) ? max.overlapIsUnit(min) ? ctx.$.node("exactLength", { rule: max.rule }) : null : Disjoint.init("range", max, min)
  }
});
var MaxLengthNode = class extends BaseRange {
  constructor() {
    super(...arguments);
    __publicField(this, "impliedBasis", $ark.intrinsic.lengthBoundable);
    __publicField(this, "traverseAllows", this.exclusive ? (data) => data.length < this.rule : (data) => data.length <= this.rule);
  }
};

// node_modules/@ark/schema/out/refinements/min.js
var minImplementation = implementNode({
  kind: "min",
  collapsibleKey: "rule",
  hasAssociatedError: true,
  keys: {
    rule: {},
    exclusive: parseExclusiveKey
  },
  normalize: (schema2) => typeof schema2 === "number" ? { rule: schema2 } : schema2,
  defaults: {
    description: (node2) => `${node2.exclusive ? "more than" : "at least"} ${node2.rule}`
  },
  intersections: {
    min: (l, r) => l.isStricterThan(r) ? l : r
  }
});
var MinNode = class extends BaseRange {
  constructor() {
    super(...arguments);
    __publicField(this, "impliedBasis", $ark.intrinsic.number);
    __publicField(this, "traverseAllows", this.exclusive ? (data) => data > this.rule : (data) => data >= this.rule);
  }
};

// node_modules/@ark/schema/out/refinements/minLength.js
var minLengthImplementation = implementNode({
  kind: "minLength",
  collapsibleKey: "rule",
  hasAssociatedError: true,
  keys: {
    rule: {},
    exclusive: parseExclusiveKey
  },
  normalize: (schema2) => typeof schema2 === "number" ? { rule: schema2 } : schema2,
  defaults: {
    description: (node2) => node2.exclusive ? node2.rule === 0 ? "non-empty" : `more than length ${node2.rule}` : node2.rule === 1 ? "non-empty" : `at least length ${node2.rule}`,
    // avoid default message like "must be non-empty (was 0)"
    actual: (data) => data.length === 0 ? null : `${data.length}`
  },
  intersections: {
    minLength: (l, r) => l.isStricterThan(r) ? l : r
  }
});
var MinLengthNode = class extends BaseRange {
  constructor() {
    super(...arguments);
    __publicField(this, "impliedBasis", $ark.intrinsic.lengthBoundable);
    __publicField(this, "traverseAllows", this.exclusive ? (data) => data.length > this.rule : (data) => data.length >= this.rule);
  }
};

// node_modules/@ark/schema/out/refinements/kinds.js
var boundImplementationsByKind = {
  min: minImplementation,
  max: maxImplementation,
  minLength: minLengthImplementation,
  maxLength: maxLengthImplementation,
  exactLength: exactLengthImplementation,
  after: afterImplementation,
  before: beforeImplementation
};
var boundClassesByKind = {
  min: MinNode,
  max: MaxNode,
  minLength: MinLengthNode,
  maxLength: MaxLengthNode,
  exactLength: ExactLengthNode,
  after: AfterNode,
  before: BeforeNode
};

// node_modules/@ark/schema/out/refinements/pattern.js
var patternImplementation = implementNode({
  kind: "pattern",
  collapsibleKey: "rule",
  keys: {
    rule: {},
    flags: {}
  },
  normalize: (schema2) => typeof schema2 === "string" ? { rule: schema2 } : schema2 instanceof RegExp ? schema2.flags ? { rule: schema2.source, flags: schema2.flags } : { rule: schema2.source } : schema2,
  hasAssociatedError: true,
  intersectionIsOpen: true,
  defaults: {
    description: (node2) => `matched by ${node2.rule}`
  },
  intersections: {
    // for now, non-equal regex are naively intersected:
    // https://github.com/arktypeio/arktype/issues/853
    pattern: () => null
  }
});
var PatternNode = class extends RawPrimitiveConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "instance", new RegExp(this.rule, this.flags));
    __publicField(this, "expression", `${this.instance}`);
    __publicField(this, "traverseAllows", this.instance.test.bind(this.instance));
    __publicField(this, "compiledCondition", `${this.expression}.test(data)`);
    __publicField(this, "compiledNegation", `!${this.compiledCondition}`);
    __publicField(this, "impliedBasis", $ark.intrinsic.string);
  }
};

// node_modules/@ark/schema/out/roots/root.js
var __runInitializers3 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate3 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var BaseRoot = (() => {
  var _a5, _b3, _c;
  let _classSuper = BaseNode;
  let _instanceExtraInitializers = [];
  let _keyof_decorators;
  let _get_flatMorphs_decorators;
  return _c = class extends (_b3 = _classSuper, _a5 = arkKind, _b3) {
    constructor() {
      super(...arguments);
      __publicField(this, "branches", (__runInitializers3(this, _instanceExtraInitializers), this.hasKind("union") ? this.inner.branches : [this]));
      __publicField(this, _a5, "root");
    }
    get internal() {
      return this;
    }
    keyof() {
      const result = this.rawKeyOf();
      if (result.branches.length === 0) {
        throwParseError(`keyof ${this.expression} results in an unsatisfiable type`);
      }
      return result;
    }
    intersect(r) {
      const rNode = this.$.parseRoot(r);
      return intersectNodesRoot(this, rNode, this.$);
    }
    and(r) {
      const result = this.intersect(r);
      return result instanceof Disjoint ? result.throw() : result;
    }
    or(r) {
      const rNode = this.$.parseRoot(r);
      const branches = [...this.branches, ...rNode.branches];
      return this.$.schema(branches);
    }
    assert(data) {
      const result = this.traverse(data);
      return result instanceof ArkErrors ? result.throw() : result;
    }
    get(...[key, ...tail]) {
      var _a6;
      if (key === void 0)
        return this;
      if (hasArkKind(key, "root") && key.hasKind("unit"))
        key = key.unit;
      if (typeof key === "number")
        key = `${key}`;
      if (this.hasKind("union")) {
        return this.branches.reduce((acc, b) => acc.or(b.get(key, ...tail)), $ark.intrinsic.never);
      }
      return ((_a6 = this.structure) == null ? void 0 : _a6.get(key, ...tail)) ?? throwParseError(writeNonStructuralIndexAccessMessage(key));
    }
    extract(r) {
      const rNode = this.$.parseRoot(r);
      return this.$.schema(this.branches.filter((branch) => branch.extends(rNode)));
    }
    exclude(r) {
      const rNode = this.$.parseRoot(r);
      return this.$.schema(this.branches.filter((branch) => !branch.extends(rNode)));
    }
    array() {
      return this.$.schema({
        proto: Array,
        sequence: this
      }, { prereduced: true });
    }
    overlaps(r) {
      const intersection = this.intersect(r);
      return !(intersection instanceof Disjoint);
    }
    extends(r) {
      const intersection = this.intersect(r);
      return !(intersection instanceof Disjoint) && this.equals(intersection);
    }
    subsumes(r) {
      return r.extends(this);
    }
    includes(r) {
      return hasArkKind(r, "root") ? r.extends(this) : this.allows(r);
    }
    configure(configOrDescription) {
      return this.configureShallowDescendants(configOrDescription);
    }
    describe(description) {
      return this.configure(description);
    }
    from(input) {
      return this.assert(input);
    }
    pipe(...morphs) {
      return morphs.reduce((acc, morph) => acc.pipeOnce(morph), this);
    }
    pipeOnce(morph) {
      if (hasArkKind(morph, "root")) {
        const result = pipeNodesRoot(this, morph, this.$);
        if (result instanceof Disjoint)
          return result.throw();
        return result;
      }
      if (this.hasKind("union")) {
        const branches = this.branches.map((node2) => node2.pipe(morph));
        return this.$.node("union", { ...this.inner, branches });
      }
      if (this.hasKind("morph")) {
        return this.$.node("morph", {
          ...this.inner,
          morphs: [...this.morphs, morph]
        });
      }
      return this.$.node("morph", {
        in: this,
        morphs: [morph]
      });
    }
    get flatMorphs() {
      return this.flatRefs.reduce((branches, ref) => appendUniqueFlatRefs(branches, ref.node.hasKind("union") ? ref.node.branches.filter((b) => b.hasKind("morph")).map((branch) => ({
        path: ref.path,
        propString: ref.propString,
        node: branch
      })) : ref.node.hasKind("morph") ? ref : []), []);
    }
    narrow(predicate) {
      return this.constrainOut("predicate", predicate);
    }
    constrain(kind, schema2) {
      return this._constrain("in", kind, schema2);
    }
    constrainOut(kind, schema2) {
      return this._constrain("out", kind, schema2);
    }
    _constrain(io, kind, schema2) {
      const constraint = this.$.node(kind, schema2);
      if (constraint.impliedBasis && !this[io].extends(constraint.impliedBasis)) {
        return throwInvalidOperandError(kind, constraint.impliedBasis, this);
      }
      const partialIntersection = this.$.node("intersection", {
        [kind]: constraint
      });
      const result = io === "in" ? intersectNodesRoot(this, partialIntersection, this.$) : pipeNodesRoot(this, partialIntersection, this.$);
      if (result instanceof Disjoint)
        result.throw();
      return result;
    }
    onUndeclaredKey(cfg) {
      const rule = typeof cfg === "string" ? cfg : cfg.rule;
      const deep = typeof cfg === "string" ? false : cfg.deep;
      return this.transform((kind, inner) => kind === "structure" ? rule === "ignore" ? omit(inner, { undeclared: 1 }) : { ...inner, undeclared: rule } : inner, deep ? void 0 : { shouldTransform: (node2) => !includes(structuralKinds, node2.kind) });
    }
    satisfying(predicate) {
      return this.constrain("predicate", predicate);
    }
    divisibleBy(schema2) {
      return this.constrain("divisor", schema2);
    }
    matching(schema2) {
      return this.constrain("pattern", schema2);
    }
    atLeast(schema2) {
      return this.constrain("min", schema2);
    }
    atMost(schema2) {
      return this.constrain("max", schema2);
    }
    moreThan(schema2) {
      return this.constrain("min", exclusivizeRangeSchema(schema2));
    }
    lessThan(schema2) {
      return this.constrain("max", exclusivizeRangeSchema(schema2));
    }
    atLeastLength(schema2) {
      return this.constrain("minLength", schema2);
    }
    atMostLength(schema2) {
      return this.constrain("maxLength", schema2);
    }
    moreThanLength(schema2) {
      return this.constrain("minLength", exclusivizeRangeSchema(schema2));
    }
    lessThanLength(schema2) {
      return this.constrain("maxLength", exclusivizeRangeSchema(schema2));
    }
    exactlyLength(schema2) {
      return this.constrain("exactLength", schema2);
    }
    atOrAfter(schema2) {
      return this.constrain("after", schema2);
    }
    atOrBefore(schema2) {
      return this.constrain("before", schema2);
    }
    laterThan(schema2) {
      return this.constrain("after", exclusivizeRangeSchema(schema2));
    }
    earlierThan(schema2) {
      return this.constrain("before", exclusivizeRangeSchema(schema2));
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _keyof_decorators = [cached];
    _get_flatMorphs_decorators = [cached];
    __esDecorate3(_c, null, _keyof_decorators, { kind: "method", name: "keyof", static: false, private: false, access: { has: (obj) => "keyof" in obj, get: (obj) => obj.keyof }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_c, null, _get_flatMorphs_decorators, { kind: "getter", name: "flatMorphs", static: false, private: false, access: { has: (obj) => "flatMorphs" in obj, get: (obj) => obj.flatMorphs }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_c, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _c;
})();
var exclusivizeRangeSchema = (schema2) => typeof schema2 === "object" && !(schema2 instanceof Date) ? { ...schema2, exclusive: true } : {
  rule: schema2,
  exclusive: true
};
var writeNonStructuralIndexAccessMessage = (key) => `${printable(key)} cannot be accessed on ${void 0}, which has no structural keys`;

// node_modules/@ark/schema/out/roots/utils.js
var defineRightwardIntersections = (kind, implementation) => flatMorph(schemaKindsRightOf(kind), (i, kind2) => [
  kind2,
  implementation
]);

// node_modules/@ark/schema/out/roots/alias.js
var __runInitializers4 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate4 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var AliasNode = (() => {
  var _a5;
  let _classSuper = BaseRoot;
  let _instanceExtraInitializers = [];
  let _get_resolution_decorators;
  return _a5 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __publicField(this, "expression", (__runInitializers4(this, _instanceExtraInitializers), this.alias));
      __publicField(this, "structure");
      __publicField(this, "traverseAllows", (data, ctx) => {
        const seen = ctx.seen[this.id];
        if (seen == null ? void 0 : seen.includes(data))
          return true;
        ctx.seen[this.id] = append(seen, data);
        return this.resolution.traverseAllows(data, ctx);
      });
      __publicField(this, "traverseApply", (data, ctx) => {
        const seen = ctx.seen[this.id];
        if (seen == null ? void 0 : seen.includes(data))
          return;
        ctx.seen[this.id] = append(seen, data);
        this.resolution.traverseApply(data, ctx);
      });
    }
    get resolution() {
      var _a6;
      return ((_a6 = this.resolve) == null ? void 0 : _a6.call(this)) ?? this.$.resolveRoot(this.alias);
    }
    rawKeyOf() {
      return this.resolution.keyof();
    }
    get shortDescription() {
      return domainDescriptions.object;
    }
    compile(js) {
      js.if(`ctx.seen.${this.id}?.includes(data)`, () => js.return(true));
      js.line(`ctx.seen.${this.id} ??= []`).line(`ctx.seen.${this.id}.push(data)`);
      js.return(js.invoke(this.resolution));
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _get_resolution_decorators = [cached];
    __esDecorate4(_a5, null, _get_resolution_decorators, { kind: "getter", name: "resolution", static: false, private: false, access: { has: (obj) => "resolution" in obj, get: (obj) => obj.resolution }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_a5, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a5;
})();
var normalizeAliasSchema = (schema2) => typeof schema2 === "string" ? { alias: schema2.slice(1) } : schema2;
var aliasImplementation = implementNode({
  kind: "alias",
  hasAssociatedError: false,
  collapsibleKey: "alias",
  keys: {
    alias: {
      serialize: (schema2) => `$${schema2}`
    },
    resolve: {}
  },
  normalize: normalizeAliasSchema,
  defaults: {
    description: (node2) => node2.alias
  },
  intersections: {
    alias: (l, r, ctx) => ctx.$.lazilyResolve(() => neverIfDisjoint(intersectNodes(l.resolution, r.resolution, ctx)), `${l.alias}${ctx.pipe ? "|>" : "&"}${r.alias}`),
    ...defineRightwardIntersections("alias", (l, r, ctx) => ctx.$.lazilyResolve(() => neverIfDisjoint(intersectNodes(l.resolution, r, ctx)), `${l.alias}${ctx.pipe ? "|>" : "&"}${r.alias}`))
  }
});
var neverIfDisjoint = (result) => result instanceof Disjoint ? $ark.intrinsic.never : result;

// node_modules/@ark/schema/out/roots/basis.js
var RawBasis = class extends BaseRoot {
  constructor() {
    super(...arguments);
    __publicField(this, "traverseApply", (data, ctx) => {
      if (!this.traverseAllows(data, ctx))
        ctx.error(this.errorContext);
    });
  }
  rawKeyOf() {
    return this.$.units(this.literalKeys);
  }
  get errorContext() {
    return { code: this.kind, description: this.description, ...this.inner };
  }
  get compiledErrorContext() {
    return compileErrorContext(this.errorContext);
  }
  compile(js) {
    if (js.traversalKind === "Allows")
      js.return(this.compiledCondition);
    else {
      js.if(this.compiledNegation, () => js.line(`${js.ctx}.error(${this.compiledErrorContext})`));
    }
  }
};

// node_modules/@ark/schema/out/roots/domain.js
var DomainNode = class extends RawBasis {
  constructor() {
    super(...arguments);
    __publicField(this, "traverseAllows", (data) => domainOf(data) === this.domain);
    __publicField(this, "compiledCondition", this.domain === "object" ? `((typeof data === "object" && data !== null) || typeof data === "function")` : `typeof data === "${this.domain}"`);
    __publicField(this, "compiledNegation", this.domain === "object" ? `((typeof data !== "object" || data === null) && typeof data !== "function")` : `typeof data !== "${this.domain}"`);
    __publicField(this, "expression", this.domain);
    __publicField(this, "literalKeys", getBaseDomainKeys(this.domain));
  }
  get shortDescription() {
    return domainDescriptions[this.domain];
  }
};
var domainImplementation = implementNode({
  kind: "domain",
  hasAssociatedError: true,
  collapsibleKey: "domain",
  keys: {
    domain: {}
  },
  normalize: (schema2) => typeof schema2 === "string" ? { domain: schema2 } : schema2,
  defaults: {
    description: (node2) => domainDescriptions[node2.domain],
    actual: (data) => typeof data === "boolean" ? `${data}` : domainOf(data)
  },
  intersections: {
    domain: (l, r) => Disjoint.init("domain", l, r)
  }
});

// node_modules/@ark/schema/out/shared/declare.js
var metaKeys = { description: 1 };

// node_modules/@ark/schema/out/roots/intersection.js
var _a3;
var IntersectionNode = class extends BaseRoot {
  constructor() {
    super(...arguments);
    __publicField(this, "basis", this.domain ?? this.proto ?? null);
    __publicField(this, "refinements", this.children.filter((node2) => node2.isRefinement()));
    __publicField(this, "expression", ((_a3 = this.structure) == null ? void 0 : _a3.expression) || `${this.basis ? this.basis.nestableExpression + " " : ""}${this.refinements.join(" & ")}` || "unknown");
    __publicField(this, "traverseAllows", (data, ctx) => this.children.every((child) => child.traverseAllows(data, ctx)));
    __publicField(this, "traverseApply", (data, ctx) => {
      const errorCount = ctx.currentErrorCount;
      if (this.basis) {
        this.basis.traverseApply(data, ctx);
        if (ctx.currentErrorCount > errorCount)
          return;
      }
      if (this.refinements.length) {
        for (let i = 0; i < this.refinements.length - 1; i++) {
          this.refinements[i].traverseApply(data, ctx);
          if (ctx.failFast && ctx.currentErrorCount > errorCount)
            return;
        }
        this.refinements.at(-1).traverseApply(data, ctx);
        if (ctx.currentErrorCount > errorCount)
          return;
      }
      if (this.structure) {
        this.structure.traverseApply(data, ctx);
        if (ctx.currentErrorCount > errorCount)
          return;
      }
      if (this.predicate) {
        for (let i = 0; i < this.predicate.length - 1; i++) {
          this.predicate[i].traverseApply(data, ctx);
          if (ctx.failFast && ctx.currentErrorCount > errorCount)
            return;
        }
        this.predicate.at(-1).traverseApply(data, ctx);
      }
    });
  }
  get shortDescription() {
    var _a5;
    return ((_a5 = this.basis) == null ? void 0 : _a5.shortDescription) ?? "present";
  }
  compile(js) {
    if (js.traversalKind === "Allows") {
      this.children.forEach((child) => js.check(child));
      js.return(true);
      return;
    }
    js.initializeErrorCount();
    if (this.basis) {
      js.check(this.basis);
      if (this.children.length > 1)
        js.returnIfFail();
    }
    if (this.refinements.length) {
      for (let i = 0; i < this.refinements.length - 1; i++) {
        js.check(this.refinements[i]);
        js.returnIfFailFast();
      }
      js.check(this.refinements.at(-1));
      if (this.structure || this.predicate)
        js.returnIfFail();
    }
    if (this.structure) {
      js.check(this.structure);
      if (this.predicate)
        js.returnIfFail();
    }
    if (this.predicate) {
      for (let i = 0; i < this.predicate.length - 1; i++) {
        js.check(this.predicate[i]);
        js.returnIfFail();
      }
      js.check(this.predicate.at(-1));
    }
  }
  rawKeyOf() {
    var _a5;
    return this.basis ? this.structure ? this.basis.rawKeyOf().or(this.structure.keyof()) : this.basis.rawKeyOf() : ((_a5 = this.structure) == null ? void 0 : _a5.keyof()) ?? $ark.intrinsic.never;
  }
};
var intersectIntersections = (l, r, ctx) => {
  if (hasArkKind(l, "root") && l.hasKind("intersection"))
    return intersectIntersections(l.inner, r, ctx);
  if (hasArkKind(r, "root") && r.hasKind("intersection"))
    return intersectIntersections(l, r.inner, ctx);
  const baseInner = isEmptyObject(l) ? pick(r, metaKeys) : {};
  const lBasis = l.proto ?? l.domain;
  const rBasis = r.proto ?? r.domain;
  const basisResult = lBasis ? rBasis ? intersectNodes(lBasis, rBasis, ctx) : lBasis : rBasis;
  if (basisResult instanceof Disjoint)
    return basisResult;
  if (basisResult)
    baseInner[basisResult.kind] = basisResult;
  return intersectConstraints({
    kind: "intersection",
    baseInner,
    l: flattenConstraints(l),
    r: flattenConstraints(r),
    roots: [],
    ctx
  });
};
var intersectionImplementation = implementNode({
  kind: "intersection",
  hasAssociatedError: true,
  normalize: (rawSchema) => {
    if (isNode(rawSchema))
      return rawSchema;
    const { structure, ...schema2 } = rawSchema;
    const hasRootStructureKey = !!structure;
    const normalizedStructure = structure ?? {};
    const normalized = flatMorph(schema2, (k, v) => {
      if (isKeyOf(k, structureKeys)) {
        if (hasRootStructureKey) {
          throwParseError(`Flattened structure key ${k} cannot be specified alongside a root 'structure' key.`);
        }
        normalizedStructure[k] = v;
        return [];
      }
      return [k, v];
    });
    if (hasArkKind(normalizedStructure, "constraint") || !isEmptyObject(normalizedStructure))
      normalized.structure = normalizedStructure;
    return normalized;
  },
  finalizeJson: ({ structure, ...rest }) => hasDomain(structure, "object") ? { ...structure, ...rest } : rest,
  keys: {
    domain: {
      child: true,
      parse: (schema2, ctx) => ctx.$.node("domain", schema2)
    },
    proto: {
      child: true,
      parse: (schema2, ctx) => ctx.$.node("proto", schema2)
    },
    structure: {
      child: true,
      parse: (schema2, ctx) => ctx.$.node("structure", schema2),
      serialize: (node2) => {
        var _a5;
        if (!((_a5 = node2.sequence) == null ? void 0 : _a5.minLength))
          return node2.collapsibleJson;
        const { sequence, ...structureJson } = node2.collapsibleJson;
        const { minVariadicLength, ...sequenceJson } = sequence;
        const collapsibleSequenceJson = sequenceJson.variadic && Object.keys(sequenceJson).length === 1 ? sequenceJson.variadic : sequenceJson;
        return { ...structureJson, sequence: collapsibleSequenceJson };
      }
    },
    divisor: {
      child: true,
      parse: constraintKeyParser("divisor")
    },
    max: {
      child: true,
      parse: constraintKeyParser("max")
    },
    min: {
      child: true,
      parse: constraintKeyParser("min")
    },
    maxLength: {
      child: true,
      parse: constraintKeyParser("maxLength")
    },
    minLength: {
      child: true,
      parse: constraintKeyParser("minLength")
    },
    exactLength: {
      child: true,
      parse: constraintKeyParser("exactLength")
    },
    before: {
      child: true,
      parse: constraintKeyParser("before")
    },
    after: {
      child: true,
      parse: constraintKeyParser("after")
    },
    pattern: {
      child: true,
      parse: constraintKeyParser("pattern")
    },
    predicate: {
      child: true,
      parse: constraintKeyParser("predicate")
    }
  },
  // leverage reduction logic from intersection and identity to ensure initial
  // parse result is reduced
  reduce: (inner, $2) => (
    // we cast union out of the result here since that only occurs when intersecting two sequences
    // that cannot occur when reducing a single intersection schema using unknown
    intersectIntersections({}, inner, {
      $: $2,
      invert: false,
      pipe: false
    })
  ),
  defaults: {
    description: (node2) => {
      var _a5;
      return node2.children.length === 0 ? "unknown" : ((_a5 = node2.structure) == null ? void 0 : _a5.description) ?? node2.children.map((child) => child.description).join(" and ");
    },
    expected: (source) => `  • ${source.errors.map((e) => e.expected).join("\n  • ")}`,
    problem: (ctx) => `(${ctx.actual}) must be...
${ctx.expected}`
  },
  intersections: {
    intersection: (l, r, ctx) => intersectIntersections(l, r, ctx),
    ...defineRightwardIntersections("intersection", (l, r, ctx) => {
      var _a5;
      if (l.children.length === 0)
        return r;
      const basis = l.basis ? intersectNodes(l.basis, r, ctx) : r;
      return basis instanceof Disjoint ? basis : ((_a5 = l == null ? void 0 : l.basis) == null ? void 0 : _a5.equals(basis)) ? (
        // if the basis doesn't change, return the original intesection
        l
      ) : l.$.node("intersection", Object.assign(omit(l.inner, metaKeys), {
        [basis.kind]: basis
      }), { prereduced: true });
    })
  }
});

// node_modules/@ark/schema/out/roots/morph.js
var morphChildKinds = [
  "alias",
  "intersection",
  "unit",
  "domain",
  "proto"
];
var morphImplementation = implementNode({
  kind: "morph",
  hasAssociatedError: false,
  keys: {
    in: {
      child: true,
      parse: (schema2, ctx) => ctx.$.node(morphChildKinds, schema2)
    },
    morphs: {
      parse: arrayFrom,
      serialize: (morphs) => morphs.map((m) => hasArkKind(m, "root") ? m.json : registeredReference(m))
    }
  },
  normalize: (schema2) => schema2,
  defaults: {
    description: (node2) => {
      var _a5;
      return `a morph from ${node2.in.description} to ${((_a5 = node2.out) == null ? void 0 : _a5.description) ?? "unknown"}`;
    }
  },
  intersections: {
    morph: (l, r, ctx) => {
      if (!l.hasEqualMorphs(r)) {
        return throwParseError(writeMorphIntersectionMessage(l.expression, r.expression));
      }
      const inTersection = intersectNodes(l.in, r.in, ctx);
      if (inTersection instanceof Disjoint)
        return inTersection;
      return ctx.$.schema(inTersection.branches.map((inBranch) => ctx.$.node("morph", {
        morphs: l.morphs,
        in: inBranch
      })));
    },
    ...defineRightwardIntersections("morph", (l, r, ctx) => {
      const inTersection = intersectNodes(l.in, r, ctx);
      return inTersection instanceof Disjoint ? inTersection : inTersection.kind === "union" ? ctx.$.node("union", inTersection.branches.map((branch) => ({
        ...l.inner,
        in: branch
      }))) : ctx.$.node("morph", {
        ...l.inner,
        in: inTersection
      });
    })
  }
});
var _a4;
var MorphNode = class extends BaseRoot {
  constructor() {
    super(...arguments);
    __publicField(this, "serializedMorphs", this.morphs.map(registeredReference));
    __publicField(this, "compiledMorphs", `[${this.serializedMorphs}]`);
    __publicField(this, "structure", this.in.structure);
    __publicField(this, "traverseAllows", (data, ctx) => this.in.traverseAllows(data, ctx));
    __publicField(this, "traverseApply", (data, ctx) => {
      this.in.traverseApply(data, ctx);
      ctx.queueMorphs(this.morphs);
    });
    __publicField(this, "expression", `(In: ${this.in.expression}) => Out<${((_a4 = this.out) == null ? void 0 : _a4.expression) ?? "unknown"}>`);
    __publicField(this, "lastMorph", this.inner.morphs.at(-1));
    __publicField(this, "validatedOut", hasArkKind(this.lastMorph, "root") ? Object.assign(this.referencesById, this.lastMorph.out.referencesById) && this.lastMorph.out : void 0);
  }
  get shortDescription() {
    return this.in.shortDescription;
  }
  compile(js) {
    if (js.traversalKind === "Allows") {
      js.return(js.invoke(this.in));
      return;
    }
    js.line(js.invoke(this.in));
    js.line(`ctx.queueMorphs(${this.compiledMorphs})`);
  }
  get in() {
    return this.inner.in;
  }
  get out() {
    return this.validatedOut ?? $ark.intrinsic.unknown;
  }
  /** Check if the morphs of r are equal to those of this node */
  hasEqualMorphs(r) {
    return arrayEquals(this.morphs, r.morphs, {
      isEqual: (lMorph, rMorph) => lMorph === rMorph || hasArkKind(lMorph, "root") && hasArkKind(rMorph, "root") && lMorph.equals(rMorph)
    });
  }
  rawKeyOf() {
    return this.in.rawKeyOf();
  }
};
var writeMorphIntersectionMessage = (lDescription, rDescription) => `The intersection of distinct morphs at a single path is indeterminate:
Left: ${lDescription}
Right: ${rDescription}`;

// node_modules/@ark/schema/out/roots/proto.js
var protoImplementation = implementNode({
  kind: "proto",
  hasAssociatedError: true,
  collapsibleKey: "proto",
  keys: {
    proto: {
      serialize: (ctor) => getExactBuiltinConstructorName(ctor) ?? defaultValueSerializer(ctor)
    }
  },
  normalize: (schema2) => typeof schema2 === "string" ? { proto: builtinConstructors[schema2] } : typeof schema2 === "function" ? { proto: schema2 } : typeof schema2.proto === "string" ? { ...schema2, proto: builtinConstructors[schema2.proto] } : schema2,
  defaults: {
    description: (node2) => node2.builtinName ? objectKindDescriptions[node2.builtinName] : `an instance of ${node2.proto.name}`,
    actual: (data) => objectKindOrDomainOf(data)
  },
  intersections: {
    proto: (l, r) => constructorExtends(l.proto, r.proto) ? l : constructorExtends(r.proto, l.proto) ? r : Disjoint.init("proto", l, r),
    domain: (proto, domain) => domain.domain === "object" ? proto : Disjoint.init("domain", $ark.intrinsic.object.internal, domain)
  }
});
var ProtoNode = class extends RawBasis {
  constructor() {
    super(...arguments);
    __publicField(this, "builtinName", getExactBuiltinConstructorName(this.proto));
    __publicField(this, "serializedConstructor", this.json.proto);
    __publicField(this, "compiledCondition", `data instanceof ${this.serializedConstructor}`);
    __publicField(this, "compiledNegation", `!(${this.compiledCondition})`);
    __publicField(this, "literalKeys", prototypeKeysOf(this.proto.prototype));
    __publicField(this, "traverseAllows", (data) => data instanceof this.proto);
    __publicField(this, "expression", this.proto.name);
    __publicField(this, "domain", "object");
  }
  get shortDescription() {
    return this.description;
  }
};

// node_modules/@ark/schema/out/roots/union.js
var __runInitializers5 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate5 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var unionChildKinds = [
  ...schemaKindsRightOf("union"),
  "alias"
];
var unionImplementation = implementNode({
  kind: "union",
  hasAssociatedError: true,
  collapsibleKey: "branches",
  keys: {
    ordered: {},
    branches: {
      child: true,
      parse: (schema2, ctx) => {
        const branches = schema2.map((branch) => ctx.$.node(unionChildKinds, branch));
        if (!ctx.schema.ordered)
          branches.sort((l, r) => l.innerHash < r.innerHash ? -1 : 1);
        return branches;
      }
    }
  },
  normalize: (schema2) => isArray(schema2) ? { branches: schema2 } : schema2,
  reduce: (inner, $2) => {
    const reducedBranches = reduceBranches(inner);
    if (reducedBranches.length === 1)
      return reducedBranches[0];
    if (reducedBranches.length === inner.branches.length)
      return;
    return $2.node("union", {
      ...inner,
      branches: reducedBranches
    }, { prereduced: true });
  },
  defaults: {
    description: (node2) => describeBranches(node2.branches.map((branch) => branch.description)),
    expected: (ctx) => {
      const byPath = groupBy(ctx.errors, "propString");
      const pathDescriptions = Object.entries(byPath).map(([path, errors]) => {
        const branchesAtPath = [];
        errors.forEach((errorAtPath) => (
          // avoid duplicate messages when multiple branches
          // are invalid due to the same error
          appendUnique(branchesAtPath, errorAtPath.expected)
        ));
        const expected = describeBranches(branchesAtPath);
        const actual = errors.every((e) => e.actual === errors[0].actual) ? errors[0].actual : printable(errors[0].data);
        return `${path && `${path} `}must be ${expected}${actual && ` (was ${actual})`}`;
      });
      return describeBranches(pathDescriptions);
    },
    problem: (ctx) => ctx.expected,
    message: (ctx) => ctx.problem
  },
  intersections: {
    union: (l, r, ctx) => {
      if (l.isNever !== r.isNever) {
        return Disjoint.init("presence", l, r);
      }
      let resultBranches;
      if (l.ordered) {
        if (r.ordered) {
          throwParseError(writeOrderedIntersectionMessage(l.expression, r.expression));
        }
        resultBranches = intersectBranches(r.branches, l.branches, ctx);
        if (resultBranches instanceof Disjoint)
          resultBranches.invert();
      } else
        resultBranches = intersectBranches(l.branches, r.branches, ctx);
      if (resultBranches instanceof Disjoint)
        return resultBranches;
      return ctx.$.schema(l.ordered || r.ordered ? {
        branches: resultBranches,
        ordered: true
      } : { branches: resultBranches });
    },
    ...defineRightwardIntersections("union", (l, r, ctx) => {
      const branches = intersectBranches(l.branches, [r], ctx);
      if (branches instanceof Disjoint)
        return branches;
      if (branches.length === 1)
        return branches[0];
      return ctx.$.schema(l.ordered ? { branches, ordered: true } : { branches });
    })
  }
});
var UnionNode = (() => {
  var _a5;
  let _classSuper = BaseRoot;
  let _instanceExtraInitializers = [];
  let _discriminate_decorators;
  return _a5 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __publicField(this, "isNever", (__runInitializers5(this, _instanceExtraInitializers), this.branches.length === 0));
      __publicField(this, "isBoolean", this.branches.length === 2 && this.branches[0].hasUnit(false) && this.branches[1].hasUnit(true));
      __publicField(this, "unitBranches", this.branches.filter((n) => n.in.hasKind("unit")));
      __publicField(this, "discriminant", this.discriminate());
      __publicField(this, "discriminantJson", this.discriminant ? discriminantToJson(this.discriminant) : null);
      __publicField(this, "expression", expressBranches(this.branches.map((n) => n.nestableExpression)));
      __publicField(this, "traverseAllows", (data, ctx) => this.branches.some((b) => b.traverseAllows(data, ctx)));
      __publicField(this, "traverseApply", (data, ctx) => {
        const errors = [];
        for (let i = 0; i < this.branches.length; i++) {
          ctx.pushBranch();
          this.branches[i].traverseApply(data, ctx);
          if (!ctx.hasError())
            return ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs);
          errors.push(ctx.popBranch().error);
        }
        ctx.error({ code: "union", errors });
      });
    }
    get shortDescription() {
      return describeBranches(this.branches.map((branch) => branch.shortDescription));
    }
    compile(js) {
      if (!this.discriminant || // if we have a union of two units like `boolean`, the
      // undiscriminated compilation will be just as fast
      this.unitBranches.length === this.branches.length && this.branches.length === 2)
        return this.compileIndiscriminable(js);
      const condition = this.discriminant.path.reduce((acc, k) => acc + compileLiteralPropAccess(k, true), this.discriminant.kind === "domain" ? "typeof data" : "data");
      const cases = this.discriminant.cases;
      const caseKeys = Object.keys(cases);
      js.block(`switch(${condition})`, () => {
        for (const k in cases) {
          const v = cases[k];
          const caseCondition = k === "default" ? k : `case ${k}`;
          js.line(`${caseCondition}: return ${v === true ? v : js.invoke(v)}`);
        }
        return js;
      });
      if (js.traversalKind === "Allows") {
        js.return(false);
        return;
      }
      const expected = describeBranches(this.discriminant.kind === "domain" ? caseKeys.map((k) => domainDescriptions[k.slice(1, -1)]) : caseKeys);
      const serializedPathSegments = this.discriminant.path.map((k) => typeof k === "string" ? JSON.stringify(k) : registeredReference(k));
      js.line(`ctx.error({
	expected: ${JSON.stringify(expected)},
	actual: ${condition},
	relativePath: [${serializedPathSegments}]
})`);
    }
    compileIndiscriminable(js) {
      if (js.traversalKind === "Apply") {
        js.const("errors", "[]");
        this.branches.forEach((branch) => js.line("ctx.pushBranch()").line(js.invoke(branch)).if("!ctx.hasError()", () => js.return("ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs)")).line("errors.push(ctx.popBranch().error)"));
        js.line(`ctx.error({ code: "union", errors })`);
      } else {
        this.branches.forEach((branch) => js.if(`${js.invoke(branch)}`, () => js.return(true)));
        js.return(false);
      }
    }
    rawKeyOf() {
      return this.branches.reduce((result, branch) => result.and(branch.rawKeyOf()), $ark.intrinsic.unknown);
    }
    get nestableExpression() {
      return this.isBoolean ? "boolean" : super.nestableExpression;
    }
    discriminate() {
      if (this.branches.length < 2)
        return null;
      if (this.unitBranches.length === this.branches.length) {
        const cases2 = flatMorph(this.unitBranches, (i, n) => [
          `${n.in.serializedValue}`,
          n.hasKind("morph") ? n : true
        ]);
        return {
          kind: "unit",
          path: [],
          propString: "",
          cases: cases2
        };
      }
      const candidates = [];
      for (let lIndex = 0; lIndex < this.branches.length - 1; lIndex++) {
        const l = this.branches[lIndex];
        for (let rIndex = lIndex + 1; rIndex < this.branches.length; rIndex++) {
          const r = this.branches[rIndex];
          const result = intersectNodesRoot(l.in, r.in, l.$);
          if (!(result instanceof Disjoint))
            continue;
          for (const entry of result) {
            if (!isKeyOf(entry.kind, discriminantKinds) || entry.optional)
              continue;
            let lSerialized;
            let rSerialized;
            if (entry.kind === "domain") {
              lSerialized = `"${entry.l.domain}"`;
              rSerialized = `"${entry.r.domain}"`;
            } else if (entry.kind === "unit") {
              lSerialized = entry.l.serializedValue;
              rSerialized = entry.r.serializedValue;
            } else {
              return throwInternalError(`Unexpected attempt to discriminate disjoint kind '${entry.kind}'`);
            }
            const matching = candidates.find((d) => arrayEquals(d.path, entry.path) && d.kind === entry.kind);
            if (!matching) {
              candidates.push({
                kind: entry.kind,
                cases: {
                  [lSerialized]: [l],
                  [rSerialized]: [r]
                },
                path: entry.path
              });
              continue;
            }
            matching.cases[lSerialized] = appendUnique(matching.cases[lSerialized], l);
            matching.cases[rSerialized] = appendUnique(matching.cases[rSerialized], r);
          }
        }
      }
      const best = candidates.sort((l, r) => Object.keys(l.cases).length - Object.keys(r.cases).length).at(-1);
      if (!best)
        return null;
      let defaultBranches = [...this.branches];
      const bestCtx = {
        kind: best.kind,
        path: best.path,
        propString: pathToPropString(best.path)
      };
      const cases = flatMorph(best.cases, (k, caseBranches) => {
        const prunedBranches = [];
        defaultBranches = defaultBranches.filter((n) => !caseBranches.includes(n));
        for (const branch of caseBranches) {
          const pruned = pruneDiscriminant(branch, bestCtx);
          if (pruned === null)
            return [k, true];
          prunedBranches.push(pruned);
        }
        const caseNode = prunedBranches.length === 1 ? prunedBranches[0] : this.$.node("union", prunedBranches);
        Object.assign(this.referencesById, caseNode.referencesById);
        return [k, caseNode];
      });
      if (defaultBranches.length) {
        cases.default = this.$.node("union", defaultBranches, {
          prereduced: true
        });
        Object.assign(this.referencesById, cases.default.referencesById);
      }
      return {
        kind: best.kind,
        path: best.path,
        propString: pathToPropString(best.path),
        cases
      };
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _discriminate_decorators = [cached];
    __esDecorate5(_a5, null, _discriminate_decorators, { kind: "method", name: "discriminate", static: false, private: false, access: { has: (obj) => "discriminate" in obj, get: (obj) => obj.discriminate }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_a5, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a5;
})();
var discriminantToJson = (discriminant) => ({
  kind: discriminant.kind,
  path: discriminant.path.map((k) => typeof k === "string" ? k : compileSerializedValue(k)),
  cases: flatMorph(discriminant.cases, (k, node2) => [
    k,
    node2 === true ? node2 : node2.hasKind("union") && node2.discriminantJson ? node2.discriminantJson : node2.json
  ])
});
var describeExpressionOptions = {
  delimiter: " | ",
  finalDelimiter: " | "
};
var expressBranches = (expressions) => describeBranches(expressions, describeExpressionOptions);
var describeBranches = (descriptions, opts) => {
  const delimiter = (opts == null ? void 0 : opts.delimiter) ?? ", ";
  const finalDelimiter = (opts == null ? void 0 : opts.finalDelimiter) ?? " or ";
  if (descriptions.length === 0)
    return "never";
  if (descriptions.length === 1)
    return descriptions[0];
  if (descriptions.length === 2 && descriptions[0] === "false" && descriptions[1] === "true" || descriptions[0] === "true" && descriptions[1] === "false")
    return "boolean";
  let description = "";
  const seen = {};
  for (let i = 0; i < descriptions.length - 1; i++) {
    if (seen[descriptions[i]])
      continue;
    seen[descriptions[i]] = true;
    description += descriptions[i];
    if (i < descriptions.length - 2)
      description += delimiter;
  }
  const lastDescription = descriptions.at(-1);
  if (!seen[lastDescription])
    description += `${finalDelimiter}${descriptions[descriptions.length - 1]}`;
  return description;
};
var intersectBranches = (l, r, ctx) => {
  const batchesByR = r.map(() => []);
  for (let lIndex = 0; lIndex < l.length; lIndex++) {
    let candidatesByR = {};
    for (let rIndex = 0; rIndex < r.length; rIndex++) {
      if (batchesByR[rIndex] === null) {
        continue;
      }
      if (l[lIndex].equals(r[rIndex])) {
        batchesByR[rIndex] = null;
        candidatesByR = {};
        break;
      }
      const branchIntersection = intersectNodes(l[lIndex], r[rIndex], ctx);
      if (branchIntersection instanceof Disjoint) {
        continue;
      }
      if (branchIntersection.equals(l[lIndex])) {
        batchesByR[rIndex].push(l[lIndex]);
        candidatesByR = {};
        break;
      }
      if (branchIntersection.equals(r[rIndex])) {
        batchesByR[rIndex] = null;
      } else {
        candidatesByR[rIndex] = branchIntersection;
      }
    }
    for (const rIndex in candidatesByR) {
      batchesByR[rIndex][lIndex] = candidatesByR[rIndex];
    }
  }
  const resultBranches = batchesByR.flatMap(
    // ensure unions returned from branchable intersections like sequence are flattened
    (batch, i) => (batch == null ? void 0 : batch.flatMap((branch) => branch.branches)) ?? r[i]
  );
  return resultBranches.length === 0 ? Disjoint.init("union", l, r) : resultBranches;
};
var reduceBranches = ({ branches, ordered }) => {
  if (branches.length < 2)
    return branches;
  const uniquenessByIndex = branches.map(() => true);
  for (let i = 0; i < branches.length; i++) {
    for (let j = i + 1; j < branches.length && uniquenessByIndex[i] && uniquenessByIndex[j]; j++) {
      if (branches[i].equals(branches[j])) {
        uniquenessByIndex[j] = false;
        continue;
      }
      const intersection = intersectNodesRoot(branches[i].in, branches[j].in, branches[0].$);
      if (intersection instanceof Disjoint)
        continue;
      if (!ordered && (branches[i].includesMorph || branches[j].includesMorph) && (!arrayEquals(branches[i].shallowMorphs, branches[j].shallowMorphs, {
        isEqual: (l, r) => l.hasEqualMorphs(r)
      }) || !arrayEquals(branches[i].flatMorphs, branches[j].flatMorphs, {
        isEqual: (l, r) => l.propString === r.propString && l.node.hasEqualMorphs(r.node)
      }))) {
        throwParseError(writeIndiscriminableMorphMessage(branches[i].expression, branches[j].expression));
      }
      if (intersection.equals(branches[i].in)) {
        uniquenessByIndex[i] = !!ordered;
      } else if (intersection.equals(branches[j].in))
        uniquenessByIndex[j] = false;
    }
  }
  return branches.filter((_, i) => uniquenessByIndex[i]);
};
var discriminantKinds = {
  domain: 1,
  unit: 1
};
var pruneDiscriminant = (discriminantBranch, discriminantCtx) => discriminantBranch.transform((nodeKind, inner, ctx) => {
  if (nodeKind === "domain" && inner.domain === "object" && discriminantCtx.path.length >= ctx.path.length)
    return null;
  if ((nodeKind === "domain" || discriminantCtx.kind === "unit") && typePathToPropString(ctx.path) === discriminantCtx.propString)
    return null;
  return inner;
}, {
  shouldTransform: (node2) => (
    // we don't need to recurse into index nodes as they will never
    // have a required path therefore can't be used to discriminate
    node2.children.length !== 0 && node2.kind !== "index" || node2.kind === "domain" || node2.kind === "unit"
  )
});
var writeIndiscriminableMorphMessage = (lDescription, rDescription) => `An unordered union of a type including a morph and a type with overlapping input is indeterminate:
Left: ${lDescription}
Right: ${rDescription}`;
var writeOrderedIntersectionMessage = (lDescription, rDescription) => `The intersection of two ordered unions is indeterminate:
Left: ${lDescription}
Right: ${rDescription}`;

// node_modules/@ark/schema/out/roots/unit.js
var unitImplementation = implementNode({
  kind: "unit",
  hasAssociatedError: true,
  keys: {
    unit: {
      preserveUndefined: true,
      serialize: (schema2) => schema2 instanceof Date ? schema2.toISOString() : defaultValueSerializer(schema2)
    }
  },
  normalize: (schema2) => schema2,
  defaults: {
    description: (node2) => printable(node2.unit),
    problem: ({ expected, actual }) => `${expected === actual ? `must be reference equal to ${expected} (serialized to the same value)` : `must be ${expected} (was ${actual})`}`
  },
  intersections: {
    unit: (l, r) => Disjoint.init("unit", l, r),
    ...defineRightwardIntersections("unit", (l, r) => r.allows(l.unit) ? l : Disjoint.init("assignability", l, r.hasKind("intersection") ? r.children.find((rConstraint) => !rConstraint.allows(l.unit)) : r))
  }
});
var UnitNode = class extends RawBasis {
  constructor() {
    super(...arguments);
    __publicField(this, "compiledValue", this.json.unit);
    __publicField(this, "serializedValue", typeof this.unit === "string" || this.unit instanceof Date ? JSON.stringify(this.compiledValue) : this.compiledValue);
    __publicField(this, "literalKeys", prototypeKeysOf(this.unit));
    __publicField(this, "compiledCondition", compileEqualityCheck(this.unit, this.serializedValue));
    __publicField(this, "compiledNegation", compileEqualityCheck(this.unit, this.serializedValue, "negated"));
    __publicField(this, "expression", printable(this.unit));
    __publicField(this, "domain", domainOf(this.unit));
    __publicField(this, "traverseAllows", this.unit instanceof Date ? (data) => data instanceof Date && data.toISOString() === this.compiledValue : (data) => data === this.unit);
  }
  get shortDescription() {
    return this.domain === "object" ? domainDescriptions.object : this.description;
  }
};
var compileEqualityCheck = (unit, serializedValue, negated) => {
  if (unit instanceof Date) {
    const condition = `data instanceof Date && data.toISOString() === ${serializedValue}`;
    return negated ? `!(${condition})` : condition;
  }
  return `data ${negated ? "!" : "="}== ${serializedValue}`;
};

// node_modules/@ark/schema/out/structure/indexed.js
var indexImplementation = implementNode({
  kind: "index",
  hasAssociatedError: false,
  intersectionIsOpen: true,
  keys: {
    signature: {
      child: true,
      parse: (schema2, ctx) => {
        const key = ctx.$.schema(schema2);
        if (!key.extends($ark.intrinsic.propertyKey)) {
          return throwParseError(writeInvalidPropertyKeyMessage(key.expression));
        }
        const enumerableBranches = key.branches.filter((b) => b.hasKind("unit"));
        if (enumerableBranches.length) {
          return throwParseError(writeEnumerableIndexBranches(enumerableBranches.map((b) => printable(b.unit))));
        }
        return key;
      }
    },
    value: {
      child: true,
      parse: (schema2, ctx) => ctx.$.schema(schema2)
    }
  },
  normalize: (schema2) => schema2,
  defaults: {
    description: (node2) => `[${node2.signature.expression}]: ${node2.value.description}`
  },
  intersections: {
    index: (l, r, ctx) => {
      if (l.signature.equals(r.signature)) {
        const valueIntersection = intersectNodes(l.value, r.value, ctx);
        const value = valueIntersection instanceof Disjoint ? $ark.intrinsic.never.internal : valueIntersection;
        return ctx.$.node("index", { signature: l.signature, value });
      }
      if (l.signature.extends(r.signature) && l.value.subsumes(r.value))
        return r;
      if (r.signature.extends(l.signature) && r.value.subsumes(l.value))
        return l;
      return null;
    }
  }
});
var IndexNode = class extends BaseConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "impliedBasis", $ark.intrinsic.object);
    __publicField(this, "expression", `[${this.signature.expression}]: ${this.value.expression}`);
    __publicField(this, "traverseAllows", (data, ctx) => stringAndSymbolicEntriesOf(data).every((entry) => {
      if (this.signature.traverseAllows(entry[0], ctx)) {
        ctx == null ? void 0 : ctx.path.push(entry[0]);
        const allowed = this.value.traverseAllows(entry[1], ctx);
        ctx == null ? void 0 : ctx.path.pop();
        return allowed;
      }
      return true;
    }));
    __publicField(this, "traverseApply", (data, ctx) => stringAndSymbolicEntriesOf(data).forEach((entry) => {
      if (this.signature.traverseAllows(entry[0], ctx)) {
        ctx.path.push(entry[0]);
        this.value.traverseApply(entry[1], ctx);
        ctx.path.pop();
      }
    }));
  }
  _transform(mapper, ctx) {
    ctx.path.push(this.signature);
    const result = super._transform(mapper, ctx);
    ctx.path.pop();
    return result;
  }
  get flatRefs() {
    return append(this.value.flatRefs.map((ref) => flatRef([this.signature, ...ref.path], ref.node)), flatRef([this.signature], this.value));
  }
  compile() {
  }
};
var writeEnumerableIndexBranches = (keys) => `Index keys ${keys.join(", ")} should be specified as named props.`;
var writeInvalidPropertyKeyMessage = (indexSchema) => `Indexed key definition '${indexSchema}' must be a string, number or symbol`;

// node_modules/@ark/schema/out/structure/prop.js
var intersectProps = (l, r, ctx) => {
  if (l.key !== r.key)
    return null;
  const key = l.key;
  let value = intersectNodes(l.value, r.value, ctx);
  const kind = l.required || r.required ? "required" : "optional";
  if (value instanceof Disjoint) {
    if (kind === "optional")
      value = $ark.intrinsic.never.internal;
    else {
      return value.withPrefixKey(l.key, l.required && r.required ? "required" : "optional");
    }
  }
  if (kind === "required") {
    return ctx.$.node("required", {
      key,
      value
    });
  }
  const defaultIntersection = l.hasDefault() ? r.hasDefault() ? l.default === r.default ? l.default : throwParseError(`Invalid intersection of default values ${printable(l.default)} & ${printable(r.default)}`) : l.default : r.hasDefault() ? r.default : unset;
  return ctx.$.node("optional", {
    key,
    value,
    // unset is stripped during parsing
    default: defaultIntersection
  });
};
var BaseProp = class extends BaseConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "required", this.kind === "required");
    __publicField(this, "optional", this.kind === "optional");
    __publicField(this, "impliedBasis", $ark.intrinsic.object);
    __publicField(this, "serializedKey", compileSerializedValue(this.key));
    __publicField(this, "compiledKey", typeof this.key === "string" ? this.key : this.serializedKey);
    __publicField(this, "defaultValueMorphs", [
      (data) => {
        data[this.key] = this.default;
        return data;
      }
    ]);
    __publicField(this, "defaultValueMorphsReference", registeredReference(this.defaultValueMorphs));
    __publicField(this, "traverseAllows", (data, ctx) => {
      if (this.key in data) {
        ctx == null ? void 0 : ctx.path.push(this.key);
        const allowed = this.value.traverseAllows(data[this.key], ctx);
        ctx == null ? void 0 : ctx.path.pop();
        return allowed;
      }
      return this.optional;
    });
    __publicField(this, "traverseApply", (data, ctx) => {
      if (this.key in data) {
        ctx.path.push(this.key);
        this.value.traverseApply(data[this.key], ctx);
        ctx.path.pop();
      } else if (this.hasKind("required"))
        ctx.error(this.errorContext);
      else if (this.hasKind("optional") && this.hasDefault())
        ctx.queueMorphs(this.defaultValueMorphs);
    });
  }
  get flatRefs() {
    return append(this.value.flatRefs.map((ref) => flatRef([this.key, ...ref.path], ref.node)), flatRef([this.key], this.value));
  }
  _transform(mapper, ctx) {
    ctx.path.push(this.key);
    const result = super._transform(mapper, ctx);
    ctx.path.pop();
    return result;
  }
  hasDefault() {
    return "default" in this;
  }
  compile(js) {
    js.if(`${this.serializedKey} in data`, () => js.traverseKey(this.serializedKey, `data${js.prop(this.key)}`, this.value));
    if (this.hasKind("required")) {
      js.else(() => {
        if (js.traversalKind === "Apply")
          return js.line(`ctx.error(${this.compiledErrorContext})`);
        else
          return js.return(false);
      });
    } else if (js.traversalKind === "Apply" && "default" in this) {
      js.else(() => js.line(`ctx.queueMorphs(${this.defaultValueMorphsReference})`));
    }
    if (js.traversalKind === "Allows")
      js.return(true);
  }
};

// node_modules/@ark/schema/out/structure/optional.js
var optionalImplementation = implementNode({
  kind: "optional",
  hasAssociatedError: false,
  intersectionIsOpen: true,
  keys: {
    key: {},
    value: {
      child: true,
      parse: (schema2, ctx) => ctx.$.schema(schema2)
    },
    default: {
      preserveUndefined: true
    }
  },
  normalize: (schema2) => schema2,
  defaults: {
    description: (node2) => `${node2.compiledKey}?: ${node2.value.description}`
  },
  intersections: {
    optional: intersectProps
  }
});
var OptionalNode = class extends BaseProp {
  constructor() {
    super(...arguments);
    __publicField(this, "expression", `${this.compiledKey}?: ${this.value.expression}`);
  }
};

// node_modules/@ark/schema/out/structure/required.js
var RequiredNode = class extends BaseProp {
  constructor() {
    super(...arguments);
    __publicField(this, "expression", `${this.compiledKey}: ${this.value.expression}`);
    __publicField(this, "errorContext", Object.freeze({
      code: "required",
      missingValueDescription: this.value.shortDescription,
      relativePath: [this.key]
    }));
    __publicField(this, "compiledErrorContext", compileErrorContext(this.errorContext));
  }
};
var requiredImplementation = implementNode({
  kind: "required",
  hasAssociatedError: true,
  intersectionIsOpen: true,
  keys: {
    key: {},
    value: {
      child: true,
      parse: (schema2, ctx) => ctx.$.schema(schema2)
    }
  },
  normalize: (schema2) => schema2,
  defaults: {
    description: (node2) => `${node2.compiledKey}: ${node2.value.description}`,
    expected: (ctx) => ctx.missingValueDescription,
    actual: () => "missing"
  },
  intersections: {
    required: intersectProps,
    optional: intersectProps
  }
});

// node_modules/@ark/schema/out/structure/sequence.js
var __runInitializers6 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate6 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var fixedSequenceKeySchemaDefinition = {
  child: true,
  parse: (schema2, ctx) => schema2.length === 0 ? (
    // empty affixes are omitted. an empty array should therefore
    // be specified as `{ proto: Array, length: 0 }`
    void 0
  ) : schema2.map((element) => ctx.$.schema(element))
};
var sequenceImplementation = implementNode({
  kind: "sequence",
  hasAssociatedError: false,
  collapsibleKey: "variadic",
  keys: {
    prefix: fixedSequenceKeySchemaDefinition,
    optionals: fixedSequenceKeySchemaDefinition,
    variadic: {
      child: true,
      parse: (schema2, ctx) => ctx.$.schema(schema2, ctx)
    },
    minVariadicLength: {
      // minVariadicLength is reflected in the id of this node,
      // but not its IntersectionNode parent since it is superceded by the minLength
      // node it implies
      parse: (min) => min === 0 ? void 0 : min
    },
    postfix: fixedSequenceKeySchemaDefinition
  },
  normalize: (schema2) => {
    var _a5, _b3;
    if (typeof schema2 === "string")
      return { variadic: schema2 };
    if ("variadic" in schema2 || "prefix" in schema2 || "optionals" in schema2 || "postfix" in schema2 || "minVariadicLength" in schema2) {
      if ((_a5 = schema2.postfix) == null ? void 0 : _a5.length) {
        if (!schema2.variadic)
          return throwParseError(postfixWithoutVariadicMessage);
        if ((_b3 = schema2.optionals) == null ? void 0 : _b3.length)
          return throwParseError(postfixFollowingOptionalMessage);
      }
      if (schema2.minVariadicLength && !schema2.variadic) {
        return throwParseError("minVariadicLength may not be specified without a variadic element");
      }
      return schema2;
    }
    return { variadic: schema2 };
  },
  reduce: (raw, $2) => {
    var _a5, _b3, _c, _d, _e, _f;
    let minVariadicLength = raw.minVariadicLength ?? 0;
    const prefix = ((_a5 = raw.prefix) == null ? void 0 : _a5.slice()) ?? [];
    const optional = ((_b3 = raw.optionals) == null ? void 0 : _b3.slice()) ?? [];
    const postfix = ((_c = raw.postfix) == null ? void 0 : _c.slice()) ?? [];
    if (raw.variadic) {
      while ((_d = optional.at(-1)) == null ? void 0 : _d.equals(raw.variadic))
        optional.pop();
      if (optional.length === 0) {
        while ((_e = prefix.at(-1)) == null ? void 0 : _e.equals(raw.variadic)) {
          prefix.pop();
          minVariadicLength++;
        }
      }
      while ((_f = postfix[0]) == null ? void 0 : _f.equals(raw.variadic)) {
        postfix.shift();
        minVariadicLength++;
      }
    } else if (optional.length === 0) {
      prefix.push(...postfix.splice(0));
    }
    if (
      // if any variadic adjacent elements were moved to minVariadicLength
      minVariadicLength !== raw.minVariadicLength || // or any postfix elements were moved to prefix
      raw.prefix && raw.prefix.length !== prefix.length
    ) {
      return $2.node("sequence", {
        ...raw,
        // empty lists will be omitted during parsing
        prefix,
        postfix,
        optionals: optional,
        minVariadicLength
      }, { prereduced: true });
    }
  },
  defaults: {
    description: (node2) => {
      if (node2.isVariadicOnly)
        return `${node2.variadic.nestableExpression}[]`;
      const innerDescription = node2.tuple.map((element) => element.kind === "optionals" ? `${element.node.nestableExpression}?` : element.kind === "variadic" ? `...${element.node.nestableExpression}[]` : element.node.expression).join(", ");
      return `[${innerDescription}]`;
    }
  },
  intersections: {
    sequence: (l, r, ctx) => {
      const rootState = _intersectSequences({
        l: l.tuple,
        r: r.tuple,
        disjoint: new Disjoint(),
        result: [],
        fixedVariants: [],
        ctx
      });
      const viableBranches = rootState.disjoint.length === 0 ? [rootState, ...rootState.fixedVariants] : rootState.fixedVariants;
      return viableBranches.length === 0 ? rootState.disjoint : viableBranches.length === 1 ? ctx.$.node("sequence", sequenceTupleToInner(viableBranches[0].result)) : ctx.$.node("union", viableBranches.map((state) => ({
        proto: Array,
        sequence: sequenceTupleToInner(state.result)
      })));
    }
    // exactLength, minLength, and maxLength don't need to be defined
    // here since impliedSiblings guarantees they will be added
    // directly to the IntersectionNode parent of the SequenceNode
    // they exist on
  }
});
var SequenceNode = (() => {
  var _a5;
  let _classSuper = BaseConstraint;
  let _instanceExtraInitializers = [];
  let _get_element_decorators;
  return _a5 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __publicField(this, "impliedBasis", (__runInitializers6(this, _instanceExtraInitializers), $ark.intrinsic.Array));
      __publicField(this, "prefix", this.inner.prefix ?? []);
      __publicField(this, "optionals", this.inner.optionals ?? []);
      __publicField(this, "prevariadic", [...this.prefix, ...this.optionals]);
      __publicField(this, "postfix", this.inner.postfix ?? []);
      __publicField(this, "variadicOrPostfix", this.variadic ? [this.variadic, ...this.postfix] : this.postfix);
      __publicField(this, "isVariadicOnly", this.prevariadic.length + this.postfix.length === 0);
      __publicField(this, "minVariadicLength", this.inner.minVariadicLength ?? 0);
      __publicField(this, "minLength", this.prefix.length + this.minVariadicLength + this.postfix.length);
      __publicField(this, "minLengthNode", this.minLength === 0 ? null : this.$.node("minLength", this.minLength));
      __publicField(this, "maxLength", this.variadic ? null : this.minLength + this.optionals.length);
      __publicField(this, "maxLengthNode", this.maxLength === null ? null : this.$.node("maxLength", this.maxLength));
      __publicField(this, "impliedSiblings", this.minLengthNode ? this.maxLengthNode ? [this.minLengthNode, this.maxLengthNode] : [this.minLengthNode] : this.maxLengthNode ? [this.maxLengthNode] : []);
      // minLength/maxLength should be checked by Intersection before either traversal
      __publicField(this, "traverseAllows", (data, ctx) => {
        for (let i = 0; i < data.length; i++)
          if (!this.childAtIndex(data, i).traverseAllows(data[i], ctx))
            return false;
        return true;
      });
      __publicField(this, "traverseApply", (data, ctx) => {
        for (let i = 0; i < data.length; i++) {
          ctx.path.push(i);
          this.childAtIndex(data, i).traverseApply(data[i], ctx);
          ctx.path.pop();
        }
      });
      __publicField(this, "tuple", sequenceInnerToTuple(this.inner));
      // this depends on tuple so needs to come after it
      __publicField(this, "expression", this.description);
    }
    childAtIndex(data, index) {
      if (index < this.prevariadic.length)
        return this.prevariadic[index];
      const firstPostfixIndex = data.length - this.postfix.length;
      if (index >= firstPostfixIndex)
        return this.postfix[index - firstPostfixIndex];
      return this.variadic ?? throwInternalError(`Unexpected attempt to access index ${index} on ${this}`);
    }
    get flatRefs() {
      const refs = [];
      appendUniqueFlatRefs(refs, this.prevariadic.flatMap((element, i) => append(element.flatRefs.map((ref) => flatRef([`${i}`, ...ref.path], ref.node)), flatRef([`${i}`], element))));
      appendUniqueFlatRefs(refs, this.variadicOrPostfix.flatMap((element) => (
        // a postfix index can't be directly represented as a type
        // key, so we just use the same matcher for variadic
        append(element.flatRefs.map((ref) => flatRef([$ark.intrinsic.nonNegativeIntegerString, ...ref.path], ref.node)), flatRef([$ark.intrinsic.nonNegativeIntegerString], element))
      )));
      return refs;
    }
    get element() {
      return this.$.node("union", this.children);
    }
    // minLength/maxLength compilation should be handled by Intersection
    compile(js) {
      this.prefix.forEach((node2, i) => js.traverseKey(`${i}`, `data[${i}]`, node2));
      this.optionals.forEach((node2, i) => {
        const dataIndex = `${i + this.prefix.length}`;
        js.if(`${dataIndex} >= ${js.data}.length`, () => js.traversalKind === "Allows" ? js.return(true) : js.return());
        js.traverseKey(dataIndex, `data[${dataIndex}]`, node2);
      });
      if (this.variadic) {
        if (this.postfix.length) {
          js.const("firstPostfixIndex", `${js.data}.length${this.postfix.length ? `- ${this.postfix.length}` : ""}`);
        }
        js.for(`i < ${this.postfix.length ? "firstPostfixIndex" : "data.length"}`, () => js.traverseKey("i", "data[i]", this.variadic), this.prevariadic.length);
        this.postfix.forEach((node2, i) => {
          const keyExpression = `firstPostfixIndex + ${i}`;
          js.traverseKey(keyExpression, `data[${keyExpression}]`, node2);
        });
      }
      if (js.traversalKind === "Allows")
        js.return(true);
    }
    _transform(mapper, ctx) {
      ctx.path.push($ark.intrinsic.nonNegativeIntegerString);
      const result = super._transform(mapper, ctx);
      ctx.path.pop();
      return result;
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _get_element_decorators = [cached];
    __esDecorate6(_a5, null, _get_element_decorators, { kind: "getter", name: "element", static: false, private: false, access: { has: (obj) => "element" in obj, get: (obj) => obj.element }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_a5, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a5;
})();
var sequenceInnerToTuple = (inner) => {
  var _a5, _b3, _c;
  const tuple = [];
  (_a5 = inner.prefix) == null ? void 0 : _a5.forEach((node2) => tuple.push({ kind: "prefix", node: node2 }));
  (_b3 = inner.optionals) == null ? void 0 : _b3.forEach((node2) => tuple.push({ kind: "optionals", node: node2 }));
  if (inner.variadic)
    tuple.push({ kind: "variadic", node: inner.variadic });
  (_c = inner.postfix) == null ? void 0 : _c.forEach((node2) => tuple.push({ kind: "postfix", node: node2 }));
  return tuple;
};
var sequenceTupleToInner = (tuple) => tuple.reduce((result, node2) => {
  if (node2.kind === "variadic")
    result.variadic = node2.node;
  else
    result[node2.kind] = append(result[node2.kind], node2.node);
  return result;
}, {});
var postfixFollowingOptionalMessage = "A postfix required element cannot follow an optional element";
var postfixWithoutVariadicMessage = "A postfix element requires a variadic element";
var _intersectSequences = (s) => {
  var _a5, _b3;
  const [lHead, ...lTail] = s.l;
  const [rHead, ...rTail] = s.r;
  if (!lHead || !rHead)
    return s;
  const lHasPostfix = ((_a5 = lTail.at(-1)) == null ? void 0 : _a5.kind) === "postfix";
  const rHasPostfix = ((_b3 = rTail.at(-1)) == null ? void 0 : _b3.kind) === "postfix";
  const kind = lHead.kind === "prefix" || rHead.kind === "prefix" ? "prefix" : lHead.kind === "optionals" || rHead.kind === "optionals" ? (
    // if either operand has postfix elements, the full-length
    // intersection can't include optional elements (though they may
    // exist in some of the fixed length variants)
    lHasPostfix || rHasPostfix ? "prefix" : "optionals"
  ) : lHead.kind === "postfix" || rHead.kind === "postfix" ? "postfix" : "variadic";
  if (lHead.kind === "prefix" && rHead.kind === "variadic" && rHasPostfix) {
    const postfixBranchResult = _intersectSequences({
      ...s,
      fixedVariants: [],
      r: rTail.map((element) => ({ ...element, kind: "prefix" }))
    });
    if (postfixBranchResult.disjoint.length === 0)
      s.fixedVariants.push(postfixBranchResult);
  } else if (rHead.kind === "prefix" && lHead.kind === "variadic" && lHasPostfix) {
    const postfixBranchResult = _intersectSequences({
      ...s,
      fixedVariants: [],
      l: lTail.map((element) => ({ ...element, kind: "prefix" }))
    });
    if (postfixBranchResult.disjoint.length === 0)
      s.fixedVariants.push(postfixBranchResult);
  }
  const result = intersectNodes(lHead.node, rHead.node, s.ctx);
  if (result instanceof Disjoint) {
    if (kind === "prefix" || kind === "postfix") {
      s.disjoint.push(...result.withPrefixKey(
        // TODO: more precise path handling for Disjoints
        kind === "prefix" ? `${s.result.length}` : `-${lTail.length + 1}`,
        "required"
      ));
      s.result = [...s.result, { kind, node: $ark.intrinsic.never.internal }];
    } else if (kind === "optionals") {
      return s;
    } else {
      return _intersectSequences({
        ...s,
        fixedVariants: [],
        // if there were any optional elements, there will be no postfix elements
        // so this mapping will never occur (which would be illegal otherwise)
        l: lTail.map((element) => ({ ...element, kind: "prefix" })),
        r: lTail.map((element) => ({ ...element, kind: "prefix" }))
      });
    }
  } else
    s.result = [...s.result, { kind, node: result }];
  const lRemaining = s.l.length;
  const rRemaining = s.r.length;
  if (lHead.kind !== "variadic" || lRemaining >= rRemaining && (rHead.kind === "variadic" || rRemaining === 1))
    s.l = lTail;
  if (rHead.kind !== "variadic" || rRemaining >= lRemaining && (lHead.kind === "variadic" || lRemaining === 1))
    s.r = rTail;
  return _intersectSequences(s);
};

// node_modules/@ark/schema/out/structure/shared.js
var arrayIndexSource = `^(?:0|[1-9]\\d*)$`;
var arrayIndexMatcher = new RegExp(arrayIndexSource);
var arrayIndexMatcherReference = registeredReference(arrayIndexMatcher);

// node_modules/@ark/schema/out/structure/structure.js
var __runInitializers7 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate7 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var StructureNode = (() => {
  var _a5, _b3, _c;
  let _classSuper = BaseConstraint;
  let _instanceExtraInitializers = [];
  let _keyof_decorators;
  return _c = class extends _classSuper {
    constructor() {
      super(...arguments);
      __publicField(this, "impliedBasis", (__runInitializers7(this, _instanceExtraInitializers), $ark.intrinsic.object));
      __publicField(this, "impliedSiblings", this.children.flatMap((n) => n.impliedSiblings ?? []));
      __publicField(this, "props", this.required ? this.optional ? [...this.required, ...this.optional] : this.required : this.optional ?? []);
      __publicField(this, "propsByKey", flatMorph(this.props, (i, node2) => [node2.key, node2]));
      __publicField(this, "propsByKeyReference", registeredReference(this.propsByKey));
      __publicField(this, "expression", structuralExpression(this));
      __publicField(this, "requiredLiteralKeys", ((_a5 = this.required) == null ? void 0 : _a5.map((node2) => node2.key)) ?? []);
      __publicField(this, "optionalLiteralKeys", ((_b3 = this.optional) == null ? void 0 : _b3.map((node2) => node2.key)) ?? []);
      __publicField(this, "literalKeys", [
        ...this.requiredLiteralKeys,
        ...this.optionalLiteralKeys
      ]);
      __publicField(this, "exhaustive", this.undeclared !== void 0 || this.index !== void 0);
      __publicField(this, "traverseAllows", (data, ctx) => this._traverse("Allows", data, ctx));
      __publicField(this, "traverseApply", (data, ctx) => this._traverse("Apply", data, ctx));
      __publicField(this, "_traverse", (traversalKind, data, ctx) => {
        const errorCount = (ctx == null ? void 0 : ctx.currentErrorCount) ?? 0;
        for (let i = 0; i < this.props.length; i++) {
          if (traversalKind === "Allows") {
            if (!this.props[i].traverseAllows(data, ctx))
              return false;
          } else {
            this.props[i].traverseApply(data, ctx);
            if (ctx.failFast && ctx.currentErrorCount > errorCount)
              return false;
          }
        }
        if (this.sequence) {
          if (traversalKind === "Allows") {
            if (!this.sequence.traverseAllows(data, ctx))
              return false;
          } else {
            this.sequence.traverseApply(data, ctx);
            if (ctx.failFast && ctx.currentErrorCount > errorCount)
              return false;
          }
        }
        if (!this.exhaustive)
          return true;
        const keys = Object.keys(data);
        keys.push(...Object.getOwnPropertySymbols(data));
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          let matched = false;
          if (this.index) {
            for (const node2 of this.index) {
              if (node2.signature.traverseAllows(k, ctx)) {
                if (traversalKind === "Allows") {
                  ctx == null ? void 0 : ctx.path.push(k);
                  const result = node2.value.traverseAllows(data[k], ctx);
                  ctx == null ? void 0 : ctx.path.pop();
                  if (!result)
                    return false;
                } else {
                  ctx.path.push(k);
                  node2.value.traverseApply(data[k], ctx);
                  ctx.path.pop();
                  if (ctx.failFast && ctx.currentErrorCount > errorCount)
                    return false;
                }
                matched = true;
              }
            }
          }
          if (this.undeclared) {
            matched || (matched = k in this.propsByKey);
            matched || (matched = this.sequence !== void 0 && typeof k === "string" && $ark.intrinsic.nonNegativeIntegerString.allows(k));
            if (!matched) {
              if (traversalKind === "Allows")
                return false;
              if (this.undeclared === "reject")
                ctx.error({ expected: "removed", actual: null, relativePath: [k] });
              else {
                ctx.queueMorphs([
                  (data2) => {
                    delete data2[k];
                    return data2;
                  }
                ]);
              }
              if (ctx.failFast)
                return false;
            }
          }
          ctx == null ? void 0 : ctx.path.pop();
        }
        return true;
      });
    }
    keyof() {
      var _a6;
      let branches = this.$.units(this.literalKeys).branches;
      (_a6 = this.index) == null ? void 0 : _a6.forEach(({ signature }) => {
        branches = branches.concat(signature.branches);
      });
      return this.$.node("union", branches);
    }
    get(key, ...tail) {
      var _a6, _b4;
      let value;
      let required = false;
      if (hasArkKind(key, "root") && key.hasKind("unit"))
        key = key.unit;
      if ((typeof key === "string" || typeof key === "symbol") && this.propsByKey[key]) {
        value = this.propsByKey[key].value;
        required = this.propsByKey[key].required;
      }
      (_a6 = this.index) == null ? void 0 : _a6.forEach((n) => {
        if (n.signature.includes(key))
          value = (value == null ? void 0 : value.and(n.value)) ?? n.value;
      });
      if (this.sequence && $ark.intrinsic.nonNegativeIntegerString.includes(key)) {
        if (hasArkKind(key, "root")) {
          if (this.sequence.variadic)
            value = (value == null ? void 0 : value.and(this.sequence.element)) ?? this.sequence.element;
        } else {
          const index = Number.parseInt(key);
          if (index < this.sequence.prevariadic.length) {
            const fixedElement = this.sequence.prevariadic[index];
            value = (value == null ? void 0 : value.and(fixedElement)) ?? fixedElement;
            required || (required = index < this.sequence.prefix.length);
          } else if (this.sequence.variadic) {
            const nonFixedElement = this.$.node("union", this.sequence.variadicOrPostfix);
            value = (value == null ? void 0 : value.and(nonFixedElement)) ?? nonFixedElement;
          }
        }
      }
      if (!value) {
        if (((_b4 = this.sequence) == null ? void 0 : _b4.variadic) && hasArkKind(key, "root") && key.extends($ark.intrinsic.number)) {
          return throwParseError(writeRawNumberIndexMessage(key.expression, this.sequence.expression));
        }
        return throwParseError(writeBadKeyAccessMessage(key, this.expression));
      }
      const result = value.get(...tail);
      return required ? result : result.or($ark.intrinsic.undefined);
    }
    omit(...keys) {
      return this.$.node("structure", omitFromInner(this.inner, keys));
    }
    merge(r) {
      const inner = makeRootAndArrayPropertiesMutable(omitFromInner(this.inner, [r.keyof()]));
      if (r.required)
        inner.required = append(inner.required, r.required);
      if (r.optional)
        inner.optional = append(inner.optional, r.optional);
      if (r.index)
        inner.index = append(inner.index, r.index);
      if (r.sequence)
        inner.sequence = r.sequence;
      if (r.undeclared)
        inner.undeclared = r.undeclared;
      else
        delete inner.undeclared;
      return this.$.node("structure", inner);
    }
    compile(js) {
      if (js.traversalKind === "Apply")
        js.initializeErrorCount();
      this.props.forEach((prop) => {
        js.check(prop);
        if (js.traversalKind === "Apply")
          js.returnIfFailFast();
      });
      if (this.sequence) {
        js.check(this.sequence);
        if (js.traversalKind === "Apply")
          js.returnIfFailFast();
      }
      if (this.exhaustive) {
        js.const("keys", "Object.keys(data)");
        js.line("keys.push(...Object.getOwnPropertySymbols(data))");
        js.for("i < keys.length", () => this.compileExhaustiveEntry(js));
      }
      if (js.traversalKind === "Allows")
        js.return(true);
    }
    compileExhaustiveEntry(js) {
      var _a6, _b4;
      js.const("k", "keys[i]");
      if (this.undeclared)
        js.let("matched", false);
      (_a6 = this.index) == null ? void 0 : _a6.forEach((node2) => {
        js.if(`${js.invoke(node2.signature, { arg: "k", kind: "Allows" })}`, () => {
          js.traverseKey("k", "data[k]", node2.value);
          if (this.undeclared)
            js.set("matched", true);
          return js;
        });
      });
      if (this.undeclared) {
        if (((_b4 = this.props) == null ? void 0 : _b4.length) !== 0)
          js.line(`matched ||= k in ${this.propsByKeyReference}`);
        if (this.sequence) {
          js.line(`matched ||= typeof k === "string" && ${arrayIndexMatcherReference}.test(k)`);
        }
        js.if("!matched", () => {
          if (js.traversalKind === "Allows")
            return js.return(false);
          return this.undeclared === "reject" ? js.line(`ctx.error({ expected: "removed", actual: null, relativePath: [k] })`).if("ctx.failFast", () => js.return()) : js.line(`ctx.queueMorphs([data => { delete data[k]; return data }])`);
        });
      }
      return js;
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _keyof_decorators = [cached];
    __esDecorate7(_c, null, _keyof_decorators, { kind: "method", name: "keyof", static: false, private: false, access: { has: (obj) => "keyof" in obj, get: (obj) => obj.keyof }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_c, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _c;
})();
var omitFromInner = (inner, keys) => {
  const result = { ...inner };
  keys.forEach((k) => {
    if (result.required) {
      result.required = result.required.filter((b) => hasArkKind(k, "root") ? !k.allows(b.key) : k !== b.key);
    }
    if (result.optional) {
      result.optional = result.optional.filter((b) => hasArkKind(k, "root") ? !k.allows(b.key) : k !== b.key);
    }
    if (result.index && hasArkKind(k, "root")) {
      result.index = result.index.filter((n) => !n.signature.extends(k));
    }
  });
  return result;
};
var createStructuralWriter = (childStringProp) => (node2) => {
  var _a5, _b3;
  if (node2.props.length || node2.index) {
    const parts = ((_a5 = node2.index) == null ? void 0 : _a5.map(String)) ?? [];
    node2.props.forEach((node3) => parts.push(node3[childStringProp]));
    if (node2.undeclared)
      parts.push(`+ (undeclared): ${node2.undeclared}`);
    const objectLiteralDescription = `{ ${parts.join(", ")} }`;
    return node2.sequence ? `${objectLiteralDescription} & ${node2.sequence.description}` : objectLiteralDescription;
  }
  return ((_b3 = node2.sequence) == null ? void 0 : _b3.description) ?? "{}";
};
var structuralDescription = createStructuralWriter("description");
var structuralExpression = createStructuralWriter("expression");
var structureImplementation = implementNode({
  kind: "structure",
  hasAssociatedError: false,
  normalize: (schema2) => schema2,
  keys: {
    required: {
      child: true,
      parse: constraintKeyParser("required")
    },
    optional: {
      child: true,
      parse: constraintKeyParser("optional")
    },
    index: {
      child: true,
      parse: constraintKeyParser("index")
    },
    sequence: {
      child: true,
      parse: constraintKeyParser("sequence")
    },
    undeclared: {
      parse: (behavior) => behavior === "ignore" ? void 0 : behavior
    }
  },
  defaults: {
    description: structuralDescription
  },
  intersections: {
    structure: (l, r, ctx) => {
      const lInner = { ...l.inner };
      const rInner = { ...r.inner };
      if (l.undeclared) {
        const lKey = l.keyof();
        const disjointRKeys = r.requiredLiteralKeys.filter((k) => !lKey.allows(k));
        if (disjointRKeys.length) {
          return new Disjoint(...disjointRKeys.map((k) => ({
            kind: "presence",
            l: $ark.intrinsic.never.internal,
            r: r.propsByKey[k].value,
            path: [k],
            optional: false
          })));
        }
        if (rInner.optional)
          rInner.optional = rInner.optional.filter((n) => lKey.allows(n.key));
        if (rInner.index) {
          rInner.index = rInner.index.flatMap((n) => {
            if (n.signature.extends(lKey))
              return n;
            const indexOverlap = intersectNodesRoot(lKey, n.signature, ctx.$);
            if (indexOverlap instanceof Disjoint)
              return [];
            const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);
            if (normalized.required) {
              rInner.required = rInner.required ? [...rInner.required, ...normalized.required] : normalized.required;
            }
            return normalized.index ?? [];
          });
        }
      }
      if (r.undeclared) {
        const rKey = r.keyof();
        const disjointLKeys = l.requiredLiteralKeys.filter((k) => !rKey.allows(k));
        if (disjointLKeys.length) {
          return new Disjoint(...disjointLKeys.map((k) => ({
            kind: "presence",
            l: l.propsByKey[k].value,
            r: $ark.intrinsic.never.internal,
            path: [k],
            optional: false
          })));
        }
        if (lInner.optional)
          lInner.optional = lInner.optional.filter((n) => rKey.allows(n.key));
        if (lInner.index) {
          lInner.index = lInner.index.flatMap((n) => {
            if (n.signature.extends(rKey))
              return n;
            const indexOverlap = intersectNodesRoot(rKey, n.signature, ctx.$);
            if (indexOverlap instanceof Disjoint)
              return [];
            const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);
            if (normalized.required) {
              lInner.required = lInner.required ? [...lInner.required, ...normalized.required] : normalized.required;
            }
            return normalized.index ?? [];
          });
        }
      }
      const baseInner = {};
      if (l.undeclared || r.undeclared) {
        baseInner.undeclared = l.undeclared === "reject" || r.undeclared === "reject" ? "reject" : "delete";
      }
      return intersectConstraints({
        kind: "structure",
        baseInner,
        l: flattenConstraints(lInner),
        r: flattenConstraints(rInner),
        roots: [],
        ctx
      });
    }
  }
});
var writeRawNumberIndexMessage = (indexExpression, sequenceExpression) => `${indexExpression} is not allowed as an array index on ${sequenceExpression}. Use the 'nonNegativeIntegerString' keyword instead.`;
var writeBadKeyAccessMessage = (key, structuralExpression2) => `${printable(key)} does not exist on ${structuralExpression2}`;
var normalizeIndex = (signature, value, $2) => {
  const [enumerableBranches, nonEnumerableBranches] = spliterate(signature.branches, (k) => k.hasKind("unit"));
  if (!enumerableBranches.length)
    return { index: $2.node("index", { signature, value }) };
  const normalized = {};
  normalized.required = enumerableBranches.map((n) => $2.node("required", { key: n.unit, value }));
  if (nonEnumerableBranches.length) {
    normalized.index = $2.node("index", {
      signature: nonEnumerableBranches,
      value
    });
  }
  return normalized;
};

// node_modules/@ark/schema/out/kinds.js
var nodeImplementationsByKind = {
  ...boundImplementationsByKind,
  alias: aliasImplementation,
  domain: domainImplementation,
  unit: unitImplementation,
  proto: protoImplementation,
  union: unionImplementation,
  morph: morphImplementation,
  intersection: intersectionImplementation,
  divisor: divisorImplementation,
  pattern: patternImplementation,
  predicate: predicateImplementation,
  required: requiredImplementation,
  optional: optionalImplementation,
  index: indexImplementation,
  sequence: sequenceImplementation,
  structure: structureImplementation
};
$ark.defaultConfig = Object.assign(flatMorph(nodeImplementationsByKind, (kind, implementation) => [
  kind,
  implementation.defaults
]), {
  jitless: envHasCsp(),
  intrinsic: false,
  prereducedAliases: false
});
var nodeClassesByKind = {
  ...boundClassesByKind,
  alias: AliasNode,
  domain: DomainNode,
  unit: UnitNode,
  proto: ProtoNode,
  union: UnionNode,
  morph: MorphNode,
  intersection: IntersectionNode,
  divisor: DivisorNode,
  pattern: PatternNode,
  predicate: PredicateNode,
  required: RequiredNode,
  optional: OptionalNode,
  index: IndexNode,
  sequence: SequenceNode,
  structure: StructureNode
};

// node_modules/@ark/schema/out/module.js
var RootModule = class extends DynamicBase {
  // ensure `[arkKind]` is non-enumerable so it doesn't get spread on import/export
  get [arkKind]() {
    return "module";
  }
};

// node_modules/@ark/schema/out/parse.js
var schemaKindOf = (schema2, allowedKinds) => {
  const kind = discriminateRootKind(schema2);
  if (allowedKinds && !allowedKinds.includes(kind)) {
    return throwParseError(`Root of kind ${kind} should be one of ${allowedKinds}`);
  }
  return kind;
};
var discriminateRootKind = (schema2) => {
  if (hasArkKind(schema2, "root"))
    return schema2.kind;
  if (typeof schema2 === "string")
    return schema2[0] === "$" ? "alias" : "domain";
  if (typeof schema2 === "function")
    return "proto";
  if (typeof schema2 !== "object" || schema2 === null)
    return throwParseError(writeInvalidSchemaMessage(schema2));
  if ("morphs" in schema2)
    return "morph";
  if ("branches" in schema2 || isArray(schema2))
    return "union";
  if ("unit" in schema2)
    return "unit";
  if ("alias" in schema2)
    return "alias";
  const schemaKeys = Object.keys(schema2);
  if (schemaKeys.length === 0 || schemaKeys.some((k) => k in constraintKeys))
    return "intersection";
  if ("proto" in schema2)
    return "proto";
  if ("domain" in schema2)
    return "domain";
  return throwParseError(writeInvalidSchemaMessage(schema2));
};
var writeInvalidSchemaMessage = (schema2) => `${printable(schema2)} is not a valid type schema`;
var nodeCache = {};
var nodeCountsByPrefix = {};
var serializeListableChild = (listableNode) => isArray(listableNode) ? listableNode.map((node2) => node2.collapsibleJson) : listableNode.collapsibleJson;
var registerNodeId = (kind, opts) => {
  const prefix = opts.alias ?? kind;
  nodeCountsByPrefix[prefix] ?? (nodeCountsByPrefix[prefix] = 0);
  return `${prefix}${++nodeCountsByPrefix[prefix]}`;
};
var parseNode = (id2, kind, schema2, $2, opts) => {
  const ctx = {
    ...opts,
    $: $2,
    args: opts.args ?? {},
    schema: schema2,
    id: id2
  };
  return _parseNode(kind, ctx);
};
var _parseNode = (kind, ctx) => {
  const impl = nodeImplementationsByKind[kind];
  const inner = {};
  const schemaEntries = entriesOf(ctx.schema).sort(([lKey], [rKey]) => isNodeKind(lKey) ? isNodeKind(rKey) ? precedenceOfKind(lKey) - precedenceOfKind(rKey) : 1 : isNodeKind(rKey) ? -1 : lKey < rKey ? -1 : 1);
  const children = [];
  for (const entry of schemaEntries) {
    const k = entry[0];
    const keyImpl = impl.keys[k];
    if (!keyImpl)
      return throwParseError(`Key ${k} is not valid on ${kind} schema`);
    const v = keyImpl.parse ? keyImpl.parse(entry[1], ctx) : entry[1];
    if (v !== unset && (v !== void 0 || keyImpl.preserveUndefined))
      inner[k] = v;
  }
  const entries = entriesOf(inner);
  let json2 = {};
  let typeJson = {};
  entries.forEach(([k, v]) => {
    const keyImpl = impl.keys[k];
    const serialize = keyImpl.serialize ?? (keyImpl.child ? serializeListableChild : defaultValueSerializer);
    json2[k] = serialize(v);
    if (keyImpl.child) {
      const listableNode = v;
      if (isArray(listableNode))
        children.push(...listableNode);
      else
        children.push(listableNode);
    }
    if (!keyImpl.meta)
      typeJson[k] = json2[k];
  });
  if (impl.finalizeJson) {
    json2 = impl.finalizeJson(json2);
    typeJson = impl.finalizeJson(typeJson);
  }
  let collapsibleJson = json2;
  const collapsibleKeys = Object.keys(collapsibleJson);
  if (collapsibleKeys.length === 1 && collapsibleKeys[0] === impl.collapsibleKey) {
    collapsibleJson = collapsibleJson[impl.collapsibleKey];
    if (
      // if the collapsibleJson is still an object
      hasDomain(collapsibleJson, "object") && // and the JSON did not include any implied keys
      Object.keys(json2).length === 1
    ) {
      json2 = collapsibleJson;
      typeJson = collapsibleJson;
    }
  }
  const innerHash = JSON.stringify({ kind, ...json2 });
  if (ctx.reduceTo) {
    nodeCache[innerHash] = ctx.reduceTo;
    return ctx.reduceTo;
  }
  const typeHash = JSON.stringify({ kind, ...typeJson });
  if (impl.reduce && !ctx.prereduced) {
    const reduced = impl.reduce(inner, ctx.$);
    if (reduced) {
      if (reduced instanceof Disjoint)
        return reduced.throw();
      if (ctx.alias)
        reduced.alias ?? (reduced.alias = ctx.alias);
      return reduced;
    }
  }
  if (nodeCache[innerHash])
    return nodeCache[innerHash];
  const attachments = {
    id: ctx.id,
    kind,
    impl,
    inner,
    entries,
    json: json2,
    typeJson,
    collapsibleJson,
    children,
    innerHash,
    typeHash
  };
  if (ctx.alias)
    attachments.alias = ctx.alias;
  for (const k in inner) {
    if (k !== "description" && k !== "in" && k !== "out")
      attachments[k] = inner[k];
  }
  const node2 = new nodeClassesByKind[kind](attachments, ctx.$);
  return nodeCache[innerHash] = node2;
};

// node_modules/@ark/schema/out/shared/compile.js
var NodeCompiler = class extends CompiledFunction {
  constructor(traversalKind) {
    super("data", "ctx");
    __publicField(this, "traversalKind");
    __publicField(this, "path", []);
    __publicField(this, "discriminants", []);
    this.traversalKind = traversalKind;
  }
  invoke(node2, opts) {
    const arg = (opts == null ? void 0 : opts.arg) ?? this.data;
    if (this.requiresContextFor(node2))
      return `${this.reference(node2, opts)}(${arg}, ${this.ctx})`;
    return `${this.reference(node2, opts)}(${arg})`;
  }
  reference(node2, opts) {
    const invokedKind = (opts == null ? void 0 : opts.kind) ?? this.traversalKind;
    const base = `this.${node2.id}${invokedKind}`;
    return (opts == null ? void 0 : opts.bind) ? `${base}.bind(${opts == null ? void 0 : opts.bind})` : base;
  }
  requiresContextFor(node2) {
    return this.traversalKind === "Apply" || node2.allowsRequiresContext;
  }
  initializeErrorCount() {
    return this.const("errorCount", "ctx.currentErrorCount");
  }
  returnIfFail() {
    return this.if("ctx.currentErrorCount > errorCount", () => this.return());
  }
  returnIfFailFast() {
    return this.if("ctx.failFast && ctx.currentErrorCount > errorCount", () => this.return());
  }
  traverseKey(keyExpression, accessExpression, node2) {
    const requiresContext = this.requiresContextFor(node2);
    if (requiresContext)
      this.line(`${this.ctx}.path.push(${keyExpression})`);
    this.check(node2, {
      arg: accessExpression
    });
    if (requiresContext)
      this.line(`${this.ctx}.path.pop()`);
    return this;
  }
  check(node2, opts) {
    return this.traversalKind === "Allows" ? this.if(`!${this.invoke(node2, opts)}`, () => this.return(false)) : this.line(this.invoke(node2, opts));
  }
  writeMethod(name) {
    return `${name}(${this.argNames.join(", ")}){
${this.body}    }
`;
  }
};

// node_modules/@ark/schema/out/scope.js
var __runInitializers8 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate8 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var schemaBranchesOf = (schema2) => isArray(schema2) ? schema2 : "branches" in schema2 && isArray(schema2.branches) ? schema2.branches : void 0;
var throwMismatchedNodeRootError = (expected, actual) => throwParseError(`Node of kind ${actual} is not valid as a ${expected} definition`);
var writeDuplicateAliasError = (alias) => `#${alias} duplicates public alias ${alias}`;
var scopesById = {};
$ark.intrinsic = {};
var RawRootScope = (() => {
  var _a5, _b3;
  let _instanceExtraInitializers = [];
  let _schema_decorators;
  let _defineRoot_decorators;
  let _generic_decorators;
  let _units_decorators;
  let _node_decorators;
  return _a5 = arkKind, _b3 = class {
    constructor(def, config) {
      __publicField(this, "config", __runInitializers8(this, _instanceExtraInitializers));
      __publicField(this, "resolvedConfig");
      __publicField(this, "id", `${Object.keys(scopesById).length}$`);
      __publicField(this, _a5, "scope");
      __publicField(this, "referencesById", {});
      __publicField(this, "references", []);
      __publicField(this, "resolutions", {});
      __publicField(this, "json", {});
      __publicField(this, "exportedNames", []);
      __publicField(this, "aliases", {});
      __publicField(this, "resolved", false);
      __publicField(this, "lazyResolutions", []);
      __publicField(this, "_exportedResolutions");
      __publicField(this, "_exports");
      this.config = config ?? {};
      this.resolvedConfig = resolveConfig(config);
      const aliasEntries = Object.entries(def).map((entry) => this.preparseAlias(...entry));
      aliasEntries.forEach(([k, v]) => {
        if (k[0] === "#") {
          const name = k.slice(1);
          if (name in this.aliases)
            throwParseError(writeDuplicateAliasError(name));
          this.aliases[name] = v;
        } else {
          if (k in this.aliases)
            throwParseError(writeDuplicateAliasError(k));
          this.aliases[k] = v;
          this.exportedNames.push(k);
        }
      });
      if ($ark.ambient) {
        $ark.ambient.export();
        this.resolutions = {};
      }
      scopesById[this.id] = this;
    }
    get internal() {
      return this;
    }
    schema(def, opts) {
      return this.node(schemaKindOf(def), def, opts);
    }
    defineRoot(def) {
      return def;
    }
    generic(params, def) {
      if (def === void 0) {
        return (def2) => this.generic(params, new LazyGenericRoot(def2));
      }
      return parseGeneric(params, def, this);
    }
    units(values, opts) {
      const uniqueValues = [];
      for (const value of values)
        if (!uniqueValues.includes(value))
          uniqueValues.push(value);
      const branches = uniqueValues.map((unit) => this.node("unit", { unit }, opts));
      return this.node("union", branches, {
        ...opts,
        prereduced: true
      });
    }
    lazilyResolve(resolve, syntheticAlias) {
      const node2 = this.node("alias", {
        alias: syntheticAlias ?? "synthetic",
        resolve
      }, { prereduced: true });
      if (!this.resolved)
        this.lazyResolutions.push(node2);
      return node2;
    }
    node(kinds, nodeSchema, opts = {}) {
      var _a6;
      let kind = typeof kinds === "string" ? kinds : schemaKindOf(nodeSchema, kinds);
      let schema2 = nodeSchema;
      if (isNode(schema2) && schema2.kind === kind)
        return schema2.bindScope(this);
      if (kind === "alias" && !(opts == null ? void 0 : opts.prereduced)) {
        const resolution = this.resolveRoot(normalizeAliasSchema(schema2).alias);
        schema2 = resolution;
        kind = resolution.kind;
      } else if (kind === "union" && hasDomain(schema2, "object")) {
        const branches = schemaBranchesOf(schema2);
        if ((branches == null ? void 0 : branches.length) === 1) {
          schema2 = branches[0];
          kind = schemaKindOf(schema2);
        }
      }
      const impl = nodeImplementationsByKind[kind];
      const normalizedSchema = ((_a6 = impl.normalize) == null ? void 0 : _a6.call(impl, schema2)) ?? schema2;
      if (isNode(normalizedSchema)) {
        return normalizedSchema.kind === kind ? normalizedSchema.bindScope(this) : throwMismatchedNodeRootError(kind, normalizedSchema.kind);
      }
      const id2 = registerNodeId(kind, opts);
      const node2 = parseNode(id2, kind, normalizedSchema, this, opts ?? {}).bindScope(this);
      if (this.resolved) {
        if (!this.resolvedConfig.jitless)
          bindCompiledScope(node2.references);
      } else {
        Object.assign(this.referencesById, node2.referencesById);
      }
      return node2;
    }
    finalizeRootArgs(opts, resolve) {
      const isResolution = opts.alias && opts.alias in this.aliases;
      resolve;
      if (!isResolution)
        opts.args ?? (opts.args = { this: $ark.intrinsic.unknown });
      return opts;
    }
    parseRoot(def, opts = {}) {
      const node2 = this.schema(def, this.finalizeRootArgs(opts, () => node2));
      return node2;
    }
    resolveRoot(name) {
      return this.maybeResolveRoot(name) ?? throwParseError(writeUnresolvableMessage(name));
    }
    maybeResolveRoot(name) {
      const result = this.maybeResolveGenericOrRoot(name);
      if (hasArkKind(result, "generic"))
        return;
      return result;
    }
    maybeResolveGenericOrRoot(name) {
      const resolution = this.maybeResolve(name);
      if (hasArkKind(resolution, "module"))
        return throwParseError(writeMissingSubmoduleAccessMessage(name));
      return resolution;
    }
    preparseRoot(def) {
      return def;
    }
    preparseAlias(k, v) {
      return [k, v];
    }
    maybeResolve(name) {
      const resolution = this.maybeShallowResolve(name);
      return typeof resolution === "string" ? this.node("alias", { alias: resolution }, { prereduced: true }) : resolution;
    }
    maybeShallowResolve(name) {
      var _a6, _b4;
      const cached2 = this.resolutions[name];
      if (cached2)
        return cached2;
      const def = this.aliases[name] ?? ((_a6 = $ark.ambient) == null ? void 0 : _a6.resolutions[name]);
      if (!def)
        return this.maybeResolveSubalias(name);
      const preparsed = this.preparseRoot(def);
      if (hasArkKind(preparsed, "generic")) {
        return this.resolutions[name] = (_b4 = preparsed.validateBaseInstantiation()) == null ? void 0 : _b4.bindScope(this);
      }
      if (hasArkKind(preparsed, "module")) {
        return this.resolutions[name] = new RootModule(flatMorph(preparsed, (alias, node2) => [
          alias,
          node2.bindScope(this)
        ]));
      }
      this.resolutions[name] = name;
      return this.resolutions[name] = this.parseRoot(preparsed, {
        alias: name
      }).bindScope(this);
    }
    /** If name is a valid reference to a submodule alias, return its resolution  */
    maybeResolveSubalias(name) {
      return maybeResolveSubalias(this.aliases, name);
    }
    import(...names) {
      return new RootModule(flatMorph(this.export(...names), (alias, value) => [
        `#${alias}`,
        value
      ]));
    }
    export(...names) {
      if (!this._exports) {
        this._exports = {};
        for (const name of this.exportedNames) {
          const resolution = this.maybeResolve(name);
          if (hasArkKind(resolution, "root")) {
            resolution.references.filter((node2) => node2.hasKind("alias")).forEach((aliasNode) => {
              Object.assign(aliasNode.referencesById, aliasNode.resolution.referencesById);
              resolution.references.forEach((ref) => {
                if (aliasNode.id in ref.referencesById)
                  Object.assign(ref.referencesById, aliasNode.referencesById);
              });
            });
          }
          this._exports[name] = resolution;
        }
        this.lazyResolutions.forEach((node2) => node2.resolution);
        this._exportedResolutions = resolutionsOfModule(this, this._exports);
        Object.assign(this.json, flatMorph(this._exportedResolutions, (k, v) => hasArkKind(v, "root") ? [k, v.json] : []));
        Object.assign(this.resolutions, this._exportedResolutions);
        if (this.config.intrinsic)
          Object.assign($ark.intrinsic, this._exportedResolutions);
        this.references = Object.values(this.referencesById);
        if (!this.resolvedConfig.jitless)
          bindCompiledScope(this.references);
        this.resolved = true;
      }
      const namesToExport = names.length ? names : this.exportedNames;
      return new RootModule(flatMorph(namesToExport, (_, name) => [
        name,
        this._exports[name]
      ]));
    }
    resolve(name) {
      return this.export()[name];
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
    _schema_decorators = [bound];
    _defineRoot_decorators = [bound];
    _generic_decorators = [bound];
    _units_decorators = [bound];
    _node_decorators = [bound];
    __esDecorate8(_b3, null, _schema_decorators, { kind: "method", name: "schema", static: false, private: false, access: { has: (obj) => "schema" in obj, get: (obj) => obj.schema }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate8(_b3, null, _defineRoot_decorators, { kind: "method", name: "defineRoot", static: false, private: false, access: { has: (obj) => "defineRoot" in obj, get: (obj) => obj.defineRoot }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate8(_b3, null, _generic_decorators, { kind: "method", name: "generic", static: false, private: false, access: { has: (obj) => "generic" in obj, get: (obj) => obj.generic }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate8(_b3, null, _units_decorators, { kind: "method", name: "units", static: false, private: false, access: { has: (obj) => "units" in obj, get: (obj) => obj.units }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate8(_b3, null, _node_decorators, { kind: "method", name: "node", static: false, private: false, access: { has: (obj) => "node" in obj, get: (obj) => obj.node }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_b3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _b3;
})();
var maybeResolveSubalias = (base, name) => {
  const dotIndex = name.indexOf(".");
  if (dotIndex === -1)
    return;
  const dotPrefix = name.slice(0, dotIndex);
  const prefixSchema = base[dotPrefix];
  if (prefixSchema === void 0)
    return;
  if (!hasArkKind(prefixSchema, "module"))
    return throwParseError(writeNonSubmoduleDotMessage(dotPrefix));
  const subalias = name.slice(dotIndex + 1);
  const resolution = prefixSchema[subalias];
  if (resolution === void 0)
    return;
  if (hasArkKind(resolution, "module"))
    return maybeResolveSubalias(resolution, subalias);
  if (hasArkKind(resolution, "root") || hasArkKind(resolution, "generic"))
    return resolution;
  throwInternalError(`Unexpected resolution for alias '${name}': ${printable(resolution)}`);
};
var schemaScope = (aliases, config) => new RootScope(aliases, config);
var RootScope = RawRootScope;
var root = new RootScope({});
var schema = root.schema;
var node = root.node;
var defineRoot = root.defineRoot;
var units = root.units;
var generic = root.generic;
var internalSchema = root.internal.schema;
var internalNode = root.internal.node;
var defineInternalRoot = root.internal.defineRoot;
var internalUnits = root.internal.units;
var internalGeneric = root.internal.generic;
var resolutionsOfModule = ($2, typeSet) => {
  const result = {};
  for (const k in typeSet) {
    const v = typeSet[k];
    if (hasArkKind(v, "module")) {
      const innerResolutions = resolutionsOfModule($2, v);
      const prefixedResolutions = flatMorph(innerResolutions, (innerK, innerV) => [`${k}.${innerK}`, innerV]);
      Object.assign(result, prefixedResolutions);
    } else if (hasArkKind(v, "generic"))
      result[k] = v;
    else if (hasArkKind(v, "root"))
      result[k] = v;
    else
      throwInternalError(`Unexpected scope resolution ${printable(v)}`);
  }
  return result;
};
var writeUnresolvableMessage = (token) => `'${token}' is unresolvable`;
var writeNonSubmoduleDotMessage = (name) => `'${name}' must reference a module to be accessed using dot syntax`;
var writeMissingSubmoduleAccessMessage = (name) => `Reference to submodule '${name}' must specify an alias`;
var bindCompiledScope = (references) => {
  const compiledTraversals = compileScope(references);
  for (const node2 of references) {
    if (node2.jit) {
      continue;
    }
    node2.jit = true;
    node2.traverseAllows = compiledTraversals[`${node2.id}Allows`].bind(compiledTraversals);
    if (node2.isRoot() && !node2.allowsRequiresContext) {
      node2.allows = node2.traverseAllows;
    }
    node2.traverseApply = compiledTraversals[`${node2.id}Apply`].bind(compiledTraversals);
  }
};
var compileScope = (references) => new CompiledFunction().block("return", (js) => {
  references.forEach((node2) => {
    const allowsCompiler = new NodeCompiler("Allows").indent();
    node2.compile(allowsCompiler);
    const applyCompiler = new NodeCompiler("Apply").indent();
    node2.compile(applyCompiler);
    js.line(`${allowsCompiler.writeMethod(`${node2.id}Allows`)},`).line(`${applyCompiler.writeMethod(`${node2.id}Apply`)},`);
  });
  return js;
}).compile()();

// node_modules/@ark/schema/out/keywords/tsKeywords.js
var tsKeywords = schemaScope({
  any: {},
  bigint: "bigint",
  // since we know this won't be reduced, it can be safely cast to a union
  boolean: [{ unit: false }, { unit: true }],
  false: { unit: false },
  never: [],
  null: { unit: null },
  number: "number",
  object: "object",
  string: "string",
  symbol: "symbol",
  true: { unit: true },
  unknown: {},
  void: { unit: void 0 },
  undefined: { unit: void 0 }
}, { prereducedAliases: true, intrinsic: true }).export();

// node_modules/@ark/schema/out/keywords/internal.js
var internal = schemaScope({
  lengthBoundable: ["string", Array],
  propertyKey: ["string", "symbol"],
  nonNegativeIntegerString: { domain: "string", pattern: arrayIndexSource }
}, {
  prereducedAliases: true,
  intrinsic: true
}).export();
root.node("union", {
  branches: [
    "string",
    "number",
    "object",
    "bigint",
    "symbol",
    { unit: true },
    { unit: false },
    { unit: null },
    { unit: void 0 }
  ]
}, { reduceTo: root.node("intersection", {}, { prereduced: true }) });

// node_modules/@ark/schema/out/keywords/jsObjects.js
var jsObjects = schemaScope({
  Array,
  Function,
  Date,
  Error,
  Map,
  RegExp,
  Set,
  WeakMap,
  WeakSet,
  Promise
}, { prereducedAliases: true, intrinsic: true }).export();

// node_modules/@ark/schema/out/keywords/format.js
var trim = defineRoot({
  in: "string",
  morphs: (s) => s.trim()
});
var uppercase = defineRoot({
  in: "string",
  morphs: (s) => s.toUpperCase()
});
var lowercase = defineRoot({
  in: "string",
  morphs: (s) => s.toLowerCase()
});
var formatting = schemaScope({
  trim,
  uppercase,
  lowercase
}).export();

// node_modules/@ark/schema/out/keywords/utils/date.js
var dayDelimiterMatcher = /^[./-]$/;
var iso8601Matcher = /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
var isValidDateInstance = (date2) => !Number.isNaN(+date2);
var writeFormattedExpected = (format) => `a ${format}-formatted date`;
var tryParseDatePattern = (data, opts) => {
  if (!(opts == null ? void 0 : opts.format)) {
    const result = new Date(data);
    return isValidDateInstance(result) ? result : "a valid date";
  }
  if (opts.format === "iso8601") {
    return iso8601Matcher.test(data) ? new Date(data) : writeFormattedExpected("iso8601");
  }
  const dataParts = data.split(dayDelimiterMatcher);
  const delimiter = data[dataParts[0].length];
  const formatParts = delimiter ? opts.format.split(delimiter) : [opts.format];
  if (dataParts.length !== formatParts.length)
    return writeFormattedExpected(opts.format);
  const parsedParts = {};
  for (let i = 0; i < formatParts.length; i++) {
    if (dataParts[i].length !== formatParts[i].length && // if format is "m" or "d", data is allowed to be 1 or 2 characters
    !(formatParts[i].length === 1 && dataParts[i].length === 2))
      return writeFormattedExpected(opts.format);
    parsedParts[formatParts[i][0]] = dataParts[i];
  }
  const date2 = /* @__PURE__ */ new Date(`${parsedParts.m}/${parsedParts.d}/${parsedParts.y}`);
  if (`${date2.getDate()}` === parsedParts.d)
    return date2;
  return writeFormattedExpected(opts.format);
};

// node_modules/@ark/schema/out/keywords/utils/regex.js
var defineRegex = (regex, description) => defineRoot({
  domain: "string",
  pattern: {
    rule: regex.source,
    flags: regex.flags,
    description
  }
});

// node_modules/@ark/schema/out/keywords/parsing.js
var number = defineRoot({
  in: defineRegex(wellFormedNumberMatcher, "a well-formed numeric string"),
  morphs: (s) => Number.parseFloat(s)
});
var integer = defineRoot({
  in: defineRegex(wellFormedIntegerMatcher, "a well-formed integer string"),
  morphs: (s, ctx) => {
    if (!isWellFormedInteger(s))
      return ctx.error("a well-formed integer string");
    const parsed = Number.parseInt(s);
    return Number.isSafeInteger(parsed) ? parsed : ctx.error("an integer in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER");
  }
});
var url = defineRoot({
  in: "string",
  morphs: (s, ctx) => {
    try {
      return new URL(s);
    } catch {
      return ctx.error("a valid URL");
    }
  }
});
var json = defineRoot({
  in: "string",
  morphs: (s, ctx) => {
    try {
      return JSON.parse(s);
    } catch {
      return ctx.error("a valid JSON string");
    }
  }
});
var date = defineRoot({
  in: "string",
  morphs: (s, ctx) => {
    const result = tryParseDatePattern(s);
    return typeof result === "string" ? ctx.error(result) : result;
  }
});
var parsing = schemaScope({
  url,
  number,
  integer,
  date,
  json
}).export();

// node_modules/@ark/schema/out/keywords/tsGenerics.js
var $ = schemaScope({
  Record: generic([["K", $ark.intrinsic.propertyKey], "V"])((args) => ({
    domain: "object",
    index: {
      signature: args.K,
      value: args.V
    }
  }))
});
var tsGenerics = $.export();

// node_modules/@ark/schema/out/keywords/utils/creditCard.js
var isLuhnValid = (creditCardInput) => {
  const sanitized = creditCardInput.replace(/[- ]+/g, "");
  let sum = 0;
  let digit;
  let tmpNum;
  let shouldDouble = false;
  for (let i = sanitized.length - 1; i >= 0; i--) {
    digit = sanitized.substring(i, i + 1);
    tmpNum = Number.parseInt(digit, 10);
    if (shouldDouble) {
      tmpNum *= 2;
      if (tmpNum >= 10)
        sum += tmpNum % 10 + 1;
      else
        sum += tmpNum;
    } else
      sum += tmpNum;
    shouldDouble = !shouldDouble;
  }
  return !!(sum % 10 === 0 ? sanitized : false);
};
var creditCardMatcher = /^(?:4[0-9]{12}(?:[0-9]{3,6})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12,15}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14}|^(81[0-9]{14,17}))$/;

// node_modules/@ark/schema/out/keywords/utils/ip.js
var ipv4Segment = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
var ipv4Address = `(${ipv4Segment}[.]){3}${ipv4Segment}`;
var ipv4Matcher = new RegExp(`^${ipv4Address}$`);
var ipv4 = defineRegex(ipv4Matcher, "a valid IPv4 address");
var ipv6Segment = "(?:[0-9a-fA-F]{1,4})";
var ipv6Matcher = new RegExp(`^((?:${ipv6Segment}:){7}(?:${ipv6Segment}|:)|(?:${ipv6Segment}:){6}(?:${ipv4Address}|:${ipv6Segment}|:)|(?:${ipv6Segment}:){5}(?::${ipv4Address}|(:${ipv6Segment}){1,2}|:)|(?:${ipv6Segment}:){4}(?:(:${ipv6Segment}){0,1}:${ipv4Address}|(:${ipv6Segment}){1,3}|:)|(?:${ipv6Segment}:){3}(?:(:${ipv6Segment}){0,2}:${ipv4Address}|(:${ipv6Segment}){1,4}|:)|(?:${ipv6Segment}:){2}(?:(:${ipv6Segment}){0,3}:${ipv4Address}|(:${ipv6Segment}){1,5}|:)|(?:${ipv6Segment}:){1}(?:(:${ipv6Segment}){0,4}:${ipv4Address}|(:${ipv6Segment}){1,6}|:)|(?::((?::${ipv6Segment}){0,5}:${ipv4Address}|(?::${ipv6Segment}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`);
var ipv6 = defineRegex(ipv6Matcher, "a valid IPv6 address");
var ip = defineRoot([ipv4, ipv6]);

// node_modules/@ark/schema/out/keywords/validation.js
var url2 = defineRoot({
  domain: "string",
  predicate: {
    predicate: (s) => {
      try {
        new URL(s);
      } catch {
        return false;
      }
      return true;
    },
    description: "a valid URL"
  }
});
var emailMatcher = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$/;
var email = defineRegex(emailMatcher, "a valid email");
var uuidMatcher = /^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$/;
var uuid = defineRegex(uuidMatcher, "a valid UUID");
var semverMatcher = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
var semver = defineRegex(semverMatcher, "a valid semantic version (see https://semver.org/)");
var creditCard = defineRoot({
  domain: "string",
  pattern: {
    rule: creditCardMatcher.source,
    description: "a valid credit card number"
  },
  predicate: {
    predicate: isLuhnValid,
    description: "a valid credit card number"
  }
});
var validation = schemaScope({
  alpha: defineRegex(/^[A-Za-z]*$/, "only letters"),
  alphanumeric: defineRegex(/^[A-Za-z\d]*$/, "only letters and digits 0-9"),
  digits: defineRegex(/^\d*$/, "only digits 0-9"),
  lowercase: defineRegex(/^[a-z]*$/, "only lowercase letters"),
  uppercase: defineRegex(/^[A-Z]*$/, "only uppercase letters"),
  creditCard,
  email,
  uuid,
  url: url2,
  semver,
  ip,
  integer: {
    domain: "number",
    divisor: 1
  }
}, { prereducedAliases: true }).export();

// node_modules/@ark/schema/out/keywords/keywords.js
var ambientRootScope = schemaScope({
  ...tsKeywords,
  ...jsObjects,
  ...validation,
  ...internal,
  ...tsGenerics,
  parse: parsing,
  format: formatting
  // TODO: remove cast
});
$ark.ambient = ambientRootScope.internal;
var keywordNodes = ambientRootScope.export();

// node_modules/arktype/out/parser/string/shift/operand/date.js
var isDateLiteral = (value) => typeof value === "string" && value[0] === "d" && (value[1] === "'" || value[1] === '"') && value.at(-1) === value[1];
var isValidDate = (d) => d.toString() !== "Invalid Date";
var extractDateLiteralSource = (literal) => literal.slice(2, -1);
var writeInvalidDateMessage = (source) => `'${source}' could not be parsed by the Date constructor`;
var tryParseDate = (source, errorOnFail) => maybeParseDate(source, errorOnFail);
var maybeParseDate = (source, errorOnFail) => {
  const stringParsedDate = new Date(source);
  if (isValidDate(stringParsedDate))
    return stringParsedDate;
  const epochMillis = tryParseNumber(source);
  if (epochMillis !== void 0) {
    const numberParsedDate = new Date(epochMillis);
    if (isValidDate(numberParsedDate))
      return numberParsedDate;
  }
  return errorOnFail ? throwParseError(errorOnFail === true ? writeInvalidDateMessage(source) : errorOnFail) : void 0;
};

// node_modules/arktype/out/parser/string/shift/operand/enclosed.js
var parseEnclosed = (s, enclosing) => {
  const enclosed = s.scanner.shiftUntil(untilLookaheadIsClosing[enclosingTokens[enclosing]]);
  if (s.scanner.lookahead === "")
    return s.error(writeUnterminatedEnclosedMessage(enclosed, enclosing));
  s.scanner.shift();
  if (enclosing === "/") {
    new RegExp(enclosed);
    s.root = s.ctx.$.node("intersection", {
      domain: "string",
      pattern: enclosed
    }, { prereduced: true });
  } else if (isKeyOf(enclosing, enclosingQuote))
    s.root = s.ctx.$.node("unit", { unit: enclosed });
  else {
    const date2 = tryParseDate(enclosed, writeInvalidDateMessage(enclosed));
    s.root = s.ctx.$.node("unit", { unit: date2, description: enclosed });
  }
};
var enclosingQuote = {
  "'": 1,
  '"': 1
};
var enclosingChar = {
  "/": 1,
  "'": 1,
  '"': 1
};
var enclosingTokens = {
  "d'": "'",
  'd"': '"',
  "'": "'",
  '"': '"',
  "/": "/"
};
var untilLookaheadIsClosing = {
  "'": (scanner) => scanner.lookahead === `'`,
  '"': (scanner) => scanner.lookahead === `"`,
  "/": (scanner) => scanner.lookahead === `/`
};
var enclosingCharDescriptions = {
  '"': "double-quote",
  "'": "single-quote",
  "/": "forward slash"
};
var writeUnterminatedEnclosedMessage = (fragment, enclosingStart) => `${enclosingStart}${fragment} requires a closing ${enclosingCharDescriptions[enclosingTokens[enclosingStart]]}`;

// node_modules/arktype/out/parser/semantic/validate.js
var writePrefixedPrivateReferenceMessage = (def) => `Private type references should not include '#'. Use '${def.slice(1)}' instead.`;

// node_modules/arktype/out/parser/string/reduce/shared.js
var minComparators = {
  ">": true,
  ">=": true
};
var maxComparators = {
  "<": true,
  "<=": true
};
var invertedComparators = {
  "<": ">",
  ">": "<",
  "<=": ">=",
  ">=": "<=",
  "==": "=="
};
var writeUnmatchedGroupCloseMessage = (unscanned) => `Unmatched )${unscanned === "" ? "" : ` before ${unscanned}`}`;
var writeUnclosedGroupMessage = (missingChar) => `Missing ${missingChar}`;
var writeOpenRangeMessage = (min, comparator) => `Left bounds are only valid when paired with right bounds (try ...${comparator}${min})`;
var writeUnpairableComparatorMessage = (comparator) => `Left-bounded expressions must specify their limits using < or <= (was ${comparator})`;
var writeMultipleLeftBoundsMessage = (openLimit, openComparator, limit, comparator) => `An expression may have at most one left bound (parsed ${openLimit}${invertedComparators[openComparator]}, ${limit}${invertedComparators[comparator]})`;

// node_modules/arktype/out/parser/string/shift/operand/genericArgs.js
var parseGenericArgs = (name, g, s) => _parseGenericArgs(name, g, s, []);
var _parseGenericArgs = (name, g, s, argNodes) => {
  const argState = s.parseUntilFinalizer();
  argNodes.push(argState.root);
  if (argState.finalizer === ">") {
    if (argNodes.length !== g.params.length) {
      return s.error(writeInvalidGenericArgCountMessage(name, g.names, argNodes.map((arg) => arg.expression)));
    }
    return argNodes;
  }
  if (argState.finalizer === ",")
    return _parseGenericArgs(name, g, s, argNodes);
  return argState.error(writeUnclosedGroupMessage(">"));
};
var writeInvalidGenericArgCountMessage = (name, params, argDefs) => `${name}<${params.join(", ")}> requires exactly ${params.length} args (got ${argDefs.length}${argDefs.length === 0 ? "" : `: ${argDefs.join(", ")}`})`;

// node_modules/arktype/out/parser/string/shift/operand/unenclosed.js
var parseUnenclosed = (s) => {
  const token = s.scanner.shiftUntilNextTerminator();
  if (token === "keyof")
    s.addPrefix("keyof");
  else
    s.root = unenclosedToNode(s, token);
};
var parseGenericInstantiation = (name, g, s) => {
  s.scanner.shiftUntilNonWhitespace();
  const lookahead = s.scanner.shift();
  if (lookahead !== "<")
    return s.error(writeInvalidGenericArgCountMessage(name, g.names, []));
  const parsedArgs = parseGenericArgs(name, g, s);
  return g(...parsedArgs);
};
var unenclosedToNode = (s, token) => maybeParseReference(s, token) ?? maybeParseUnenclosedLiteral(s, token) ?? s.error(token === "" ? writeMissingOperandMessage(s) : token[0] === "#" ? writePrefixedPrivateReferenceMessage(token) : writeUnresolvableMessage(token));
var maybeParseReference = (s, token) => {
  var _a5;
  if ((_a5 = s.ctx.args) == null ? void 0 : _a5[token])
    return s.ctx.args[token].internal;
  const resolution = s.ctx.$.maybeResolve(token);
  if (resolution instanceof BaseRoot)
    return resolution;
  if (resolution === void 0)
    return;
  if (hasArkKind(resolution, "generic"))
    return parseGenericInstantiation(token, resolution, s);
  return throwParseError(`Unexpected resolution ${printable(resolution)}`);
};
var maybeParseUnenclosedLiteral = (s, token) => {
  const maybeNumber = tryParseWellFormedNumber(token);
  if (maybeNumber !== void 0)
    return s.ctx.$.node("unit", { unit: maybeNumber });
  const maybeBigint = tryParseWellFormedBigint(token);
  if (maybeBigint !== void 0)
    return s.ctx.$.node("unit", { unit: maybeBigint });
};
var writeMissingOperandMessage = (s) => {
  const operator = s.previousOperator();
  return operator ? writeMissingRightOperandMessage(operator, s.scanner.unscanned) : writeExpressionExpectedMessage(s.scanner.unscanned);
};
var writeMissingRightOperandMessage = (token, unscanned = "") => `Token '${token}' requires a right operand${unscanned ? ` before '${unscanned}'` : ""}`;
var writeExpressionExpectedMessage = (unscanned) => `Expected an expression${unscanned ? ` before '${unscanned}'` : ""}`;

// node_modules/arktype/out/parser/string/shift/operand/operand.js
var parseOperand = (s) => s.scanner.lookahead === "" ? s.error(writeMissingOperandMessage(s)) : s.scanner.lookahead === "(" ? s.shiftedByOne().reduceGroupOpen() : s.scanner.lookaheadIsIn(enclosingChar) ? parseEnclosed(s, s.scanner.shift()) : s.scanner.lookaheadIsIn(whiteSpaceTokens) ? parseOperand(s.shiftedByOne()) : s.scanner.lookahead === "d" ? s.scanner.nextLookahead in enclosingQuote ? parseEnclosed(s, `${s.scanner.shift()}${s.scanner.shift()}`) : parseUnenclosed(s) : parseUnenclosed(s);

// node_modules/arktype/out/parser/string/shift/scanner.js
var Scanner = class _Scanner {
  constructor(def) {
    __publicField(this, "chars");
    __publicField(this, "i");
    this.chars = [...def];
    this.i = 0;
  }
  /** Get lookahead and advance scanner by one */
  shift() {
    return this.chars[this.i++] ?? "";
  }
  get lookahead() {
    return this.chars[this.i] ?? "";
  }
  get nextLookahead() {
    return this.chars[this.i + 1] ?? "";
  }
  get length() {
    return this.chars.length;
  }
  shiftUntil(condition) {
    let shifted = "";
    while (this.lookahead) {
      if (condition(this, shifted)) {
        if (shifted[shifted.length - 1] === escapeToken)
          shifted = shifted.slice(0, -1);
        else
          break;
      }
      shifted += this.shift();
    }
    return shifted;
  }
  shiftUntilNextTerminator() {
    this.shiftUntilNonWhitespace();
    return this.shiftUntil(_Scanner.lookaheadIsTerminator);
  }
  shiftUntilNonWhitespace() {
    return this.shiftUntil(_Scanner.lookaheadIsNotWhitespace);
  }
  jumpToIndex(i) {
    this.i = i < 0 ? this.length + i : i;
  }
  jumpForward(count) {
    this.i += count;
  }
  get location() {
    return this.i;
  }
  get unscanned() {
    return this.chars.slice(this.i, this.length).join("");
  }
  get scanned() {
    return this.chars.slice(0, this.i).join("");
  }
  sliceChars(start, end) {
    return this.chars.slice(start, end).join("");
  }
  lookaheadIs(char) {
    return this.lookahead === char;
  }
  lookaheadIsIn(tokens) {
    return this.lookahead in tokens;
  }
};
(function(Scanner2) {
  Scanner2.lookaheadIsTerminator = (scanner) => scanner.lookahead in Scanner2.terminatingChars;
  Scanner2.lookaheadIsNotWhitespace = (scanner) => !(scanner.lookahead in whiteSpaceTokens);
  Scanner2.terminatingChars = {
    "<": true,
    ">": true,
    "=": true,
    "|": true,
    "&": true,
    ")": true,
    "[": true,
    "%": true,
    " ": true,
    ",": true,
    ":": true
  };
  Scanner2.finalizingLookaheads = {
    ">": true,
    ",": true,
    "": true,
    "=": true
  };
  Scanner2.lookaheadIsFinalizing = (lookahead, unscanned) => lookahead === ">" ? unscanned[0] === "=" ? (
    // >== would only occur in an expression like Array<number>==5
    // otherwise, >= would only occur as part of a bound like number>=5
    unscanned[1] === "="
  ) : unscanned.trimStart() === "" || isKeyOf(unscanned.trimStart()[0], Scanner2.terminatingChars) : lookahead === "=" ? unscanned[0] !== "=" : lookahead === ",";
})(Scanner || (Scanner = {}));

// node_modules/arktype/out/parser/string/shift/operator/bounds.js
var parseBound = (s, start) => {
  const comparator = shiftComparator(s, start);
  if (s.root.hasKind("unit")) {
    if (typeof s.root.unit === "number") {
      s.reduceLeftBound(s.root.unit, comparator);
      s.unsetRoot();
      return;
    }
    if (s.root.unit instanceof Date) {
      const literal = `d'${s.root.description ?? s.root.unit.toISOString()}'`;
      s.unsetRoot();
      s.reduceLeftBound(literal, comparator);
      return;
    }
  }
  return parseRightBound(s, comparator);
};
var comparatorStartChars = {
  "<": 1,
  ">": 1,
  "=": 1
};
var shiftComparator = (s, start) => s.scanner.lookaheadIs("=") ? `${start}${s.scanner.shift()}` : start;
var getBoundKinds = (comparator, limit, root2, boundKind) => {
  if (root2.extends(tsKeywords.number)) {
    if (typeof limit !== "number") {
      return throwParseError(writeInvalidLimitMessage(comparator, limit, boundKind));
    }
    return comparator === "==" ? ["min", "max"] : comparator[0] === ">" ? ["min"] : ["max"];
  }
  if (root2.extends(internal.lengthBoundable)) {
    if (typeof limit !== "number") {
      return throwParseError(writeInvalidLimitMessage(comparator, limit, boundKind));
    }
    return comparator === "==" ? ["minLength", "maxLength"] : comparator[0] === ">" ? ["minLength"] : ["maxLength"];
  }
  if (root2.extends(jsObjects.Date)) {
    return comparator === "==" ? ["after", "before"] : comparator[0] === ">" ? ["after"] : ["before"];
  }
  return throwParseError(writeUnboundableMessage(root2.expression));
};
var openLeftBoundToRoot = (leftBound) => ({
  rule: isDateLiteral(leftBound.limit) ? extractDateLiteralSource(leftBound.limit) : leftBound.limit,
  exclusive: leftBound.comparator.length === 1
});
var parseRightBound = (s, comparator) => {
  const previousRoot = s.unsetRoot();
  const previousScannerIndex = s.scanner.location;
  s.parseOperand();
  const limitNode = s.unsetRoot();
  const limitToken = s.scanner.sliceChars(previousScannerIndex, s.scanner.location);
  s.root = previousRoot;
  if (!limitNode.hasKind("unit") || typeof limitNode.unit !== "number" && !(limitNode.unit instanceof Date))
    return s.error(writeInvalidLimitMessage(comparator, limitToken, "right"));
  const limit = limitNode.unit;
  const exclusive = comparator.length === 1;
  for (const kind of getBoundKinds(comparator, typeof limit === "number" ? limit : limitToken, previousRoot, "right"))
    s.constrainRoot(kind, { rule: limit, exclusive });
  if (!s.branches.leftBound)
    return;
  if (!isKeyOf(comparator, maxComparators))
    return s.error(writeUnpairableComparatorMessage(comparator));
  const lowerBoundKind = getBoundKinds(s.branches.leftBound.comparator, s.branches.leftBound.limit, previousRoot, "left");
  s.constrainRoot(lowerBoundKind[0], openLeftBoundToRoot(s.branches.leftBound));
  s.branches.leftBound = null;
};
var writeInvalidLimitMessage = (comparator, limit, boundKind) => `Comparator ${boundKind === "left" ? invertedComparators[comparator] : comparator} must be ${boundKind === "left" ? "preceded" : "followed"} by a corresponding literal (was ${limit})`;

// node_modules/arktype/out/parser/string/shift/operator/divisor.js
var parseDivisor = (s) => {
  const divisorToken = s.scanner.shiftUntilNextTerminator();
  const divisor = tryParseInteger(divisorToken, {
    errorOnFail: writeInvalidDivisorMessage(divisorToken)
  });
  if (divisor === 0)
    s.error(writeInvalidDivisorMessage(0));
  s.root = s.root.constrain("divisor", divisor);
};
var writeInvalidDivisorMessage = (divisor) => `% operator must be followed by a non-zero integer literal (was ${divisor})`;

// node_modules/arktype/out/parser/string/shift/operator/operator.js
var parseOperator = (s) => {
  const lookahead = s.scanner.shift();
  return lookahead === "" ? s.finalize("") : lookahead === "[" ? s.scanner.shift() === "]" ? s.setRoot(s.root.array()) : s.error(incompleteArrayTokenMessage) : lookahead === "|" || lookahead === "&" ? s.pushRootToBranch(lookahead) : lookahead === ")" ? s.finalizeGroup() : Scanner.lookaheadIsFinalizing(lookahead, s.scanner.unscanned) ? s.finalize(lookahead) : isKeyOf(lookahead, comparatorStartChars) ? parseBound(s, lookahead) : lookahead === "%" ? parseDivisor(s) : lookahead === " " ? parseOperator(s) : s.error(writeUnexpectedCharacterMessage(lookahead));
};
var writeUnexpectedCharacterMessage = (char, shouldBe = "") => `'${char}' is not allowed here${shouldBe && ` (should be ${shouldBe})`}`;
var incompleteArrayTokenMessage = `Missing expected ']'`;

// node_modules/arktype/out/parser/string/shift/operator/default.js
var parseDefault = (s) => {
  if (!s.defaultable)
    return throwParseError(shallowDefaultMessage);
  const baseNode = s.unsetRoot();
  s.parseOperand();
  const defaultNode = s.unsetRoot();
  if (!defaultNode.hasKind("unit"))
    return s.error(writeNonLiteralDefaultMessage(defaultNode.expression));
  return [baseNode, "=", defaultNode.unit];
};
var writeNonLiteralDefaultMessage = (defaultDef) => `Default value '${defaultDef}' must a literal value`;
var shallowDefaultMessage = `Default values must be specified on objects like { isAdmin: 'boolean = false' }`;

// node_modules/arktype/out/parser/string/string.js
var fullStringParse = (s) => {
  s.parseOperand();
  let result = parseUntilFinalizer(s).root;
  if (!result) {
    return throwInternalError(`Root was unexpectedly unset after parsing string '${s.scanner.scanned}'`);
  }
  if (s.finalizer === "=")
    result = parseDefault(s);
  s.scanner.shiftUntilNonWhitespace();
  if (s.scanner.lookahead) {
    throwParseError(writeUnexpectedCharacterMessage(s.scanner.lookahead));
  }
  return result;
};
var parseUntilFinalizer = (s) => {
  while (s.finalizer === void 0)
    next(s);
  return s;
};
var next = (s) => s.hasRoot() ? s.parseOperator() : s.parseOperand();

// node_modules/arktype/out/parser/string/reduce/dynamic.js
var DynamicState = class _DynamicState {
  constructor(scanner, ctx, defaultable) {
    __publicField(this, "scanner");
    __publicField(this, "ctx");
    __publicField(this, "defaultable");
    // set root type to `any` so that all constraints can be applied
    __publicField(this, "root");
    __publicField(this, "branches", {
      prefixes: [],
      leftBound: null,
      intersection: null,
      union: null
    });
    __publicField(this, "finalizer");
    __publicField(this, "groups", []);
    this.scanner = scanner;
    this.ctx = ctx;
    this.defaultable = defaultable;
  }
  error(message) {
    return throwParseError(message);
  }
  hasRoot() {
    return this.root !== void 0;
  }
  setRoot(root2) {
    this.root = root2;
  }
  unsetRoot() {
    const value = this.root;
    this.root = void 0;
    return value;
  }
  constrainRoot(...args) {
    this.root = this.root.constrain(args[0], args[1]);
  }
  finalize(finalizer) {
    if (this.groups.length)
      return this.error(writeUnclosedGroupMessage(")"));
    this.finalizeBranches();
    this.finalizer = finalizer;
  }
  reduceLeftBound(limit, comparator) {
    const invertedComparator = invertedComparators[comparator];
    if (!isKeyOf(invertedComparator, minComparators))
      return this.error(writeUnpairableComparatorMessage(comparator));
    if (this.branches.leftBound) {
      return this.error(writeMultipleLeftBoundsMessage(this.branches.leftBound.limit, this.branches.leftBound.comparator, limit, invertedComparator));
    }
    this.branches.leftBound = {
      comparator: invertedComparator,
      limit
    };
  }
  finalizeBranches() {
    this.assertRangeUnset();
    if (this.branches.union) {
      this.pushRootToBranch("|");
      this.root = this.branches.union;
    } else if (this.branches.intersection) {
      this.pushRootToBranch("&");
      this.root = this.branches.intersection;
    } else
      this.applyPrefixes();
  }
  finalizeGroup() {
    this.finalizeBranches();
    const topBranchState = this.groups.pop();
    if (!topBranchState)
      return this.error(writeUnmatchedGroupCloseMessage(this.scanner.unscanned));
    this.branches = topBranchState;
  }
  addPrefix(prefix) {
    this.branches.prefixes.push(prefix);
  }
  applyPrefixes() {
    while (this.branches.prefixes.length) {
      const lastPrefix = this.branches.prefixes.pop();
      this.root = lastPrefix === "keyof" ? this.root.keyof() : throwInternalError(`Unexpected prefix '${lastPrefix}'`);
    }
  }
  pushRootToBranch(token) {
    var _a5, _b3;
    this.assertRangeUnset();
    this.applyPrefixes();
    const root2 = this.root;
    this.branches.intersection = ((_a5 = this.branches.intersection) == null ? void 0 : _a5.and(root2)) ?? root2;
    if (token === "|") {
      this.branches.union = ((_b3 = this.branches.union) == null ? void 0 : _b3.or(this.branches.intersection)) ?? this.branches.intersection;
      this.branches.intersection = null;
    }
    this.root = void 0;
  }
  parseUntilFinalizer() {
    return parseUntilFinalizer(new _DynamicState(this.scanner, this.ctx, false));
  }
  parseOperator() {
    return parseOperator(this);
  }
  parseOperand() {
    return parseOperand(this);
  }
  assertRangeUnset() {
    if (this.branches.leftBound) {
      return this.error(writeOpenRangeMessage(this.branches.leftBound.limit, this.branches.leftBound.comparator));
    }
  }
  reduceGroupOpen() {
    this.groups.push(this.branches);
    this.branches = {
      prefixes: [],
      leftBound: null,
      union: null,
      intersection: null
    };
  }
  previousOperator() {
    var _a5;
    return ((_a5 = this.branches.leftBound) == null ? void 0 : _a5.comparator) ?? this.branches.prefixes.at(-1) ?? (this.branches.intersection ? "&" : this.branches.union ? "|" : void 0);
  }
  shiftedByOne() {
    this.scanner.shift();
    return this;
  }
};

// node_modules/arktype/out/generic.js
var emptyGenericParameterMessage = "An empty string is not a valid generic parameter name";
var parseGenericParams = (def, ctx) => parseName(new Scanner(def), [], ctx);
var paramsTerminators = { ...whiteSpaceTokens, ",": true, ":": true };
var parseName = (scanner, result, ctx) => {
  scanner.shiftUntilNonWhitespace();
  const name = scanner.shiftUntilNextTerminator();
  if (name === "") {
    if (scanner.lookahead === "" && result.length)
      return result;
    return throwParseError(emptyGenericParameterMessage);
  }
  scanner.shiftUntilNonWhitespace();
  return _parseOptionalConstraint(scanner, name, result, ctx);
};
var extendsToken = "extends ";
var _parseOptionalConstraint = (scanner, name, result, ctx) => {
  scanner.shiftUntilNonWhitespace();
  if (scanner.lookahead === ":")
    scanner.shift();
  else if (scanner.unscanned.startsWith(extendsToken))
    scanner.jumpForward(extendsToken.length);
  else {
    if (scanner.lookahead === ",")
      scanner.shift();
    result.push(name);
    return parseName(scanner, result, ctx);
  }
  const s = parseUntilFinalizer(new DynamicState(scanner, ctx, false));
  result.push([name, s.root]);
  return parseName(scanner, result, ctx);
};

// node_modules/arktype/out/match.js
var createMatchParser = ($2) => (() => {
}).bind($2);

// node_modules/arktype/out/parser/semantic/default.js
var writeUnassignableDefaultValueMessage = (key, message) => `Default value at ${key} ${message}`;

// node_modules/arktype/out/parser/objectLiteral.js
var parseObjectLiteral = (def, ctx) => {
  var _a5;
  let spread;
  const structure = {};
  const parsedEntries = stringAndSymbolicEntriesOf(def).flatMap((entry) => parseEntry(entry[0], entry[1], ctx));
  if (((_a5 = parsedEntries[0]) == null ? void 0 : _a5.kind) === "spread") {
    const spreadEntry = parsedEntries.shift();
    if (!spreadEntry.node.hasKind("intersection") || !spreadEntry.node.structure) {
      return throwParseError(writeInvalidSpreadTypeMessage(typeof spreadEntry.node.expression));
    }
    spread = spreadEntry.node.structure;
  }
  for (const entry of parsedEntries) {
    if (entry.kind === "spread")
      return throwParseError(nonLeadingSpreadError);
    if (entry.kind === "undeclared") {
      structure.undeclared = entry.behavior;
      continue;
    }
    structure[entry.kind] = append(structure[entry.kind], entry);
  }
  const structureNode = ctx.$.node("structure", structure);
  return ctx.$.schema({
    domain: "object",
    structure: (spread == null ? void 0 : spread.merge(structureNode)) ?? structureNode
  });
};
var writeInvalidUndeclaredBehaviorMessage = (actual) => `Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${printable(actual)})`;
var nonLeadingSpreadError = "Spread operator may only be used as the first key in an object";
var parseEntry = (key, value, ctx) => {
  const parsedKey = parseKey(key);
  if (parsedKey.kind === "+") {
    if (value !== "reject" && value !== "delete" && value !== "ignore")
      throwParseError(writeInvalidUndeclaredBehaviorMessage(value));
    return { kind: "undeclared", behavior: value };
  }
  if (parsedKey.kind === "...")
    return { kind: "spread", node: ctx.$.parse(value, ctx) };
  const parsedValue = isArray(value) && value[1] === "=" ? [ctx.$.parse(value[0], ctx), "=", value[2]] : ctx.$.parse(value, ctx, true);
  if (isArray(parsedValue)) {
    if (parsedKey.kind !== "required")
      throwParseError(invalidDefaultKeyKindMessage);
    const out = parsedValue[0].traverse(parsedValue[2]);
    if (out instanceof ArkErrors) {
      throwParseError(writeUnassignableDefaultValueMessage(printable(parsedKey.key), out.message));
    }
    return ctx.$.node("optional", {
      key: parsedKey.key,
      value: parsedValue[0],
      default: parsedValue[2]
    });
  }
  if (parsedKey.kind === "index") {
    const signature = ctx.$.parse(parsedKey.key, ctx);
    const normalized = normalizeIndex(signature, parsedValue, ctx.$);
    return normalized.index ? normalized.required ? [normalized.index, ...normalized.required] : normalized.index : normalized.required ?? [];
  }
  return ctx.$.node(parsedKey.kind, {
    key: parsedKey.key,
    value: parsedValue
  });
};
var invalidDefaultKeyKindMessage = `Only required keys may specify default values, e.g. { value: 'number = 0' }`;
var parseKey = (key) => typeof key === "symbol" ? { kind: "required", key } : key.at(-1) === "?" ? key.at(-2) === escapeToken ? { kind: "required", key: `${key.slice(0, -2)}?` } : {
  kind: "optional",
  key: key.slice(0, -1)
} : key[0] === "[" && key.at(-1) === "]" ? { kind: "index", key: key.slice(1, -1) } : key[0] === escapeToken && key[1] === "[" && key.at(-1) === "]" ? { kind: "required", key: key.slice(1) } : key === "..." ? { kind: key, key } : key === "+" ? { kind: key, key } : {
  kind: "required",
  key: key === "\\..." ? "..." : key === "\\+" ? "+" : key
};
var writeInvalidSpreadTypeMessage = (def) => `Spread operand must resolve to an object literal type (was ${def})`;

// node_modules/arktype/out/parser/tuple.js
var parseTuple = (def, ctx) => maybeParseTupleExpression(def, ctx) ?? parseTupleLiteral(def, ctx);
var parseTupleLiteral = (def, ctx) => {
  let sequences = [{}];
  let i = 0;
  while (i < def.length) {
    let spread = false;
    let optional = false;
    if (def[i] === "..." && i < def.length - 1) {
      spread = true;
      i++;
    }
    const element = ctx.$.parse(def[i], ctx);
    i++;
    if (def[i] === "?") {
      if (spread)
        return throwParseError(spreadOptionalMessage);
      optional = true;
      i++;
    }
    if (spread) {
      if (!element.extends(jsObjects.Array))
        return throwParseError(writeNonArraySpreadMessage(element.expression));
      sequences = sequences.flatMap((base) => (
        // since appendElement mutates base, we have to shallow-ish clone it for each branch
        element.branches.map((branch) => appendSpreadBranch(makeRootAndArrayPropertiesMutable(base), branch))
      ));
    } else {
      sequences = sequences.map((base) => appendElement(base, optional ? "optional" : "required", element));
    }
  }
  return ctx.$.internal.schema(sequences.map((sequence) => ({
    proto: Array,
    sequence
  })));
};
var appendElement = (base, kind, element) => {
  switch (kind) {
    case "required":
      if (base.optionals)
        return throwParseError(requiredPostOptionalMessage);
      if (base.variadic) {
        base.postfix = append(base.postfix, element);
      } else {
        base.prefix = append(base.prefix, element);
      }
      return base;
    case "optional":
      if (base.variadic)
        return throwParseError(optionalPostVariadicMessage);
      base.optionals = append(base.optionals, element);
      return base;
    case "variadic":
      if (base.postfix)
        throwParseError(multipleVariadicMesage);
      if (base.variadic) {
        if (!base.variadic.equals(element)) {
          throwParseError(multipleVariadicMesage);
        }
      } else {
        base.variadic = element.internal;
      }
      return base;
  }
};
var appendSpreadBranch = (base, branch) => {
  const spread = branch.firstReferenceOfKind("sequence");
  if (!spread) {
    return appendElement(base, "variadic", tsKeywords.unknown.internal);
  }
  spread.prefix.forEach((node2) => appendElement(base, "required", node2));
  spread.optionals.forEach((node2) => appendElement(base, "optional", node2));
  spread.variadic && appendElement(base, "variadic", spread.variadic);
  spread.postfix.forEach((node2) => appendElement(base, "required", node2));
  return base;
};
var maybeParseTupleExpression = (def, ctx) => {
  const tupleExpressionResult = isIndexZeroExpression(def) ? prefixParsers[def[0]](def, ctx) : isIndexOneExpression(def) ? indexOneParsers[def[1]](def, ctx) : void 0;
  return tupleExpressionResult;
};
var writeNonArraySpreadMessage = (operand) => `Spread element must be an array (was ${operand})`;
var multipleVariadicMesage = "A tuple may have at most one variadic element";
var requiredPostOptionalMessage = "A required element may not follow an optional element";
var optionalPostVariadicMessage = "An optional element may not follow a variadic element";
var spreadOptionalMessage = "A spread element cannot be optional";
var parseKeyOfTuple = (def, ctx) => ctx.$.parse(def[1], ctx).keyof();
var parseBranchTuple = (def, ctx) => {
  if (def[2] === void 0)
    return throwParseError(writeMissingRightOperandMessage(def[1], ""));
  const l = ctx.$.parse(def[0], ctx);
  const r = ctx.$.parse(def[2], ctx);
  return def[1] === "&" ? l.and(r) : l.or(r);
};
var parseArrayTuple = (def, ctx) => ctx.$.parse(def[0], ctx).array();
var isIndexOneExpression = (def) => indexOneParsers[def[1]] !== void 0;
var parseMorphTuple = (def, ctx) => {
  if (typeof def[2] !== "function") {
    return throwParseError(writeMalformedFunctionalExpressionMessage("=>", def[2]));
  }
  return ctx.$.parse(def[0], ctx).pipe(def[2]);
};
var writeMalformedFunctionalExpressionMessage = (operator, value) => `${operator === ":" ? "Narrow" : "Morph"} expression requires a function following '${operator}' (was ${typeof value})`;
var parseNarrowTuple = (def, ctx) => {
  if (typeof def[2] !== "function") {
    return throwParseError(writeMalformedFunctionalExpressionMessage(":", def[2]));
  }
  return ctx.$.parse(def[0], ctx).constrain("predicate", def[2]);
};
var parseAttributeTuple = (def, ctx) => ctx.$.parse(def[0], ctx).configureShallowDescendants(def[2]);
var indexOneParsers = {
  "|": parseBranchTuple,
  "&": parseBranchTuple,
  "[]": parseArrayTuple,
  ":": parseNarrowTuple,
  "=>": parseMorphTuple,
  "@": parseAttributeTuple
};
var prefixParsers = {
  keyof: parseKeyOfTuple,
  instanceof: (def, ctx) => {
    if (typeof def[1] !== "function") {
      return throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(def[1])));
    }
    const branches = def.slice(1).map((ctor) => typeof ctor === "function" ? ctx.$.node("proto", { proto: ctor }) : throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(ctor))));
    return branches.length === 1 ? branches[0] : ctx.$.node("union", { branches });
  },
  "===": (def, ctx) => ctx.$.units(def.slice(1))
};
var isIndexZeroExpression = (def) => prefixParsers[def[0]] !== void 0;
var writeInvalidConstructorMessage = (actual) => `Expected a constructor following 'instanceof' operator (was ${actual})`;

// node_modules/arktype/out/parser/definition.js
var parseObject = (def, ctx) => {
  const objectKind = objectKindOf(def);
  switch (objectKind) {
    case void 0:
      if (hasArkKind(def, "root"))
        return def;
      return parseObjectLiteral(def, ctx);
    case "Array":
      return parseTuple(def, ctx);
    case "RegExp":
      return ctx.$.node("intersection", {
        domain: "string",
        pattern: def
      }, { prereduced: true });
    case "Function": {
      const resolvedDef = isThunk(def) ? def() : def;
      if (hasArkKind(resolvedDef, "root"))
        return resolvedDef;
      return throwParseError(writeBadDefinitionTypeMessage("Function"));
    }
    default:
      return throwParseError(writeBadDefinitionTypeMessage(objectKind ?? printable(def)));
  }
};
var writeBadDefinitionTypeMessage = (actual) => `Type definitions must be strings or objects (was ${actual})`;

// node_modules/arktype/out/type.js
var RawTypeParser = class extends Callable {
  constructor($2) {
    super((...args) => {
      if (args.length === 1) {
        return $2.parseRoot(args[0]);
      }
      if (args.length === 2 && typeof args[0] === "string" && args[0][0] === "<" && args[0].at(-1) === ">") {
        const params = parseGenericParams(args[0].slice(1, -1), {
          $: $2,
          args: {}
        });
        const def = args[1];
        return $2.generic(params, def);
      }
      return $2.parseRoot(args);
    }, {
      bind: $2,
      attach: {
        errors: ArkErrors,
        raw: $2.parseRoot
      }
    });
  }
};
var Type = BaseRoot;

// node_modules/arktype/out/scope.js
var __runInitializers9 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate9 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var scope = (def, config = {}) => new RawScope(def, config);
var RawScope = (() => {
  var _a5;
  let _classSuper = RawRootScope;
  let _instanceExtraInitializers = [];
  let _parseRoot_decorators;
  return _a5 = class extends _classSuper {
    constructor(def, config) {
      super(def, config);
      __publicField(this, "parseCache", (__runInitializers9(this, _instanceExtraInitializers), {}));
      __publicField(this, "type", new RawTypeParser(this));
      __publicField(this, "match", createMatchParser(this));
      __publicField(this, "declare", (() => ({
        type: this.type
      })).bind(this));
      __publicField(this, "define", ((def) => def).bind(this));
    }
    preparseAlias(k, v) {
      const firstParamIndex = k.indexOf("<");
      if (firstParamIndex === -1)
        return [k, v];
      if (k.at(-1) !== ">") {
        throwParseError(`'>' must be the last character of a generic declaration in a scope`);
      }
      const name = k.slice(0, firstParamIndex);
      const paramString = k.slice(firstParamIndex + 1, -1);
      return [
        name,
        // use a thunk definition for the generic so that we can parse
        // constraints within the current scope
        () => {
          const params = parseGenericParams(paramString, {
            $: this,
            args: {}
          });
          const generic2 = parseGeneric(params, v, this);
          return generic2;
        }
      ];
    }
    preparseRoot(def) {
      if (isThunk(def) && !hasArkKind(def, "generic"))
        return def();
      return def;
    }
    parseRoot(def, opts = {}) {
      const node2 = this.parse(def, Object.assign(this.finalizeRootArgs(opts, () => node2), { $: this })).bindScope(this);
      return node2;
    }
    parse(def, ctx, defaultable = false) {
      var _a6;
      if (typeof def === "string") {
        if (ctx.args && Object.keys(ctx.args).some((k) => def.includes(k))) {
          return this.parseString(def, ctx, defaultable);
        }
        const contextKey = `${def}${defaultable}`;
        return (_a6 = this.parseCache)[contextKey] ?? (_a6[contextKey] = this.parseString(def, ctx, defaultable));
      }
      return hasDomain(def, "object") ? parseObject(def, ctx) : throwParseError(writeBadDefinitionTypeMessage(domainOf(def)));
    }
    parseString(def, ctx, defaultable) {
      var _a6;
      const aliasResolution = this.maybeResolveRoot(def);
      if (aliasResolution)
        return aliasResolution;
      const aliasArrayResolution = def.endsWith("[]") ? (_a6 = this.maybeResolveRoot(def.slice(0, -2))) == null ? void 0 : _a6.array() : void 0;
      if (aliasArrayResolution)
        return aliasArrayResolution;
      const s = new DynamicState(new Scanner(def), ctx, defaultable);
      const node2 = fullStringParse(s);
      if (s.finalizer === ">")
        throwParseError(writeUnexpectedCharacterMessage(">"));
      return node2;
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _parseRoot_decorators = [bound];
    __esDecorate9(_a5, null, _parseRoot_decorators, { kind: "method", name: "parseRoot", static: false, private: false, access: { has: (obj) => "parseRoot" in obj, get: (obj) => obj.parseRoot }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_a5, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a5;
})();

// node_modules/arktype/out/ark.js
var ambient = scope(keywordNodes);
var ark = ambient.export();
var type = ambient.type;
var match = ambient.match;
var define = ambient.define;
var declare = ambient.declare;

// node_modules/arktype/out/module.js
var Module = RootModule;
export {
  ArkError,
  ArkErrors,
  Module,
  Type,
  ambient,
  ark,
  declare,
  define,
  match,
  scope,
  type
};
//# sourceMappingURL=out-CGWNOBIR.js.map
