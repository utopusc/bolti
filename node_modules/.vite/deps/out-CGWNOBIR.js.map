{
  "version": 3,
  "sources": ["../../@ark/util/out/arrays.js", "../../@ark/util/out/errors.js", "../../@ark/util/out/flatMorph.js", "../../@ark/util/out/records.js", "../../@ark/util/out/functions.js", "../../@ark/util/out/domain.js", "../../@ark/util/out/objectKinds.js", "../../@ark/util/out/primitive.js", "../../@ark/util/out/registry.js", "../../@ark/util/out/compilation.js", "../../@ark/util/out/generics.js", "../../@ark/util/out/hkt.js", "../../@ark/util/out/numericLiterals.js", "../../@ark/util/out/serialize.js", "../../@ark/util/out/strings.js", "../../@ark/util/out/traits.js", "../../@ark/schema/out/shared/utils.js", "../../@ark/schema/out/shared/implement.js", "../../@ark/schema/out/config.js", "../../@ark/schema/out/shared/errors.js", "../../@ark/schema/out/shared/traversal.js", "../../@ark/schema/out/node.js", "../../@ark/schema/out/shared/disjoint.js", "../../@ark/schema/out/shared/intersections.js", "../../@ark/schema/out/constraint.js", "../../@ark/schema/out/generic.js", "../../@ark/schema/out/predicate.js", "../../@ark/schema/out/refinements/divisor.js", "../../@ark/schema/out/refinements/range.js", "../../@ark/schema/out/refinements/after.js", "../../@ark/schema/out/refinements/before.js", "../../@ark/schema/out/refinements/exactLength.js", "../../@ark/schema/out/refinements/max.js", "../../@ark/schema/out/refinements/maxLength.js", "../../@ark/schema/out/refinements/min.js", "../../@ark/schema/out/refinements/minLength.js", "../../@ark/schema/out/refinements/kinds.js", "../../@ark/schema/out/refinements/pattern.js", "../../@ark/schema/out/roots/root.js", "../../@ark/schema/out/roots/utils.js", "../../@ark/schema/out/roots/alias.js", "../../@ark/schema/out/roots/basis.js", "../../@ark/schema/out/roots/domain.js", "../../@ark/schema/out/shared/declare.js", "../../@ark/schema/out/roots/intersection.js", "../../@ark/schema/out/roots/morph.js", "../../@ark/schema/out/roots/proto.js", "../../@ark/schema/out/roots/union.js", "../../@ark/schema/out/roots/unit.js", "../../@ark/schema/out/structure/indexed.js", "../../@ark/schema/out/structure/prop.js", "../../@ark/schema/out/structure/optional.js", "../../@ark/schema/out/structure/required.js", "../../@ark/schema/out/structure/sequence.js", "../../@ark/schema/out/structure/shared.js", "../../@ark/schema/out/structure/structure.js", "../../@ark/schema/out/kinds.js", "../../@ark/schema/out/module.js", "../../@ark/schema/out/parse.js", "../../@ark/schema/out/shared/compile.js", "../../@ark/schema/out/scope.js", "../../@ark/schema/out/keywords/tsKeywords.js", "../../@ark/schema/out/keywords/internal.js", "../../@ark/schema/out/keywords/jsObjects.js", "../../@ark/schema/out/keywords/format.js", "../../@ark/schema/out/keywords/utils/date.js", "../../@ark/schema/out/keywords/utils/regex.js", "../../@ark/schema/out/keywords/parsing.js", "../../@ark/schema/out/keywords/tsGenerics.js", "../../@ark/schema/out/keywords/utils/creditCard.js", "../../@ark/schema/out/keywords/utils/ip.js", "../../@ark/schema/out/keywords/validation.js", "../../@ark/schema/out/keywords/keywords.js", "../../arktype/out/parser/string/shift/operand/date.js", "../../arktype/out/parser/string/shift/operand/enclosed.js", "../../arktype/out/parser/semantic/validate.js", "../../arktype/out/parser/string/reduce/shared.js", "../../arktype/out/parser/string/shift/operand/genericArgs.js", "../../arktype/out/parser/string/shift/operand/unenclosed.js", "../../arktype/out/parser/string/shift/operand/operand.js", "../../arktype/out/parser/string/shift/scanner.js", "../../arktype/out/parser/string/shift/operator/bounds.js", "../../arktype/out/parser/string/shift/operator/divisor.js", "../../arktype/out/parser/string/shift/operator/operator.js", "../../arktype/out/parser/string/shift/operator/default.js", "../../arktype/out/parser/string/string.js", "../../arktype/out/parser/string/reduce/dynamic.js", "../../arktype/out/generic.js", "../../arktype/out/match.js", "../../arktype/out/parser/semantic/default.js", "../../arktype/out/parser/objectLiteral.js", "../../arktype/out/parser/tuple.js", "../../arktype/out/parser/definition.js", "../../arktype/out/type.js", "../../arktype/out/scope.js", "../../arktype/out/ark.js", "../../arktype/out/module.js"],
  "sourcesContent": ["export const join = (segments, delimiter) => segments.join(delimiter);\nexport const getPath = (root, path) => {\n    let result = root;\n    for (const segment of path) {\n        if (typeof result !== \"object\" || result === null)\n            return undefined;\n        result = result[segment];\n    }\n    return result;\n};\nexport const intersectUniqueLists = (l, r) => {\n    const intersection = [...l];\n    for (const item of r)\n        if (!l.includes(item))\n            intersection.push(item);\n    return intersection;\n};\nexport const arrayFrom = (data) => (Array.isArray(data) ? data : [data]);\nexport const spliterate = (list, by) => {\n    const result = [[], []];\n    for (const item of list) {\n        if (by(item))\n            result[0].push(item);\n        else\n            result[1].push(item);\n    }\n    return result;\n};\nexport const ReadonlyArray = Array;\nexport const includes = (array, element) => array.includes(element);\nexport const range = (length, offset = 0) => [...new Array(length)].map((_, i) => i + offset);\n/**\n * Adds a value or array to an array, returning the concatenated result\n *\n * @param to The array to which `value` is to be added. If `to` is `undefined`, a new array\n * is created as `[value]` if value was not undefined, otherwise `[]`.\n * @param value The value to add to the array.\n * @param opts\n * \t\tprepend: If true, adds the element to the beginning of the array instead of the end\n */\nexport const append = (to, value, opts) => {\n    if (to === undefined) {\n        return (value === undefined ? []\n            : Array.isArray(value) ? value\n                : [value]);\n    }\n    if (opts?.prepend)\n        Array.isArray(value) ? to.unshift(...value) : to.unshift(value);\n    else\n        Array.isArray(value) ? to.push(...value) : to.push(value);\n    return to;\n};\n/**\n * Concatenates an element or list with a readonly list\n *\n * @param {to} to - The base list.\n * @param {elementOrList} elementOrList - The element or list to concatenate.\n */\nexport const conflatenate = (to, elementOrList) => {\n    if (elementOrList === undefined || elementOrList === null)\n        return to ?? [];\n    if (to === undefined || to === null)\n        return arrayFrom(elementOrList);\n    return to.concat(elementOrList);\n};\n/**\n * Concatenates a variadic list of elements or lists with a readonly list\n *\n * @param {to} to - The base list.\n * @param {elementsOrLists} elementsOrLists - The elements or lists to concatenate.\n */\nexport const conflatenateAll = (...elementsOrLists) => elementsOrLists.reduce(conflatenate, []);\n/**\n * Appends a value or concatenates an array to an array if it is not already included, returning the array\n *\n * @param to The array to which `value` is to be appended. If `to` is `undefined`, a new array\n * is created including only `value`.\n * @param value An array or value to append to the array. If `to` includes `value`, nothing is appended.\n */\nexport const appendUnique = (to, value, opts) => {\n    if (to === undefined)\n        return Array.isArray(value) ? value : [value];\n    const isEqual = opts?.isEqual ?? ((l, r) => l === r);\n    arrayFrom(value).forEach(v => {\n        if (!to.some(existing => isEqual(existing, v)))\n            to.push(v);\n    });\n    return to;\n};\nexport const groupBy = (array, discriminant) => array.reduce((result, item) => {\n    const key = item[discriminant];\n    result[key] = append(result[key], item);\n    return result;\n}, {});\nexport const arrayEquals = (l, r, opts) => l.length === r.length &&\n    l.every(opts?.isEqual ?\n        (lItem, i) => opts.isEqual(lItem, r[i])\n        : (lItem, i) => lItem === r[i]);\n", "export class InternalArktypeError extends Error {\n}\nexport const throwInternalError = message => throwError(message, InternalArktypeError);\nexport const throwError = (message, ctor = Error) => {\n    throw new ctor(message);\n};\nexport class ParseError extends Error {\n    name = \"ParseError\";\n}\nexport const throwParseError = message => throwError(message, ParseError);\n", "// eslint-disable-next-line prefer-arrow-functions/prefer-arrow-functions\nexport function flatMorph(o, flatMapEntry) {\n    const inputIsArray = Array.isArray(o);\n    const entries = Object.entries(o).flatMap((entry, i) => {\n        const result = inputIsArray ? flatMapEntry(i, entry[1]) : flatMapEntry(...entry, i);\n        const entrySet = Array.isArray(result[0]) || result.length === 0 ?\n            // if we have an empty array (for filtering) or an array with\n            // another array as its first element, treat it as a list of\n            result\n            // otherwise, it should be a single entry, so nest it in a tuple\n            // so it doesn't get spread when the result is flattened\n            : [result];\n        return entrySet;\n    });\n    const objectResult = Object.fromEntries(entries);\n    return typeof entries[0]?.[0] === \"number\" ?\n        Object.values(objectResult)\n        : objectResult;\n}\n", "import { flatMorph } from \"./flatMorph.js\";\nexport const entriesOf = (o) => Object.entries(o);\nexport const fromEntries = (entries) => Object.fromEntries(entries);\nexport const keysOf = (o) => Object.keys(o);\nexport const isKeyOf = (k, o) => k in o;\nexport const hasKey = (o, k) => k in o;\n// must be defined this way to avoid https://github.com/microsoft/TypeScript/issues/55049\nexport const hasDefinedKey = (o, k) => o[k] !== undefined;\nexport const InnerDynamicBase = class {\n    constructor(properties) {\n        Object.assign(this, properties);\n    }\n};\n/** @ts-expect-error (needed to extend `t`, but safe given ShallowClone's implementation) **/\nexport class DynamicBase extends InnerDynamicBase {\n}\nexport const NoopBase = class {\n};\n/** @ts-expect-error (see DynamicBase) **/\nexport class CastableBase extends NoopBase {\n}\nexport const splitByKeys = (o, leftKeys) => {\n    const l = {};\n    const r = {};\n    let k;\n    for (k in o) {\n        if (k in leftKeys)\n            l[k] = o[k];\n        else\n            r[k] = o[k];\n    }\n    return [l, r];\n};\nexport const pick = (o, keys) => splitByKeys(o, keys)[0];\nexport const omit = (o, keys) => splitByKeys(o, keys)[1];\nexport const isEmptyObject = (o) => Object.keys(o).length === 0;\nexport const stringAndSymbolicEntriesOf = (o) => [\n    ...Object.entries(o),\n    ...Object.getOwnPropertySymbols(o).map(k => [k, o[k]])\n];\n/** Like Object.assign, but it will preserve getters instead of evaluating them. */\nexport const defineProperties = (base, merged) => \n// declared like this to avoid https://github.com/microsoft/TypeScript/issues/55049\nObject.defineProperties(base, Object.getOwnPropertyDescriptors(merged));\nexport const invert = (t) => flatMorph(t, (k, v) => [v, k]);\nexport const unset = Symbol(\"represents an uninitialized value\");\n", "import { throwInternalError } from \"./errors.js\";\nimport { NoopBase, unset } from \"./records.js\";\nexport const bound = (target, ctx) => {\n    ctx.addInitializer(function () {\n        this[ctx.name] = this[ctx.name].bind(this);\n    });\n};\nexport const cached = (target, context) => function () {\n    const value = target.call(this);\n    Object.defineProperty(this, context.name, context.kind === \"getter\" ?\n        { value }\n        : {\n            value: () => value,\n            enumerable: false\n        });\n    return value;\n};\nexport const cachedThunk = (thunk) => {\n    let result = unset;\n    return () => (result === unset ? (result = thunk()) : result);\n};\nexport const isThunk = (value) => typeof value === \"function\" && value.length === 0;\nexport const tryCatch = (fn, onError) => {\n    try {\n        return fn();\n    }\n    catch (e) {\n        return onError?.(e);\n    }\n};\nexport const DynamicFunction = class extends Function {\n    constructor(...args) {\n        const params = args.slice(0, -1);\n        const body = args.at(-1);\n        try {\n            super(...params, body);\n        }\n        catch (e) {\n            return throwInternalError(`Encountered an unexpected error while compiling your definition:\n                Message: ${e} \n                Source: (${args.slice(0, -1)}) => {\n                    ${args.at(-1)}\n                }`);\n        }\n    }\n};\n/** @ts-expect-error required to cast function type */\nexport class Callable extends NoopBase {\n    constructor(f, opts) {\n        super();\n        return Object.assign(Object.setPrototypeOf(f.bind(opts?.bind ?? this), this.constructor.prototype), opts?.attach);\n    }\n}\n/**\n * Checks if the environment has Content Security Policy (CSP) enabled,\n * preventing JIT-optimized code from being compiled via new Function().\n *\n * @returns `true` if a function created using new Function() can be\n * successfully invoked in the environment, `false` otherwise.\n *\n * The result is cached for subsequent invocations.\n */\nexport const envHasCsp = cachedThunk(() => {\n    try {\n        return new Function(\"return false\")();\n    }\n    catch (e) {\n        return true;\n    }\n});\n", "export const hasDomain = (data, kind) => domainOf(data) === kind;\nexport const domainOf = (data) => {\n    const builtinType = typeof data;\n    return (builtinType === \"object\" ?\n        data === null ?\n            \"null\"\n            : \"object\"\n        : builtinType === \"function\" ? \"object\"\n            : builtinType);\n};\nconst enumerableDomainDescriptions = {\n    boolean: \"boolean\",\n    null: \"null\",\n    undefined: \"undefined\"\n};\nconst nonEnumerableDomainDescriptions = {\n    bigint: \"a bigint\",\n    number: \"a number\",\n    object: \"an object\",\n    string: \"a string\",\n    symbol: \"a symbol\"\n};\n/** Each domain's completion for the phrase \"must be _____\" */\nexport const domainDescriptions = {\n    ...nonEnumerableDomainDescriptions,\n    ...enumerableDomainDescriptions\n};\n", "import { domainOf } from \"./domain.js\";\nimport { isKeyOf } from \"./records.js\";\n// Built-in object constructors based on a subset of:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\nexport const builtinConstructors = {\n    Array,\n    Date,\n    Error,\n    Function,\n    Map,\n    RegExp,\n    Set,\n    String,\n    Number,\n    Boolean,\n    WeakMap,\n    WeakSet,\n    Promise\n};\nexport const objectKindOf = (data) => {\n    let prototype = Object.getPrototypeOf(data);\n    while (prototype?.constructor &&\n        (!isKeyOf(prototype.constructor.name, builtinConstructors) ||\n            !(data instanceof builtinConstructors[prototype.constructor.name])))\n        prototype = Object.getPrototypeOf(prototype);\n    const name = prototype?.constructor?.name;\n    if (name === undefined || name === \"Object\")\n        return undefined;\n    return name;\n};\nexport const objectKindOrDomainOf = (data) => (typeof data === \"object\" && data !== null ?\n    objectKindOf(data) ?? \"object\"\n    : domainOf(data));\nexport const hasObjectKind = (data, kind) => objectKindOf(data) === kind;\nexport const isArray = (data) => Array.isArray(data);\n/** Each defaultObjectKind's completion for the phrase \"must be _____\" */\nexport const objectKindDescriptions = {\n    Array: \"an array\",\n    Function: \"a function\",\n    Date: \"a Date\",\n    RegExp: \"a RegExp\",\n    Error: \"an Error\",\n    Map: \"a Map\",\n    Set: \"a Set\",\n    String: \"a String object\",\n    Number: \"a Number object\",\n    Boolean: \"a Boolean object\",\n    Promise: \"a Promise\",\n    WeakMap: \"a WeakMap\",\n    WeakSet: \"a WeakSet\"\n};\n// this will only return an object kind if it's the root constructor\n// example TypeError would return undefined not 'Error'\nexport const getExactBuiltinConstructorName = (ctor) => {\n    const constructorName = Object(ctor).name ?? null;\n    return (constructorName &&\n        isKeyOf(constructorName, builtinConstructors) &&\n        builtinConstructors[constructorName] === ctor) ?\n        constructorName\n        : null;\n};\n/**\n * Returns an array of constructors for all ancestors (i.e., prototypes) of a given object.\n *\n * @param {object} o - The object to find the ancestors of.\n * @returns {Function[]} An array of constructors for all ancestors of the object.\n */\nexport const ancestorsOf = (o) => {\n    let proto = Object.getPrototypeOf(o);\n    const result = [];\n    while (proto !== null) {\n        result.push(proto.constructor);\n        proto = Object.getPrototypeOf(proto);\n    }\n    return result;\n};\n/** Mimics output of TS's keyof operator at runtime */\nexport const prototypeKeysOf = (value) => {\n    const result = [];\n    let curr = value;\n    while (curr !== Object.prototype && curr !== null && curr !== undefined) {\n        for (const k of Object.getOwnPropertyNames(curr))\n            if (k !== \"constructor\" && !result.includes(k))\n                result.push(k);\n        for (const symbol of Object.getOwnPropertySymbols(curr))\n            if (!result.includes(symbol))\n                result.push(symbol);\n        curr = Object.getPrototypeOf(curr);\n    }\n    return result;\n};\nconst baseKeysByDomain = {\n    bigint: prototypeKeysOf(0n),\n    boolean: prototypeKeysOf(false),\n    null: [],\n    number: prototypeKeysOf(0),\n    // TS doesn't include the Object prototype in keyof, so keyof object is never\n    object: [],\n    string: prototypeKeysOf(\"\"),\n    symbol: prototypeKeysOf(Symbol()),\n    undefined: []\n};\nexport const getBaseDomainKeys = (domain) => [...baseKeysByDomain[domain]];\nexport const constructorExtends = (ctor, base) => {\n    let current = ctor.prototype;\n    while (current !== null) {\n        if (current === base.prototype)\n            return true;\n        current = Object.getPrototypeOf(current);\n    }\n    return false;\n};\n", "export const serializePrimitive = (value) => (typeof value === \"string\" ? JSON.stringify(value)\n    : typeof value === \"bigint\" ? `${value}n`\n        : `${value}`);\n", "import { domainOf, hasDomain } from \"./domain.js\";\nimport { throwError, throwInternalError } from \"./errors.js\";\nimport { objectKindOf } from \"./objectKinds.js\";\nimport { serializePrimitive } from \"./primitive.js\";\nif (\"$ark\" in globalThis) {\n    throwError(`Tried to initialize an $ark registry but one already existed.\nThis probably means you are either depending on multiple versions of an arktype package,\nor importing the same package from both ESM and CJS.\nReview package.json versions across your repo to ensure consistency.`);\n}\nexport const registry = {};\nglobalThis.$ark = registry;\nconst namesByResolution = new WeakMap();\nconst nameCounts = {};\nexport const register = (value) => {\n    const existingName = namesByResolution.get(value);\n    if (existingName)\n        return existingName;\n    let name = baseNameFor(value);\n    if (nameCounts[name])\n        name = `${name}${nameCounts[name]++}`;\n    else\n        nameCounts[name] = 1;\n    registry[name] = value;\n    namesByResolution.set(value, name);\n    return name;\n};\nexport const reference = (name) => `$ark.${name}`;\nexport const registeredReference = (value) => reference(register(value));\nexport const isDotAccessible = (keyName) => /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(keyName);\nexport const compileSerializedValue = (value) => hasDomain(value, \"object\") || typeof value === \"symbol\" ?\n    registeredReference(value)\n    : serializePrimitive(value);\nconst baseNameFor = (value) => {\n    switch (typeof value) {\n        case \"object\": {\n            if (value === null)\n                break;\n            const prefix = objectKindOf(value) ?? \"object\";\n            // convert to camelCase\n            return prefix[0].toLowerCase() + prefix.slice(1);\n        }\n        case \"function\":\n            return isDotAccessible(value.name) ? value.name : \"fn\";\n        case \"symbol\":\n            return value.description && isDotAccessible(value.description) ?\n                value.description\n                : \"symbol\";\n    }\n    return throwInternalError(`Unexpected attempt to register serializable value of type ${domainOf(value)}`);\n};\n", "import { DynamicFunction } from \"./functions.js\";\nimport { CastableBase } from \"./records.js\";\nimport { isDotAccessible, registeredReference } from \"./registry.js\";\nexport class CompiledFunction extends CastableBase {\n    argNames;\n    body = \"\";\n    constructor(...args) {\n        super();\n        this.argNames = args;\n        for (const arg of args) {\n            if (arg in this) {\n                throw new Error(`Arg name '${arg}' would overwrite an existing property on FunctionBody`);\n            }\n            ;\n            this[arg] = arg;\n        }\n    }\n    indentation = 0;\n    indent() {\n        this.indentation += 4;\n        return this;\n    }\n    dedent() {\n        this.indentation -= 4;\n        return this;\n    }\n    prop(key, optional = false) {\n        return compileLiteralPropAccess(key, optional);\n    }\n    index(key, optional = false) {\n        return indexPropAccess(`${key}`, optional);\n    }\n    line(statement) {\n        ;\n        this.body += `${\" \".repeat(this.indentation)}${statement}\\n`;\n        return this;\n    }\n    const(identifier, expression) {\n        this.line(`const ${identifier} = ${expression}`);\n        return this;\n    }\n    let(identifier, expression) {\n        return this.line(`let ${identifier} = ${expression}`);\n    }\n    set(identifier, expression) {\n        return this.line(`${identifier} = ${expression}`);\n    }\n    if(condition, then) {\n        return this.block(`if (${condition})`, then);\n    }\n    elseIf(condition, then) {\n        return this.block(`else if (${condition})`, then);\n    }\n    else(then) {\n        return this.block(\"else\", then);\n    }\n    /** Current index is \"i\" */\n    for(until, body, initialValue = 0) {\n        return this.block(`for (let i = ${initialValue}; ${until}; i++)`, body);\n    }\n    /** Current key is \"k\" */\n    forIn(object, body) {\n        return this.block(`for (const k in ${object})`, body);\n    }\n    block(prefix, contents, suffix = \"\") {\n        this.line(`${prefix} {`);\n        this.indent();\n        contents(this);\n        this.dedent();\n        return this.line(`}${suffix}`);\n    }\n    return(expression = \"\") {\n        return this.line(`return ${expression}`);\n    }\n    compile() {\n        return new DynamicFunction(...this.argNames, this.body);\n    }\n}\nexport const compileLiteralPropAccess = (key, optional = false) => {\n    if (typeof key === \"string\" && isDotAccessible(key))\n        return `${optional ? \"?\" : \"\"}.${key}`;\n    return indexPropAccess(serializeLiteralKey(key), optional);\n};\nexport const serializeLiteralKey = (key) => typeof key === \"symbol\" ? registeredReference(key) : JSON.stringify(key);\nexport const indexPropAccess = (key, optional = false) => `${optional ? \"?.\" : \"\"}[${key}]`;\n", "export const id = Symbol(\"id\");\nexport const narrow = (t) => t;\n", "/** A small set of HKT utility types based on https://github.com/poteat/hkt-toolbelt */\nexport var Hkt;\n(function (Hkt) {\n    class Kind {\n    }\n    Hkt.Kind = Kind;\n    class Instantiable {\n    }\n    Hkt.Instantiable = Instantiable;\n    Hkt.reify = (def) => def.hkt;\n    class UnaryKind {\n    }\n    Hkt.UnaryKind = UnaryKind;\n    Hkt.pipe = (...kinds) => In => kinds.reduce((out, kind) => kind.hkt(out), In);\n})(Hkt || (Hkt = {}));\n", "import { throwParseError } from \"./errors.js\";\n/**\n * The goal of the number literal and bigint literal regular expressions is to:\n *\n *   1. Ensure definitions form a bijection with the values they represent.\n *   2. Attempt to mirror TypeScript's own format for stringification of numeric\n *      values such that the regex should match a given definition if any only if\n *      a precise literal type will be inferred (in TS4.8+).\n */\n/**\n *  Matches a well-formatted numeric expression according to the following rules:\n *    1. Must include an integer portion (i.e. '.321' must be written as '0.321')\n *    2. The first digit of the value must not be 0, unless the entire integer portion is 0\n *    3. If the value includes a decimal, its last digit may not be 0\n *    4. The value may not be \"-0\"\n */\nexport const wellFormedNumberMatcher = /^(?!^-0$)-?(?:0|[1-9]\\d*)(?:\\.\\d*[1-9])?$/;\nexport const isWellFormedNumber = wellFormedNumberMatcher.test.bind(wellFormedNumberMatcher);\nexport const numberLikeMatcher = /^-?\\d*\\.?\\d*$/;\nconst isNumberLike = (s) => s.length !== 0 && numberLikeMatcher.test(s);\n/**\n *  Matches a well-formatted integer according to the following rules:\n *    1. must begin with an integer, the first digit of which cannot be 0 unless the entire value is 0\n *    2. The value may not be \"-0\"\n */\nexport const wellFormedIntegerMatcher = /^(?:0|(?:-?[1-9]\\d*))$/;\nexport const isWellFormedInteger = wellFormedIntegerMatcher.test.bind(wellFormedIntegerMatcher);\nexport const integerLikeMatcher = /^-?\\d+$/;\nconst isIntegerLike = integerLikeMatcher.test.bind(integerLikeMatcher);\nconst numericLiteralDescriptions = {\n    number: \"a number\",\n    bigint: \"a bigint\",\n    integer: \"an integer\"\n};\nexport const writeMalformedNumericLiteralMessage = (def, kind) => `'${def}' was parsed as ${numericLiteralDescriptions[kind]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`;\nconst isWellFormed = (def, kind) => kind === \"number\" ? isWellFormedNumber(def) : isWellFormedInteger(def);\nconst parseKind = (def, kind) => kind === \"number\" ? Number(def) : Number.parseInt(def);\nconst isKindLike = (def, kind) => kind === \"number\" ? isNumberLike(def) : isIntegerLike(def);\nexport const tryParseNumber = (token, options) => parseNumeric(token, \"number\", options);\nexport const tryParseWellFormedNumber = (token, options) => parseNumeric(token, \"number\", { ...options, strict: true });\nexport const tryParseInteger = (token, options) => parseNumeric(token, \"integer\", options);\nconst parseNumeric = (token, kind, options) => {\n    const value = parseKind(token, kind);\n    if (!Number.isNaN(value)) {\n        if (isKindLike(token, kind)) {\n            if (options?.strict) {\n                return isWellFormed(token, kind) ? value : (throwParseError(writeMalformedNumericLiteralMessage(token, kind)));\n            }\n            return value;\n        }\n    }\n    return (options?.errorOnFail ?\n        throwParseError(options?.errorOnFail === true ?\n            `Failed to parse ${numericLiteralDescriptions[kind]} from '${token}'`\n            : options?.errorOnFail)\n        : undefined);\n};\nexport const tryParseWellFormedBigint = (def) => {\n    if (def[def.length - 1] !== \"n\")\n        return;\n    const maybeIntegerLiteral = def.slice(0, -1);\n    let value;\n    try {\n        value = BigInt(maybeIntegerLiteral);\n    }\n    catch {\n        return;\n    }\n    if (wellFormedIntegerMatcher.test(maybeIntegerLiteral))\n        return value;\n    if (integerLikeMatcher.test(maybeIntegerLiteral)) {\n        // If the definition looks like a bigint but is\n        // not well-formed, throw.\n        return throwParseError(writeMalformedNumericLiteralMessage(def, \"bigint\"));\n    }\n};\n", "import { domainOf } from \"./domain.js\";\nimport { serializePrimitive } from \"./primitive.js\";\nimport { register } from \"./registry.js\";\nexport const snapshot = (data, opts = { onUndefined: \"(undefined)\" }) => _serialize(data, opts, []);\nexport const print = (data, indent) => console.log(printable(data, indent));\nexport const printable = (data, indent) => {\n    switch (domainOf(data)) {\n        case \"object\":\n            const o = data;\n            const ctorName = o.constructor.name;\n            return (ctorName === \"Object\" || ctorName === \"Array\" ?\n                JSON.stringify(_serialize(o, printableOpts, []), null, indent)\n                : o instanceof Date ? o.toDateString()\n                    : typeof o.expression === \"string\" ? o.expression\n                        : ctorName);\n        case \"symbol\":\n            return printableOpts.onSymbol(data);\n        default:\n            return serializePrimitive(data);\n    }\n};\nconst printableOpts = {\n    onCycle: () => \"(cycle)\",\n    onSymbol: v => `Symbol(${register(v)})`,\n    onFunction: v => `Function(${register(v)})`\n};\nconst _serialize = (data, opts, seen) => {\n    switch (domainOf(data)) {\n        case \"object\": {\n            if (typeof data === \"function\")\n                return printableOpts.onFunction(data);\n            if (seen.includes(data))\n                return \"(cycle)\";\n            const nextSeen = [...seen, data];\n            if (Array.isArray(data))\n                return data.map(item => _serialize(item, opts, nextSeen));\n            if (data instanceof Date)\n                return data.toDateString();\n            const result = {};\n            for (const k in data)\n                result[k] = _serialize(data[k], opts, nextSeen);\n            return result;\n        }\n        case \"symbol\":\n            return printableOpts.onSymbol(data);\n        case \"bigint\":\n            return `${data}n`;\n        case \"undefined\":\n            return opts.onUndefined ?? \"undefined\";\n        default:\n            return data;\n    }\n};\n", "export const capitalize = (s) => (s[0].toUpperCase() + s.slice(1));\nexport const anchoredRegex = (regex) => new RegExp(anchoredSource(regex), typeof regex === \"string\" ? \"\" : regex.flags);\nexport const deanchoredRegex = (regex) => new RegExp(deanchoredSource(regex), typeof regex === \"string\" ? \"\" : regex.flags);\nexport const anchoredSource = (regex) => {\n    const source = typeof regex === \"string\" ? regex : regex.source;\n    return `^(?:${source})$`;\n};\nexport const deanchoredSource = (regex) => {\n    const source = typeof regex === \"string\" ? regex : regex.source;\n    if (source.startsWith(\"^(?:\") && source.endsWith(\")$\"))\n        return source.slice(4, -2);\n    return source.slice(source[0] === \"^\" ? 1 : 0, source.at(-1) === \"$\" ? -1 : undefined);\n};\nexport const escapeToken = \"\\\\\";\nexport const whiteSpaceTokens = {\n    \" \": true,\n    \"\\n\": true,\n    \"\\t\": true\n};\n", "import { hasDomain } from \"./domain.js\";\nimport { ancestorsOf } from \"./objectKinds.js\";\nimport { NoopBase } from \"./records.js\";\n// even though the value we attach will be identical, we use this so classes\n// won't be treated as instanceof a Trait\nconst implementedTraits = Symbol(\"implementedTraits\");\nexport const hasTrait = (traitClass) => (o) => {\n    if (!hasDomain(o, \"object\"))\n        return false;\n    if (implementedTraits in o.constructor &&\n        o.constructor[implementedTraits].includes(traitClass))\n        return true;\n    // emulate standard instanceof behavior\n    return ancestorsOf(o).includes(traitClass);\n};\n/** @ts-expect-error required to extend NoopBase */\nexport class Trait extends NoopBase {\n    static get [Symbol.hasInstance]() {\n        return hasTrait(this);\n    }\n    traitsOf() {\n        return implementedTraits in this.constructor ?\n            this.constructor[implementedTraits]\n            : [];\n    }\n}\nconst collectPrototypeDescriptors = (trait) => {\n    let proto = trait.prototype;\n    let result = {};\n    do {\n        // ensure prototypes are sorted from lowest to highest precedence\n        result = Object.assign(Object.getOwnPropertyDescriptors(proto), result);\n        proto = Object.getPrototypeOf(proto);\n    } while (proto !== Object.prototype && proto !== null);\n    return result;\n};\nexport const compose = ((...traits) => {\n    const base = function (...args) {\n        for (const trait of traits) {\n            const instance = Reflect.construct(trait, args, this.constructor);\n            Object.assign(this, instance);\n        }\n    };\n    const flatImplementedTraits = [];\n    for (const trait of traits) {\n        // copy static properties\n        Object.assign(base, trait);\n        // flatten and copy prototype\n        Object.defineProperties(base.prototype, collectPrototypeDescriptors(trait));\n        if (implementedTraits in trait) {\n            // add any ancestor traits from which the current trait was composed\n            for (const innerTrait of trait[implementedTraits]) {\n                if (!flatImplementedTraits.includes(innerTrait))\n                    flatImplementedTraits.push(innerTrait);\n            }\n        }\n        if (!flatImplementedTraits.includes(trait))\n            flatImplementedTraits.push(trait);\n    }\n    Object.defineProperty(base, implementedTraits, {\n        value: flatImplementedTraits,\n        enumerable: false\n    });\n    return base;\n});\nexport const implement = (...args) => {\n    if (args.at(-1) instanceof Trait)\n        return compose(...args);\n    const implementation = args.at(-1);\n    const base = compose(...args.slice(0, -1));\n    // copy implementation last since it overrides traits\n    Object.defineProperties(base.prototype, Object.getOwnPropertyDescriptors(implementation));\n    return base;\n};\n", "import { flatMorph, isArray, isDotAccessible, printable, throwParseError } from \"@ark/util\";\nexport const makeRootAndArrayPropertiesMutable = (o) => \n// this cast should not be required, but it seems TS is referencing\n// the wrong parameters here?\nflatMorph(o, (k, v) => [k, isArray(v) ? [...v] : v]);\nexport const pathToPropString = (path, ...[opts]) => {\n    const stringifySymbol = opts?.stringifySymbol ?? printable;\n    const propAccessChain = path.reduce((s, k) => {\n        switch (typeof k) {\n            case \"string\":\n                return isDotAccessible(k) ? `${s}.${k}` : `${s}[${JSON.stringify(k)}]`;\n            case \"number\":\n                return `${s}[${k}]`;\n            case \"symbol\":\n                return `${s}[${stringifySymbol(k)}]`;\n            default:\n                if (opts?.stringifyNonKey)\n                    return `${s}[${opts.stringifyNonKey(k)}]`;\n                throwParseError(`${printable(k)} must be a PropertyKey or stringifyNonKey must be passed to options`);\n        }\n    }, \"\");\n    return propAccessChain[0] === \".\" ? propAccessChain.slice(1) : propAccessChain;\n};\nexport const arkKind = Symbol(\"ArkTypeInternalKind\");\nexport const hasArkKind = (value, kind) => value?.[arkKind] === kind;\nexport const isNode = (value) => hasArkKind(value, \"root\") || hasArkKind(value, \"constraint\");\n// ideally this could be just declared since it is not used at runtime,\n// but it doesn't play well with typescript-eslint: https://github.com/typescript-eslint/typescript-eslint/issues/4608\n// easiest solution seems to be just having it declared as a value so it doesn't break when we import at runtime\nexport const inferred = Symbol(\"inferred\");\n", "import { compileSerializedValue, flatMorph, printable, throwParseError } from \"@ark/util\";\nimport { isNode } from \"./utils.js\";\nexport const basisKinds = [\"unit\", \"proto\", \"domain\"];\nexport const structuralKinds = [\n    \"required\",\n    \"optional\",\n    \"index\",\n    \"sequence\"\n];\nexport const refinementKinds = [\n    \"pattern\",\n    \"divisor\",\n    \"exactLength\",\n    \"max\",\n    \"min\",\n    \"maxLength\",\n    \"minLength\",\n    \"before\",\n    \"after\"\n];\nexport const constraintKinds = [\n    ...refinementKinds,\n    ...structuralKinds,\n    \"structure\",\n    \"predicate\"\n];\nexport const rootKinds = [\n    \"alias\",\n    \"union\",\n    \"morph\",\n    \"unit\",\n    \"intersection\",\n    \"proto\",\n    \"domain\"\n];\nexport const nodeKinds = [...rootKinds, ...constraintKinds];\nexport const constraintKeys = flatMorph(constraintKinds, (i, kind) => [kind, 1]);\nexport const structureKeys = flatMorph([...structuralKinds, \"undeclared\"], (i, k) => [k, 1]);\nexport const precedenceByKind = flatMorph(nodeKinds, (i, kind) => [kind, i]);\nexport const isNodeKind = (value) => typeof value === \"string\" && value in precedenceByKind;\nexport function assertNodeKind(value, kind) {\n    const valueIsNode = isNode(value);\n    if (!valueIsNode || value.kind !== kind) {\n        throwParseError(`Expected node of kind ${kind} (was ${valueIsNode ? `${value.kind} node` : printable(value)})`);\n    }\n}\nexport const precedenceOfKind = (kind) => precedenceByKind[kind];\nexport const schemaKindsRightOf = (kind) => rootKinds.slice(precedenceOfKind(kind) + 1);\nexport const defaultValueSerializer = (v) => {\n    if (typeof v === \"string\" ||\n        typeof v === \"boolean\" ||\n        typeof v === \"number\" ||\n        v === null)\n        return v;\n    return compileSerializedValue(v);\n};\nexport const compileErrorContext = (ctx) => {\n    let result = \"{ \";\n    for (const [k, v] of Object.entries(ctx))\n        result += `${k}: ${compileSerializedValue(v)}, `;\n    return result + \" }\";\n};\nexport const baseKeys = {\n    description: { meta: true }\n};\nexport const implementNode = (_) => {\n    const implementation = _;\n    if (implementation.hasAssociatedError) {\n        implementation.defaults.expected ??= ctx => \"description\" in ctx ?\n            ctx.description\n            : implementation.defaults.description(ctx);\n        implementation.defaults.actual ??= data => printable(data);\n        implementation.defaults.problem ??= ctx => `must be ${ctx.expected}${ctx.actual ? ` (was ${ctx.actual})` : \"\"}`;\n        implementation.defaults.message ??= ctx => {\n            if (ctx.path.length === 0)\n                return ctx.problem;\n            const problemWithLocation = `${ctx.propString} ${ctx.problem}`;\n            if (problemWithLocation[0] === \"[\") {\n                // clarify paths like [1], [0][1], and [\"key!\"] that could be confusing\n                return `value at ${problemWithLocation}`;\n            }\n            return problemWithLocation;\n        };\n    }\n    Object.assign(implementation.keys, baseKeys);\n    return implementation;\n};\n", "import { isNodeKind } from \"./shared/implement.js\";\n$ark.config = {};\nexport const configure = (config) => Object.assign($ark.config, mergeConfigs($ark.config, config));\nexport const mergeConfigs = (base, extensions) => {\n    const result = { ...base };\n    let k;\n    for (k in extensions) {\n        result[k] =\n            isNodeKind(k) ?\n                {\n                    ...base[k],\n                    ...extensions[k]\n                }\n                : extensions[k];\n    }\n    return result;\n};\nconst nonInheritedKeys = [\n    \"intrinsic\",\n    \"prereducedAliases\"\n];\nexport const extendConfig = (base, extension) => {\n    if (!extension)\n        return base;\n    const result = mergeConfigs(base, extension);\n    nonInheritedKeys.forEach(k => {\n        if (!(k in extension))\n            delete result[k];\n    });\n    return result;\n};\nexport const resolveConfig = (config) => extendConfig(extendConfig($ark.defaultConfig, $ark.config), config);\n", "import { CastableBase, ReadonlyArray, defineProperties } from \"@ark/util\";\nimport { arkKind, pathToPropString } from \"./utils.js\";\nexport class ArkError extends CastableBase {\n    input;\n    [arkKind] = \"error\";\n    path;\n    data;\n    nodeConfig;\n    constructor(input, ctx) {\n        super();\n        this.input = input;\n        defineProperties(this, input);\n        const data = ctx.data;\n        if (input.code === \"union\") {\n            // flatten union errors to avoid repeating context like \"foo must be foo must be\"...\n            input.errors = input.errors.flatMap(e => e.hasCode(\"union\") ? e.errors : e);\n        }\n        this.nodeConfig = ctx.config[this.code];\n        this.path = input.path ?? [...ctx.path];\n        if (input.relativePath)\n            this.path.push(...input.relativePath);\n        this.data = \"data\" in input ? input.data : data;\n    }\n    hasCode(code) {\n        return this.code === code;\n    }\n    get propString() {\n        return pathToPropString(this.path);\n    }\n    get expected() {\n        return (this.input.expected ?? this.nodeConfig.expected?.(this.input));\n    }\n    get actual() {\n        // null is a valid value of actual meaning it should be omitted, so\n        // check for undefined explicitly\n        return this.input.actual !== undefined ?\n            this.input.actual\n            : this.nodeConfig.actual?.(this.data);\n    }\n    get problem() {\n        return this.input.problem ?? this.nodeConfig.problem(this);\n    }\n    get message() {\n        return this.input.message ?? this.nodeConfig.message(this);\n    }\n    toString() {\n        return this.message;\n    }\n    throw() {\n        throw this;\n    }\n}\nexport class ArkErrors extends ReadonlyArray {\n    ctx;\n    constructor(ctx) {\n        super();\n        this.ctx = ctx;\n    }\n    byPath = {};\n    count = 0;\n    mutable = this;\n    add(error) {\n        const existing = this.byPath[error.propString];\n        if (existing) {\n            const errorIntersection = new ArkError({\n                code: \"intersection\",\n                errors: existing.hasCode(\"intersection\") ?\n                    [...existing.errors, error]\n                    : [existing, error]\n            }, this.ctx);\n            const existingIndex = this.indexOf(existing);\n            // If existing is found (which it always should be unless this was externally mutated),\n            // replace it with the new problem intersection. In case it isn't for whatever reason,\n            // just append the intersection.\n            this.mutable[existingIndex === -1 ? this.length : existingIndex] =\n                errorIntersection;\n            this.byPath[error.propString] = errorIntersection;\n        }\n        else {\n            this.byPath[error.propString] = error;\n            this.mutable.push(error);\n        }\n        this.count++;\n    }\n    get summary() {\n        return this.toString();\n    }\n    get message() {\n        return this.toString();\n    }\n    toString() {\n        return this.join(\"\\n\");\n    }\n    throw() {\n        throw new AggregateError(this, this.message);\n    }\n}\n", "import { ArkError, ArkErrors } from \"./errors.js\";\nexport class TraversalContext {\n    root;\n    config;\n    path = [];\n    queuedMorphs = [];\n    errors = new ArkErrors(this);\n    branches = [];\n    seen = {};\n    constructor(root, config) {\n        this.root = root;\n        this.config = config;\n    }\n    get currentBranch() {\n        return this.branches.at(-1);\n    }\n    queueMorphs(morphs) {\n        const input = {\n            path: [...this.path],\n            morphs\n        };\n        this.currentBranch?.queuedMorphs.push(input) ??\n            this.queuedMorphs.push(input);\n    }\n    finalize() {\n        if (this.hasError())\n            return this.errors;\n        // invoking morphs that are Nodes will reuse this context, potentially\n        // adding additional morphs, so we have to continue looping until\n        // queuedMorphs is empty rather than iterating over the list once\n        while (this.queuedMorphs.length) {\n            const { path, morphs } = this.queuedMorphs.shift();\n            const key = path.at(-1);\n            let parent;\n            if (key !== undefined) {\n                // find the object on which the key to be morphed exists\n                parent = this.root;\n                for (let pathIndex = 0; pathIndex < path.length - 1; pathIndex++)\n                    parent = parent[path[pathIndex]];\n            }\n            this.path = path;\n            for (const morph of morphs) {\n                const result = morph(parent === undefined ? this.root : parent[key], this);\n                if (result instanceof ArkErrors)\n                    return result;\n                if (this.hasError())\n                    return this.errors;\n                if (result instanceof ArkError) {\n                    // if an ArkError was returned but wasn't added to these\n                    // errors, add it then return\n                    this.error(result);\n                    return this.errors;\n                }\n                // apply the morph function and assign the result to the\n                // corresponding property, or to root if path is empty\n                if (parent === undefined)\n                    this.root = result;\n                else\n                    parent[key] = result;\n            }\n        }\n        return this.root;\n    }\n    get currentErrorCount() {\n        return (this.currentBranch ?\n            this.currentBranch.error ?\n                1\n                : 0\n            : this.errors.count);\n    }\n    hasError() {\n        return this.currentErrorCount !== 0;\n    }\n    get failFast() {\n        return this.branches.length !== 0;\n    }\n    error(input) {\n        const errCtx = typeof input === \"object\" ?\n            input.code ?\n                input\n                : { ...input, code: \"predicate\" }\n            : { code: \"predicate\", expected: input };\n        const error = new ArkError(errCtx, this);\n        if (this.currentBranch)\n            this.currentBranch.error = error;\n        else\n            this.errors.add(error);\n        return error;\n    }\n    get data() {\n        let result = this.root;\n        for (const segment of this.path)\n            result = result?.[segment];\n        return result;\n    }\n    reject(input) {\n        this.error(input);\n        return false;\n    }\n    mustBe(expected) {\n        this.error(expected);\n        return false;\n    }\n    pushBranch() {\n        this.branches.push({\n            error: undefined,\n            queuedMorphs: []\n        });\n    }\n    popBranch() {\n        return this.branches.pop();\n    }\n}\n", "var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { Callable, appendUnique, cached, flatMorph, includes, isArray, isEmptyObject, throwError } from \"@ark/util\";\nimport { basisKinds, constraintKinds, precedenceOfKind, refinementKinds, rootKinds, structuralKinds } from \"./shared/implement.js\";\nimport { TraversalContext } from \"./shared/traversal.js\";\nimport { isNode, pathToPropString } from \"./shared/utils.js\";\nlet BaseNode = (() => {\n    let _classSuper = Callable;\n    let _instanceExtraInitializers = [];\n    let _get_description_decorators;\n    let _get_shallowReferences_decorators;\n    let _get_shallowMorphs_decorators;\n    let _get_flatRefs_decorators;\n    let _get_in_decorators;\n    let _get_out_decorators;\n    return class BaseNode extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _get_description_decorators = [cached];\n            _get_shallowReferences_decorators = [cached];\n            _get_shallowMorphs_decorators = [cached];\n            _get_flatRefs_decorators = [cached];\n            _get_in_decorators = [cached];\n            _get_out_decorators = [cached];\n            __esDecorate(this, null, _get_description_decorators, { kind: \"getter\", name: \"description\", static: false, private: false, access: { has: obj => \"description\" in obj, get: obj => obj.description }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _get_shallowReferences_decorators, { kind: \"getter\", name: \"shallowReferences\", static: false, private: false, access: { has: obj => \"shallowReferences\" in obj, get: obj => obj.shallowReferences }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _get_shallowMorphs_decorators, { kind: \"getter\", name: \"shallowMorphs\", static: false, private: false, access: { has: obj => \"shallowMorphs\" in obj, get: obj => obj.shallowMorphs }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _get_flatRefs_decorators, { kind: \"getter\", name: \"flatRefs\", static: false, private: false, access: { has: obj => \"flatRefs\" in obj, get: obj => obj.flatRefs }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _get_in_decorators, { kind: \"getter\", name: \"in\", static: false, private: false, access: { has: obj => \"in\" in obj, get: obj => obj.in }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _get_out_decorators, { kind: \"getter\", name: \"out\", static: false, private: false, access: { has: obj => \"out\" in obj, get: obj => obj.out }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        attachments = __runInitializers(this, _instanceExtraInitializers);\n        $;\n        constructor(attachments, $) {\n            super(\n            // pipedFromCtx allows us internally to reuse TraversalContext\n            // through pipes and keep track of piped paths. It is not exposed\n            (data, pipedFromCtx) => {\n                if (!this.includesMorph &&\n                    !this.allowsRequiresContext &&\n                    this.allows(data))\n                    return data;\n                if (pipedFromCtx) {\n                    this.traverseApply(data, pipedFromCtx);\n                    return pipedFromCtx.data;\n                }\n                const ctx = new TraversalContext(data, this.$.resolvedConfig);\n                this.traverseApply(data, ctx);\n                return ctx.finalize();\n            }, { attach: attachments });\n            this.attachments = attachments;\n            this.$ = $;\n        }\n        bindScope($) {\n            if (this.$ === $)\n                return this;\n            return new this.constructor(this.attachments, $);\n        }\n        includesMorph = this.kind === \"morph\" ||\n            (this.hasKind(\"optional\") && this.hasDefault()) ||\n            (this.hasKind(\"structure\") && this.undeclared === \"delete\") ||\n            this.children.some(child => child.includesMorph);\n        // if a predicate accepts exactly one arg, we can safely skip passing context\n        allowsRequiresContext = (this.hasKind(\"predicate\") && this.inner.predicate.length !== 1) ||\n            this.kind === \"alias\" ||\n            this.children.some(child => child.allowsRequiresContext);\n        referencesById = this.children.reduce((result, child) => Object.assign(result, child.referencesById), { [this.id]: this });\n        get description() {\n            const writer = this.$?.resolvedConfig[this.kind].description ??\n                $ark.config[this.kind]?.description ??\n                $ark.defaultConfig[this.kind].description;\n            return this.inner.description ?? writer(this);\n        }\n        // we don't cache this currently since it can be updated once a scope finishes\n        // resolving cyclic references, although it may be possible to ensure it is cached safely\n        get references() {\n            return Object.values(this.referencesById).filter(ref => !ref.id.startsWith(\"this\"));\n        }\n        get shallowReferences() {\n            return this.hasKind(\"structure\") ?\n                [this, ...this.children]\n                : this.children.reduce((acc, child) => appendUniqueNodes(acc, child.shallowReferences), [this]);\n        }\n        get shallowMorphs() {\n            return this.shallowReferences\n                .filter(n => n.hasKind(\"morph\"))\n                .sort((l, r) => (l.expression < r.expression ? -1 : 1));\n        }\n        // overriden by structural kinds so that only the root at each path is added\n        get flatRefs() {\n            return this.children\n                .reduce((acc, child) => appendUniqueFlatRefs(acc, child.flatRefs), [])\n                .sort((l, r) => l.path.length > r.path.length ? 1\n                : l.path.length < r.path.length ? -1\n                    : l.propString > r.propString ? 1\n                        : l.propString < r.propString ? -1\n                            : l.node.expression < r.node.expression ? -1\n                                : 1);\n        }\n        precedence = precedenceOfKind(this.kind);\n        jit = false;\n        allows = (data) => {\n            if (this.allowsRequiresContext) {\n                return this.traverseAllows(data, new TraversalContext(data, this.$.resolvedConfig));\n            }\n            return this.traverseAllows(data);\n        };\n        traverse(data) {\n            return this(data);\n        }\n        get in() {\n            return this.getIo(\"in\");\n        }\n        get out() {\n            return this.getIo(\"out\");\n        }\n        // Should be refactored to use transform\n        // https://github.com/arktypeio/arktype/issues/1020\n        getIo(kind) {\n            if (!this.includesMorph)\n                return this;\n            const ioInner = {};\n            for (const [k, v] of this.entries) {\n                const keySchemaImplementation = this.impl.keys[k];\n                if (keySchemaImplementation.meta)\n                    continue;\n                if (keySchemaImplementation.child) {\n                    const childValue = v;\n                    ioInner[k] =\n                        isArray(childValue) ?\n                            childValue.map(child => child[kind])\n                            : childValue[kind];\n                }\n                else\n                    ioInner[k] = v;\n            }\n            return this.$.node(this.kind, ioInner);\n        }\n        toJSON() {\n            return this.json;\n        }\n        toString() {\n            return this.expression;\n        }\n        equals(other) {\n            return this.typeHash === other.typeHash;\n        }\n        assertHasKind(kind) {\n            if (!this.kind === kind)\n                throwError(`${this.kind} node was not of asserted kind ${kind}`);\n            return this;\n        }\n        hasKind(kind) {\n            return this.kind === kind;\n        }\n        isBasis() {\n            return includes(basisKinds, this.kind);\n        }\n        isConstraint() {\n            return includes(constraintKinds, this.kind);\n        }\n        isStructural() {\n            return includes(structuralKinds, this.kind);\n        }\n        isRefinement() {\n            return includes(refinementKinds, this.kind);\n        }\n        isRoot() {\n            return includes(rootKinds, this.kind);\n        }\n        hasUnit(value) {\n            return this.hasKind(\"unit\") && this.allows(value);\n        }\n        hasOpenIntersection() {\n            return this.impl.intersectionIsOpen;\n        }\n        get nestableExpression() {\n            return this.expression;\n        }\n        firstReference(filter) {\n            return this.references.find(n => n !== this && filter(n));\n        }\n        firstReferenceOrThrow(filter) {\n            return (this.firstReference(filter) ??\n                throwError(`${this.id} had no references matching predicate ${filter}`));\n        }\n        firstReferenceOfKind(kind) {\n            return this.firstReference(node => node.hasKind(kind));\n        }\n        firstReferenceOfKindOrThrow(kind) {\n            return (this.firstReference(node => node.kind === kind) ??\n                throwError(`${this.id} had no ${kind} references`));\n        }\n        transform(mapper, opts) {\n            return this._transform(mapper, {\n                ...opts,\n                seen: {},\n                path: [],\n                parseOptions: {\n                    prereduced: opts?.prereduced ?? false\n                }\n            });\n        }\n        _transform(mapper, ctx) {\n            const $ = ctx.bindScope?.internal ?? this.$;\n            if (ctx.seen[this.id])\n                // Cyclic handling needs to be made more robust\n                // https://github.com/arktypeio/arktype/issues/944\n                return this.$.lazilyResolve(ctx.seen[this.id]);\n            if (ctx.shouldTransform?.(this, ctx) === false)\n                return this;\n            let transformedNode;\n            ctx.seen[this.id] = () => transformedNode;\n            const innerWithTransformedChildren = flatMorph(this.inner, (k, v) => {\n                if (!this.impl.keys[k].child)\n                    return [k, v];\n                const children = v;\n                if (!isArray(children)) {\n                    const transformed = children._transform(mapper, ctx);\n                    return transformed ? [k, transformed] : [];\n                }\n                // if the value was previously explicitly set to an empty list,\n                // (e.g. branches for `never`), ensure it is not pruned\n                if (children.length === 0)\n                    return [k, v];\n                const transformed = children.flatMap(n => {\n                    const transformedChild = n._transform(mapper, ctx);\n                    return transformedChild ?? [];\n                });\n                return transformed.length ? [k, transformed] : [];\n            });\n            delete ctx.seen[this.id];\n            const transformedInner = mapper(this.kind, innerWithTransformedChildren, ctx);\n            if (transformedInner === null)\n                return null;\n            if (isNode(transformedInner))\n                return (transformedNode = transformedInner);\n            if (isEmptyObject(transformedInner) &&\n                // if inner was previously an empty object (e.g. unknown) ensure it is not pruned\n                !isEmptyObject(this.inner))\n                return null;\n            if ((this.kind === \"required\" ||\n                this.kind === \"optional\" ||\n                this.kind === \"index\") &&\n                !(\"value\" in transformedInner))\n                return null;\n            if (this.kind === \"morph\") {\n                ;\n                transformedInner.in ??= $ark.intrinsic\n                    .unknown;\n            }\n            return (transformedNode = $.node(this.kind, transformedInner, ctx.parseOptions));\n        }\n        configureShallowDescendants(configOrDescription) {\n            const config = typeof configOrDescription === \"string\" ?\n                { description: configOrDescription }\n                : configOrDescription;\n            return this.transform((kind, inner) => ({ ...inner, ...config }), {\n                shouldTransform: node => node.kind !== \"structure\"\n            });\n        }\n    };\n})();\nexport { BaseNode };\nexport const typePathToPropString = (path) => pathToPropString(path, {\n    stringifyNonKey: node => node.expression\n});\nexport const flatRef = (path, node) => ({\n    path,\n    node,\n    propString: typePathToPropString(path)\n});\nexport const flatRefsAreEqual = (l, r) => l.propString === r.propString && l.node.equals(r.node);\nexport const appendUniqueFlatRefs = (existing, refs) => appendUnique(existing, refs, {\n    isEqual: flatRefsAreEqual\n});\nexport const appendUniqueNodes = (existing, refs) => appendUnique(existing, refs, {\n    isEqual: (l, r) => l.equals(r)\n});\n", "import { isArray, throwParseError } from \"@ark/util\";\nimport { hasArkKind, pathToPropString } from \"./utils.js\";\nexport class Disjoint extends Array {\n    static init(kind, l, r, ctx) {\n        return new Disjoint({\n            kind,\n            l,\n            r,\n            path: ctx?.path ?? [],\n            optional: ctx?.optional ?? false\n        });\n    }\n    add(kind, l, r, ctx) {\n        this.push({\n            kind,\n            l,\n            r,\n            path: ctx?.path ?? [],\n            optional: ctx?.optional ?? false\n        });\n        return this;\n    }\n    describeReasons() {\n        if (this.length === 1) {\n            const { path, l, r } = this[0];\n            const pathString = pathToPropString(path);\n            return `Intersection${pathString && ` at ${pathString}`} of ${describeReasons(l, r)} results in an unsatisfiable type`;\n        }\n        return `The following intersections result in unsatisfiable types:\\n• ${this.map(({ path, l, r }) => `${path}: ${describeReasons(l, r)}`).join(\"\\n• \")}`;\n    }\n    throw() {\n        return throwParseError(this.describeReasons());\n    }\n    invert() {\n        return this.map(entry => ({\n            ...entry,\n            l: entry.r,\n            r: entry.l\n        }));\n    }\n    withPrefixKey(key, kind) {\n        return this.map(entry => ({\n            ...entry,\n            path: [key, ...entry.path],\n            optional: entry.optional || kind === \"optional\"\n        }));\n    }\n}\nconst describeReasons = (l, r) => `${describeReason(l)} and ${describeReason(r)}`;\nconst describeReason = (value) => hasArkKind(value, \"root\") ? value.expression\n    : isArray(value) ? value.map(describeReason).join(\" | \")\n        : String(value);\n", "import { Hkt } from \"@ark/util\";\nimport { Disjoint } from \"./disjoint.js\";\nimport { isNode } from \"./utils.js\";\nconst intersectionCache = {};\nexport const intersectNodesRoot = (l, r, $) => intersectNodes(l, r, {\n    $,\n    invert: false,\n    pipe: false\n});\nexport const pipeNodesRoot = (l, r, $) => intersectNodes(l, r, {\n    $,\n    invert: false,\n    pipe: true\n});\nexport const intersectNodes = (l, r, ctx) => {\n    const operator = ctx.pipe ? \"|>\" : \"&\";\n    const lrCacheKey = `${l.typeHash}${operator}${r.typeHash}`;\n    if (intersectionCache[lrCacheKey] !== undefined)\n        return intersectionCache[lrCacheKey];\n    if (!ctx.pipe) {\n        // we can only use this for the commutative & operator\n        const rlCacheKey = `${r.typeHash}${operator}${l.typeHash}`;\n        if (intersectionCache[rlCacheKey] !== undefined) {\n            // if the cached result was a Disjoint and the operands originally\n            // appeared in the opposite order, we need to invert it to match\n            const rlResult = intersectionCache[rlCacheKey];\n            const lrResult = rlResult instanceof Disjoint ? rlResult.invert() : rlResult;\n            // add the lr result to the cache directly to bypass this check in the future\n            intersectionCache[lrCacheKey] = lrResult;\n            return lrResult;\n        }\n    }\n    if (l.equals(r))\n        return l;\n    let result;\n    if (ctx.pipe && l.kind !== \"union\" && r.kind !== \"union\") {\n        if (l.includesMorph) {\n            if (l.hasKind(\"morph\")) {\n                result =\n                    ctx.invert ?\n                        pipeToMorph(r, l, ctx)\n                        : pipeFromMorph(l, r, ctx);\n            }\n            else {\n                result = ctx.$.node(\"morph\", {\n                    morphs: [r],\n                    in: l\n                });\n            }\n        }\n        else if (r.includesMorph) {\n            if (!r.hasKind(\"morph\")) {\n                result = ctx.$.node(\"morph\", {\n                    morphs: [r],\n                    in: l\n                });\n            }\n            else {\n                result =\n                    ctx.invert ?\n                        pipeFromMorph(r, l, ctx)\n                        : pipeToMorph(l, r, ctx);\n            }\n        }\n    }\n    if (!result) {\n        const leftmostKind = l.precedence < r.precedence ? l.kind : r.kind;\n        const implementation = l.impl.intersections[r.kind] ?? r.impl.intersections[l.kind];\n        if (implementation === undefined) {\n            // should be two ConstraintNodes that have no relation\n            // this could also happen if a user directly intersects a Type and a ConstraintNode,\n            // but that is not allowed by the external function signature\n            result = null;\n        }\n        else if (leftmostKind === l.kind)\n            result = implementation(l, r, ctx);\n        else {\n            result = implementation(r, l, { ...ctx, invert: !ctx.invert });\n            if (result instanceof Disjoint)\n                result = result.invert();\n        }\n    }\n    if (isNode(result)) {\n        // if the result equals one of the operands, preserve its metadata by\n        // returning the original reference\n        if (l.equals(result))\n            result = l;\n        else if (r.equals(result))\n            result = r;\n    }\n    intersectionCache[lrCacheKey] = result;\n    return result;\n};\nexport const pipeFromMorph = (from, to, ctx) => {\n    const morphs = [...from.morphs];\n    if (from.validatedOut) {\n        // still piped from context, so allows appending additional morphs\n        const outIntersection = intersectNodes(from.validatedOut, to, ctx);\n        if (outIntersection instanceof Disjoint)\n            return outIntersection;\n        morphs[morphs.length - 1] = outIntersection;\n    }\n    else\n        morphs.push(to);\n    return ctx.$.node(\"morph\", {\n        morphs,\n        in: from.in\n    });\n};\nexport const pipeToMorph = (from, to, ctx) => {\n    const result = intersectNodes(from, to.in, ctx);\n    if (result instanceof Disjoint)\n        return result;\n    return ctx.$.node(\"morph\", {\n        morphs: to.morphs,\n        in: result\n    });\n};\n", "import { append, appendUnique, capitalize, isArray, throwInternalError, throwParseError } from \"@ark/util\";\nimport { BaseNode } from \"./node.js\";\nimport { Disjoint } from \"./shared/disjoint.js\";\nimport { compileErrorContext, constraintKeys } from \"./shared/implement.js\";\nimport { intersectNodes, intersectNodesRoot } from \"./shared/intersections.js\";\nimport { arkKind } from \"./shared/utils.js\";\nexport class BaseConstraint extends BaseNode {\n    [arkKind] = \"constraint\";\n    impliedSiblings;\n    intersect(r) {\n        return intersectNodesRoot(this, r, this.$);\n    }\n}\nexport class RawPrimitiveConstraint extends BaseConstraint {\n    traverseApply = (data, ctx) => {\n        if (!this.traverseAllows(data, ctx))\n            ctx.error(this.errorContext);\n    };\n    compile(js) {\n        if (js.traversalKind === \"Allows\")\n            js.return(this.compiledCondition);\n        else {\n            js.if(this.compiledNegation, () => js.line(`${js.ctx}.error(${this.compiledErrorContext})`));\n        }\n    }\n    get errorContext() {\n        return { code: this.kind, description: this.description, ...this.inner };\n    }\n    get compiledErrorContext() {\n        return compileErrorContext(this.errorContext);\n    }\n}\nexport const constraintKeyParser = (kind) => (schema, ctx) => {\n    if (isArray(schema)) {\n        if (schema.length === 0) {\n            // Omit empty lists as input\n            return;\n        }\n        const nodes = schema.map(schema => ctx.$.node(kind, schema));\n        // predicate order must be preserved to ensure inputs are narrowed\n        // and checked in the correct order\n        if (kind === \"predicate\")\n            return nodes;\n        return nodes.sort((l, r) => (l.innerHash < r.innerHash ? -1 : 1));\n    }\n    const child = ctx.$.node(kind, schema);\n    return child.hasOpenIntersection() ? [child] : child;\n};\nexport const intersectConstraints = (s) => {\n    const head = s.r.shift();\n    if (!head) {\n        let result = s.l.length === 0 && s.kind === \"structure\" ?\n            $ark.intrinsic.unknown.internal\n            : s.ctx.$.node(s.kind, Object.assign(s.baseInner, unflattenConstraints(s.l)), { prereduced: true });\n        for (const root of s.roots) {\n            if (result instanceof Disjoint)\n                return result;\n            result = intersectNodes(root, result, s.ctx);\n        }\n        return result;\n    }\n    let matched = false;\n    for (let i = 0; i < s.l.length; i++) {\n        const result = intersectNodes(s.l[i], head, s.ctx);\n        if (result === null)\n            continue;\n        if (result instanceof Disjoint)\n            return result;\n        if (!matched) {\n            if (result.isRoot()) {\n                s.roots.push(result);\n                s.l.splice(i);\n                return intersectConstraints(s);\n            }\n            s.l[i] = result;\n            matched = true;\n        }\n        else if (!s.l.includes(result)) {\n            return throwInternalError(`Unexpectedly encountered multiple distinct intersection results for refinement ${result}`);\n        }\n    }\n    if (!matched)\n        s.l.push(head);\n    if (s.kind === \"intersection\")\n        head.impliedSiblings?.forEach(node => appendUnique(s.r, node));\n    return intersectConstraints(s);\n};\nexport const flattenConstraints = (inner) => {\n    const result = Object.entries(inner)\n        .flatMap(([k, v]) => k in constraintKeys ? v : [])\n        .sort((l, r) => l.precedence < r.precedence ? -1\n        : l.precedence > r.precedence ? 1\n            // preserve order for predicates\n            : l.kind === \"predicate\" && r.kind === \"predicate\" ? 0\n                : l.innerHash < r.innerHash ? -1\n                    : 1);\n    return result;\n};\n// TODO: Fix type\nexport const unflattenConstraints = (constraints) => {\n    const inner = {};\n    for (const constraint of constraints) {\n        if (constraint.hasOpenIntersection()) {\n            inner[constraint.kind] = append(inner[constraint.kind], constraint);\n        }\n        else {\n            if (inner[constraint.kind]) {\n                return throwInternalError(`Unexpected intersection of closed refinements of kind ${constraint.kind}`);\n            }\n            inner[constraint.kind] = constraint;\n        }\n    }\n    return inner;\n};\nexport const throwInvalidOperandError = (...args) => throwParseError(writeInvalidOperandMessage(...args));\nexport const writeInvalidOperandMessage = (kind, expected, actual) => `${capitalize(kind)} operand must be ${expected.description} (was ${actual.exclude(expected).description})`;\n", "var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { Callable, cached, flatMorph, isThunk, throwParseError } from \"@ark/util\";\nimport { arkKind } from \"./shared/utils.js\";\nexport const parseGeneric = (paramDefs, bodyDef, $) => new GenericRoot(paramDefs, bodyDef, $, $);\nexport class LazyGenericRoot extends Callable {\n}\nlet GenericRoot = (() => {\n    let _classSuper = Callable;\n    let _instanceExtraInitializers = [];\n    let _get_params_decorators;\n    let _get_names_decorators;\n    let _get_constraints_decorators;\n    let _get_baseInstantiation_decorators;\n    return class GenericRoot extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _get_params_decorators = [cached];\n            _get_names_decorators = [cached];\n            _get_constraints_decorators = [cached];\n            _get_baseInstantiation_decorators = [cached];\n            __esDecorate(this, null, _get_params_decorators, { kind: \"getter\", name: \"params\", static: false, private: false, access: { has: obj => \"params\" in obj, get: obj => obj.params }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _get_names_decorators, { kind: \"getter\", name: \"names\", static: false, private: false, access: { has: obj => \"names\" in obj, get: obj => obj.names }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _get_constraints_decorators, { kind: \"getter\", name: \"constraints\", static: false, private: false, access: { has: obj => \"constraints\" in obj, get: obj => obj.constraints }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _get_baseInstantiation_decorators, { kind: \"getter\", name: \"baseInstantiation\", static: false, private: false, access: { has: obj => \"baseInstantiation\" in obj, get: obj => obj.baseInstantiation }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        paramDefs = __runInitializers(this, _instanceExtraInitializers);\n        bodyDef;\n        _$;\n        _arg$;\n        [arkKind] = \"generic\";\n        constructor(paramDefs, bodyDef, _$, _arg$) {\n            super((...args) => {\n                const argNodes = flatMorph(this.names, (i, name) => {\n                    const arg = this.arg$.parseRoot(args[i]);\n                    if (!arg.extends(this.constraints[i])) {\n                        throwParseError(writeUnsatisfiedParameterConstraintMessage(name, this.constraints[i].expression, arg.expression));\n                    }\n                    return [name, arg];\n                });\n                if (bodyDef instanceof LazyGenericRoot)\n                    return this.$.parseRoot(bodyDef(argNodes));\n                return this.$.parseRoot(bodyDef, { args: argNodes });\n            });\n            this.paramDefs = paramDefs;\n            this.bodyDef = bodyDef;\n            this._$ = _$;\n            this._arg$ = _arg$;\n            // if this is a standalone generic, validate its base constraints right away\n            if (!isThunk(this._$))\n                this.validateBaseInstantiation();\n            // if it's part of a scope, scope.export will be resposible for invoking\n            // validateBaseInstantiation on export() once everything is resolvable\n        }\n        get $() {\n            return isThunk(this._$) ? this._$() : this._$;\n        }\n        get arg$() {\n            return isThunk(this._arg$) ? this._arg$() : this._arg$;\n        }\n        bindScope($) {\n            if (this.arg$ === $)\n                return this;\n            return new GenericRoot(this.params, this.bodyDef, this.$, $);\n        }\n        get params() {\n            return this.paramDefs.map((param) => typeof param === \"string\" ?\n                [param, $ark.intrinsic.unknown]\n                : [param[0], this.$.parseRoot(param[1])]);\n        }\n        get names() {\n            return this.params.map(e => e[0]);\n        }\n        get constraints() {\n            return this.params.map(e => e[1]);\n        }\n        get baseInstantiation() {\n            return this(...this.constraints);\n        }\n        validateBaseInstantiation() {\n            this.baseInstantiation;\n            return this;\n        }\n        get internal() {\n            return this;\n        }\n        get references() {\n            return this.baseInstantiation.internal.references;\n        }\n    };\n})();\nexport { GenericRoot };\nexport const writeUnsatisfiedParameterConstraintMessage = (name, constraint, arg) => `${name} must be assignable to ${constraint} (was ${arg})`;\n", "import { registeredReference } from \"@ark/util\";\nimport { BaseConstraint } from \"./constraint.js\";\nimport { compileErrorContext, implementNode } from \"./shared/implement.js\";\nexport const predicateImplementation = implementNode({\n    kind: \"predicate\",\n    hasAssociatedError: true,\n    collapsibleKey: \"predicate\",\n    keys: {\n        predicate: {}\n    },\n    normalize: schema => typeof schema === \"function\" ? { predicate: schema } : schema,\n    defaults: {\n        description: node => `valid according to ${node.predicate.name || \"an anonymous predicate\"}`\n    },\n    intersectionIsOpen: true,\n    intersections: {\n        // as long as the narrows in l and r are individually safe to check\n        // in the order they're specified, checking them in the order\n        // resulting from this intersection should also be safe.\n        predicate: () => null\n    }\n});\nexport class PredicateNode extends BaseConstraint {\n    serializedPredicate = registeredReference(this.predicate);\n    compiledCondition = `${this.serializedPredicate}(data, ctx)`;\n    compiledNegation = `!${this.compiledCondition}`;\n    impliedBasis = null;\n    expression = this.serializedPredicate;\n    traverseAllows = this.predicate;\n    errorContext = {\n        code: \"predicate\",\n        description: this.description\n    };\n    compiledErrorContext = compileErrorContext(this.errorContext);\n    traverseApply = (data, ctx) => {\n        if (!this.predicate(data, ctx) && !ctx.hasError())\n            ctx.error(this.errorContext);\n    };\n    compile(js) {\n        if (js.traversalKind === \"Allows\") {\n            js.return(this.compiledCondition);\n            return;\n        }\n        js.if(`${this.compiledNegation} && !ctx.hasError()`, () => js.line(`ctx.error(${this.compiledErrorContext})`));\n    }\n}\n", "import { RawPrimitiveConstraint, writeInvalidOperandMessage } from \"../constraint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nexport const divisorImplementation = implementNode({\n    kind: \"divisor\",\n    collapsibleKey: \"rule\",\n    keys: {\n        rule: {}\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    hasAssociatedError: true,\n    defaults: {\n        description: node => node.rule === 1 ? \"an integer\" : `a multiple of ${node.rule}`\n    },\n    intersections: {\n        divisor: (l, r, ctx) => ctx.$.node(\"divisor\", {\n            rule: Math.abs((l.rule * r.rule) / greatestCommonDivisor(l.rule, r.rule))\n        })\n    }\n});\nexport class DivisorNode extends RawPrimitiveConstraint {\n    traverseAllows = data => data % this.rule === 0;\n    compiledCondition = `data % ${this.rule} === 0`;\n    compiledNegation = `data % ${this.rule} !== 0`;\n    impliedBasis = $ark.intrinsic.number;\n    expression = `% ${this.rule}`;\n}\nexport const writeIndivisibleMessage = (t) => writeInvalidOperandMessage(\"divisor\", $ark.intrinsic.number, t);\n// https://en.wikipedia.org/wiki/Euclidean_algorithm\nconst greatestCommonDivisor = (l, r) => {\n    let previous;\n    let greatestCommonDivisor = l;\n    let current = r;\n    while (current !== 0) {\n        previous = current;\n        current = greatestCommonDivisor % current;\n        greatestCommonDivisor = previous;\n    }\n    return greatestCommonDivisor;\n};\n", "import { isKeyOf } from \"@ark/util\";\nimport { RawPrimitiveConstraint } from \"../constraint.js\";\nexport class BaseRange extends RawPrimitiveConstraint {\n    boundOperandKind = operandKindsByBoundKind[this.kind];\n    compiledActual = this.boundOperandKind === \"value\" ? `data`\n        : this.boundOperandKind === \"length\" ? `data.length`\n            : `data.valueOf()`;\n    comparator = compileComparator(this.kind, this.exclusive);\n    numericLimit = this.rule.valueOf();\n    expression = `${this.comparator} ${this.rule}`;\n    compiledCondition = `${this.compiledActual} ${this.comparator} ${this.numericLimit}`;\n    compiledNegation = `${this.compiledActual} ${negatedComparators[this.comparator]} ${this.numericLimit}`;\n    // we need to compute stringLimit before errorContext, which references it\n    // transitively through description for date bounds\n    stringLimit = this.boundOperandKind === \"date\" ?\n        dateLimitToString(this.numericLimit)\n        : `${this.numericLimit}`;\n    limitKind = this.comparator[\"0\"] === \"<\" ? \"upper\" : \"lower\";\n    isStricterThan(r) {\n        const thisLimitIsStricter = this.limitKind === \"upper\" ?\n            this.numericLimit < r.numericLimit\n            : this.numericLimit > r.numericLimit;\n        return (thisLimitIsStricter ||\n            (this.numericLimit === r.numericLimit &&\n                this.exclusive === true &&\n                !r.exclusive));\n    }\n    overlapsRange(r) {\n        if (this.isStricterThan(r))\n            return false;\n        if (this.numericLimit === r.numericLimit && (this.exclusive || r.exclusive))\n            return false;\n        return true;\n    }\n    overlapIsUnit(r) {\n        return (this.numericLimit === r.numericLimit && !this.exclusive && !r.exclusive);\n    }\n}\nconst negatedComparators = {\n    \"<\": \">=\",\n    \"<=\": \">\",\n    \">\": \"<=\",\n    \">=\": \"<\"\n};\nexport const boundKindPairsByLower = {\n    min: \"max\",\n    minLength: \"maxLength\",\n    after: \"before\"\n};\nexport const parseExclusiveKey = {\n    // omit key with value false since it is the default\n    parse: (flag) => flag || undefined\n};\nexport const parseDateLimit = (limit) => typeof limit === \"string\" || typeof limit === \"number\" ?\n    new Date(limit)\n    : limit;\nconst operandKindsByBoundKind = {\n    min: \"value\",\n    max: \"value\",\n    minLength: \"length\",\n    maxLength: \"length\",\n    after: \"date\",\n    before: \"date\"\n};\nexport const compileComparator = (kind, exclusive) => `${isKeyOf(kind, boundKindPairsByLower) ? \">\" : \"<\"}${exclusive ? \"\" : \"=\"}`;\nexport const dateLimitToString = (limit) => typeof limit === \"string\" ? limit : new Date(limit).toLocaleString();\nexport const writeUnboundableMessage = (root) => `Bounded expression ${root} must be a number, string, Array, or Date`;\n", "import { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseDateLimit, parseExclusiveKey } from \"./range.js\";\nexport const afterImplementation = implementNode({\n    kind: \"after\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {\n            parse: parseDateLimit,\n            serialize: schema => schema.toISOString()\n        },\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => (typeof schema === \"number\" ||\n        typeof schema === \"string\" ||\n        schema instanceof Date) ?\n        { rule: schema }\n        : schema,\n    defaults: {\n        description: node => node.exclusive ?\n            `after ${node.stringLimit}`\n            : `${node.stringLimit} or later`,\n        actual: data => data.toLocaleString()\n    },\n    intersections: {\n        after: (l, r) => (l.isStricterThan(r) ? l : r)\n    }\n});\nexport class AfterNode extends BaseRange {\n    impliedBasis = $ark.intrinsic.Date;\n    traverseAllows = this.exclusive ? data => data > this.rule : data => data >= this.rule;\n}\n", "import { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseDateLimit, parseExclusiveKey } from \"./range.js\";\nexport const beforeImplementation = implementNode({\n    kind: \"before\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {\n            parse: parseDateLimit,\n            serialize: schema => schema.toISOString()\n        },\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => (typeof schema === \"number\" ||\n        typeof schema === \"string\" ||\n        schema instanceof Date) ?\n        { rule: schema }\n        : schema,\n    defaults: {\n        description: node => node.exclusive ?\n            `before ${node.stringLimit}`\n            : `${node.stringLimit} or earlier`,\n        actual: data => data.toLocaleString()\n    },\n    intersections: {\n        before: (l, r) => (l.isStricterThan(r) ? l : r),\n        after: (before, after, ctx) => before.overlapsRange(after) ?\n            before.overlapIsUnit(after) ?\n                ctx.$.node(\"unit\", { unit: before.rule })\n                : null\n            : Disjoint.init(\"range\", before, after)\n    }\n});\nexport class BeforeNode extends BaseRange {\n    traverseAllows = this.exclusive ? data => data < this.rule : data => data <= this.rule;\n    impliedBasis = $ark.intrinsic.Date;\n}\n", "import { RawPrimitiveConstraint } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nexport const exactLengthImplementation = implementNode({\n    kind: \"exactLength\",\n    collapsibleKey: \"rule\",\n    keys: {\n        rule: {}\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    hasAssociatedError: true,\n    defaults: {\n        description: node => `exactly length ${node.rule}`,\n        actual: data => `${data.length}`\n    },\n    intersections: {\n        exactLength: (l, r, ctx) => Disjoint.init(\"unit\", ctx.$.node(\"unit\", { unit: l.rule }), ctx.$.node(\"unit\", { unit: r.rule }), { path: [\"length\"] }),\n        minLength: (exactLength, minLength) => (minLength.exclusive ?\n            exactLength.rule > minLength.rule\n            : exactLength.rule >= minLength.rule) ?\n            exactLength\n            : Disjoint.init(\"range\", exactLength, minLength),\n        maxLength: (exactLength, maxLength) => (maxLength.exclusive ?\n            exactLength.rule < maxLength.rule\n            : exactLength.rule <= maxLength.rule) ?\n            exactLength\n            : Disjoint.init(\"range\", exactLength, maxLength)\n    }\n});\nexport class ExactLengthNode extends RawPrimitiveConstraint {\n    traverseAllows = data => data.length === this.rule;\n    compiledCondition = `data.length === ${this.rule}`;\n    compiledNegation = `data.length !== ${this.rule}`;\n    impliedBasis = $ark.intrinsic.lengthBoundable;\n    expression = `{ length: ${this.rule} }`;\n}\n", "import { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nexport const maxImplementation = implementNode({\n    kind: \"max\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => `${node.exclusive ? \"less than\" : \"at most\"} ${node.rule}`\n    },\n    intersections: {\n        max: (l, r) => (l.isStricterThan(r) ? l : r),\n        min: (max, min, ctx) => max.overlapsRange(min) ?\n            max.overlapIsUnit(min) ?\n                ctx.$.node(\"unit\", { unit: max.rule })\n                : null\n            : Disjoint.init(\"range\", max, min)\n    }\n});\nexport class MaxNode extends BaseRange {\n    impliedBasis = $ark.intrinsic.number;\n    traverseAllows = this.exclusive ? data => data < this.rule : data => data <= this.rule;\n}\n", "import { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nexport const maxLengthImplementation = implementNode({\n    kind: \"maxLength\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => node.exclusive ?\n            `less than length ${node.rule}`\n            : `at most length ${node.rule}`,\n        actual: data => `${data.length}`\n    },\n    intersections: {\n        maxLength: (l, r) => (l.isStricterThan(r) ? l : r),\n        minLength: (max, min, ctx) => max.overlapsRange(min) ?\n            max.overlapIsUnit(min) ?\n                ctx.$.node(\"exactLength\", { rule: max.rule })\n                : null\n            : Disjoint.init(\"range\", max, min)\n    }\n});\nexport class MaxLengthNode extends BaseRange {\n    impliedBasis = $ark.intrinsic.lengthBoundable;\n    traverseAllows = this.exclusive ?\n        data => data.length < this.rule\n        : data => data.length <= this.rule;\n}\n", "import { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nexport const minImplementation = implementNode({\n    kind: \"min\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => `${node.exclusive ? \"more than\" : \"at least\"} ${node.rule}`\n    },\n    intersections: {\n        min: (l, r) => (l.isStricterThan(r) ? l : r)\n    }\n});\nexport class MinNode extends BaseRange {\n    impliedBasis = $ark.intrinsic.number;\n    traverseAllows = this.exclusive ? data => data > this.rule : data => data >= this.rule;\n}\n", "import { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nexport const minLengthImplementation = implementNode({\n    kind: \"minLength\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => node.exclusive ?\n            node.rule === 0 ?\n                \"non-empty\"\n                : `more than length ${node.rule}`\n            : node.rule === 1 ? \"non-empty\"\n                : `at least length ${node.rule}`,\n        // avoid default message like \"must be non-empty (was 0)\"\n        actual: data => (data.length === 0 ? null : `${data.length}`)\n    },\n    intersections: {\n        minLength: (l, r) => (l.isStricterThan(r) ? l : r)\n    }\n});\nexport class MinLengthNode extends BaseRange {\n    impliedBasis = $ark.intrinsic.lengthBoundable;\n    traverseAllows = this.exclusive ?\n        data => data.length > this.rule\n        : data => data.length >= this.rule;\n}\n", "import { AfterNode, afterImplementation } from \"./after.js\";\nimport { BeforeNode, beforeImplementation } from \"./before.js\";\nimport { ExactLengthNode, exactLengthImplementation } from \"./exactLength.js\";\nimport { MaxNode, maxImplementation } from \"./max.js\";\nimport { MaxLengthNode, maxLengthImplementation } from \"./maxLength.js\";\nimport { MinNode, minImplementation } from \"./min.js\";\nimport { MinLengthNode, minLengthImplementation } from \"./minLength.js\";\nexport const boundImplementationsByKind = {\n    min: minImplementation,\n    max: maxImplementation,\n    minLength: minLengthImplementation,\n    maxLength: maxLengthImplementation,\n    exactLength: exactLengthImplementation,\n    after: afterImplementation,\n    before: beforeImplementation\n};\nexport const boundClassesByKind = {\n    min: MinNode,\n    max: MaxNode,\n    minLength: MinLengthNode,\n    maxLength: MaxLengthNode,\n    exactLength: ExactLengthNode,\n    after: AfterNode,\n    before: BeforeNode\n};\n", "import { RawPrimitiveConstraint } from \"../constraint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nexport const patternImplementation = implementNode({\n    kind: \"pattern\",\n    collapsibleKey: \"rule\",\n    keys: {\n        rule: {},\n        flags: {}\n    },\n    normalize: schema => typeof schema === \"string\" ? { rule: schema }\n        : schema instanceof RegExp ?\n            schema.flags ?\n                { rule: schema.source, flags: schema.flags }\n                : { rule: schema.source }\n            : schema,\n    hasAssociatedError: true,\n    intersectionIsOpen: true,\n    defaults: {\n        description: node => `matched by ${node.rule}`\n    },\n    intersections: {\n        // for now, non-equal regex are naively intersected:\n        // https://github.com/arktypeio/arktype/issues/853\n        pattern: () => null\n    }\n});\nexport class PatternNode extends RawPrimitiveConstraint {\n    instance = new RegExp(this.rule, this.flags);\n    expression = `${this.instance}`;\n    traverseAllows = this.instance.test.bind(this.instance);\n    compiledCondition = `${this.expression}.test(data)`;\n    compiledNegation = `!${this.compiledCondition}`;\n    impliedBasis = $ark.intrinsic.string;\n}\n", "var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { cached, includes, omit, printable, throwParseError } from \"@ark/util\";\nimport { throwInvalidOperandError } from \"../constraint.js\";\nimport { BaseNode, appendUniqueFlatRefs } from \"../node.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { ArkErrors } from \"../shared/errors.js\";\nimport { structuralKinds } from \"../shared/implement.js\";\nimport { intersectNodesRoot, pipeNodesRoot } from \"../shared/intersections.js\";\nimport { arkKind, hasArkKind } from \"../shared/utils.js\";\nlet BaseRoot = (() => {\n    let _classSuper = BaseNode;\n    let _instanceExtraInitializers = [];\n    let _keyof_decorators;\n    let _get_flatMorphs_decorators;\n    return class BaseRoot extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _keyof_decorators = [cached];\n            _get_flatMorphs_decorators = [cached];\n            __esDecorate(this, null, _keyof_decorators, { kind: \"method\", name: \"keyof\", static: false, private: false, access: { has: obj => \"keyof\" in obj, get: obj => obj.keyof }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _get_flatMorphs_decorators, { kind: \"getter\", name: \"flatMorphs\", static: false, private: false, access: { has: obj => \"flatMorphs\" in obj, get: obj => obj.flatMorphs }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        branches = (__runInitializers(this, _instanceExtraInitializers), this.hasKind(\"union\") ? this.inner.branches : [this]);\n        [arkKind] = \"root\";\n        get internal() {\n            return this;\n        }\n        keyof() {\n            const result = this.rawKeyOf();\n            if (result.branches.length === 0) {\n                throwParseError(`keyof ${this.expression} results in an unsatisfiable type`);\n            }\n            return result;\n        }\n        intersect(r) {\n            const rNode = this.$.parseRoot(r);\n            return intersectNodesRoot(this, rNode, this.$);\n        }\n        and(r) {\n            const result = this.intersect(r);\n            return result instanceof Disjoint ? result.throw() : result;\n        }\n        or(r) {\n            const rNode = this.$.parseRoot(r);\n            const branches = [...this.branches, ...rNode.branches];\n            return this.$.schema(branches);\n        }\n        assert(data) {\n            const result = this.traverse(data);\n            return result instanceof ArkErrors ? result.throw() : result;\n        }\n        get(...[key, ...tail]) {\n            if (key === undefined)\n                return this;\n            if (hasArkKind(key, \"root\") && key.hasKind(\"unit\"))\n                key = key.unit;\n            if (typeof key === \"number\")\n                key = `${key}`;\n            if (this.hasKind(\"union\")) {\n                return this.branches.reduce((acc, b) => acc.or(b.get(key, ...tail)), $ark.intrinsic.never);\n            }\n            return (this.structure?.get(key, ...tail) ??\n                throwParseError(writeNonStructuralIndexAccessMessage(key)));\n        }\n        extract(r) {\n            const rNode = this.$.parseRoot(r);\n            return this.$.schema(this.branches.filter(branch => branch.extends(rNode)));\n        }\n        exclude(r) {\n            const rNode = this.$.parseRoot(r);\n            return this.$.schema(this.branches.filter(branch => !branch.extends(rNode)));\n        }\n        array() {\n            return this.$.schema({\n                proto: Array,\n                sequence: this\n            }, { prereduced: true });\n        }\n        overlaps(r) {\n            const intersection = this.intersect(r);\n            return !(intersection instanceof Disjoint);\n        }\n        extends(r) {\n            const intersection = this.intersect(r);\n            return (!(intersection instanceof Disjoint) && this.equals(intersection));\n        }\n        subsumes(r) {\n            return r.extends(this);\n        }\n        includes(r) {\n            return hasArkKind(r, \"root\") ? r.extends(this) : this.allows(r);\n        }\n        configure(configOrDescription) {\n            return this.configureShallowDescendants(configOrDescription);\n        }\n        describe(description) {\n            return this.configure(description);\n        }\n        from(input) {\n            // ideally we wouldn't validate here but for now we need to do determine\n            // which morphs to apply\n            return this.assert(input);\n        }\n        pipe(...morphs) {\n            return morphs.reduce((acc, morph) => acc.pipeOnce(morph), this);\n        }\n        pipeOnce(morph) {\n            if (hasArkKind(morph, \"root\")) {\n                const result = pipeNodesRoot(this, morph, this.$);\n                if (result instanceof Disjoint)\n                    return result.throw();\n                return result;\n            }\n            if (this.hasKind(\"union\")) {\n                const branches = this.branches.map(node => node.pipe(morph));\n                return this.$.node(\"union\", { ...this.inner, branches });\n            }\n            if (this.hasKind(\"morph\")) {\n                return this.$.node(\"morph\", {\n                    ...this.inner,\n                    morphs: [...this.morphs, morph]\n                });\n            }\n            return this.$.node(\"morph\", {\n                in: this,\n                morphs: [morph]\n            });\n        }\n        get flatMorphs() {\n            return this.flatRefs.reduce((branches, ref) => appendUniqueFlatRefs(branches, ref.node.hasKind(\"union\") ?\n                ref.node.branches\n                    .filter(b => b.hasKind(\"morph\"))\n                    .map(branch => ({\n                    path: ref.path,\n                    propString: ref.propString,\n                    node: branch\n                }))\n                : ref.node.hasKind(\"morph\") ? ref\n                    : []), []);\n        }\n        narrow(predicate) {\n            return this.constrainOut(\"predicate\", predicate);\n        }\n        constrain(kind, schema) {\n            return this._constrain(\"in\", kind, schema);\n        }\n        constrainOut(kind, schema) {\n            return this._constrain(\"out\", kind, schema);\n        }\n        _constrain(io, kind, schema) {\n            const constraint = this.$.node(kind, schema);\n            if (constraint.impliedBasis && !this[io].extends(constraint.impliedBasis)) {\n                return throwInvalidOperandError(kind, constraint.impliedBasis, this);\n            }\n            const partialIntersection = this.$.node(\"intersection\", {\n                [kind]: constraint\n            });\n            const result = io === \"in\" ?\n                intersectNodesRoot(this, partialIntersection, this.$)\n                : pipeNodesRoot(this, partialIntersection, this.$);\n            if (result instanceof Disjoint)\n                result.throw();\n            return result;\n        }\n        onUndeclaredKey(cfg) {\n            const rule = typeof cfg === \"string\" ? cfg : cfg.rule;\n            const deep = typeof cfg === \"string\" ? false : cfg.deep;\n            return this.transform((kind, inner) => kind === \"structure\" ?\n                rule === \"ignore\" ?\n                    omit(inner, { undeclared: 1 })\n                    : { ...inner, undeclared: rule }\n                : inner, deep ? undefined : ({ shouldTransform: node => !includes(structuralKinds, node.kind) }));\n        }\n        satisfying(predicate) {\n            return this.constrain(\"predicate\", predicate);\n        }\n        divisibleBy(schema) {\n            return this.constrain(\"divisor\", schema);\n        }\n        matching(schema) {\n            return this.constrain(\"pattern\", schema);\n        }\n        atLeast(schema) {\n            return this.constrain(\"min\", schema);\n        }\n        atMost(schema) {\n            return this.constrain(\"max\", schema);\n        }\n        moreThan(schema) {\n            return this.constrain(\"min\", exclusivizeRangeSchema(schema));\n        }\n        lessThan(schema) {\n            return this.constrain(\"max\", exclusivizeRangeSchema(schema));\n        }\n        atLeastLength(schema) {\n            return this.constrain(\"minLength\", schema);\n        }\n        atMostLength(schema) {\n            return this.constrain(\"maxLength\", schema);\n        }\n        moreThanLength(schema) {\n            return this.constrain(\"minLength\", exclusivizeRangeSchema(schema));\n        }\n        lessThanLength(schema) {\n            return this.constrain(\"maxLength\", exclusivizeRangeSchema(schema));\n        }\n        exactlyLength(schema) {\n            return this.constrain(\"exactLength\", schema);\n        }\n        atOrAfter(schema) {\n            return this.constrain(\"after\", schema);\n        }\n        atOrBefore(schema) {\n            return this.constrain(\"before\", schema);\n        }\n        laterThan(schema) {\n            return this.constrain(\"after\", exclusivizeRangeSchema(schema));\n        }\n        earlierThan(schema) {\n            return this.constrain(\"before\", exclusivizeRangeSchema(schema));\n        }\n    };\n})();\nexport { BaseRoot };\nexport const exclusivizeRangeSchema = (schema) => (typeof schema === \"object\" && !(schema instanceof Date) ?\n    { ...schema, exclusive: true }\n    : {\n        rule: schema,\n        exclusive: true\n    });\nexport const writeNonStructuralIndexAccessMessage = (key) => `${printable(key)} cannot be accessed on ${this}, which has no structural keys`;\n", "import { flatMorph } from \"@ark/util\";\nimport { schemaKindsRightOf } from \"../shared/implement.js\";\nexport const defineRightwardIntersections = (kind, implementation) => flatMorph(schemaKindsRightOf(kind), (i, kind) => [\n    kind,\n    implementation\n]);\n", "var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { append, cached, domainDescriptions } from \"@ark/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nlet AliasNode = (() => {\n    let _classSuper = BaseRoot;\n    let _instanceExtraInitializers = [];\n    let _get_resolution_decorators;\n    return class AliasNode extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _get_resolution_decorators = [cached];\n            __esDecorate(this, null, _get_resolution_decorators, { kind: \"getter\", name: \"resolution\", static: false, private: false, access: { has: obj => \"resolution\" in obj, get: obj => obj.resolution }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        expression = (__runInitializers(this, _instanceExtraInitializers), this.alias);\n        structure = undefined;\n        get resolution() {\n            return this.resolve?.() ?? this.$.resolveRoot(this.alias);\n        }\n        rawKeyOf() {\n            return this.resolution.keyof();\n        }\n        get shortDescription() {\n            return domainDescriptions.object;\n        }\n        traverseAllows = (data, ctx) => {\n            const seen = ctx.seen[this.id];\n            if (seen?.includes(data))\n                return true;\n            ctx.seen[this.id] = append(seen, data);\n            return this.resolution.traverseAllows(data, ctx);\n        };\n        traverseApply = (data, ctx) => {\n            const seen = ctx.seen[this.id];\n            if (seen?.includes(data))\n                return;\n            ctx.seen[this.id] = append(seen, data);\n            this.resolution.traverseApply(data, ctx);\n        };\n        compile(js) {\n            js.if(`ctx.seen.${this.id}?.includes(data)`, () => js.return(true));\n            js.line(`ctx.seen.${this.id} ??= []`).line(`ctx.seen.${this.id}.push(data)`);\n            js.return(js.invoke(this.resolution));\n        }\n    };\n})();\nexport { AliasNode };\nexport const normalizeAliasSchema = (schema) => typeof schema === \"string\" ? { alias: schema.slice(1) } : schema;\nexport const aliasImplementation = implementNode({\n    kind: \"alias\",\n    hasAssociatedError: false,\n    collapsibleKey: \"alias\",\n    keys: {\n        alias: {\n            serialize: schema => `$${schema}`\n        },\n        resolve: {}\n    },\n    normalize: normalizeAliasSchema,\n    defaults: {\n        description: node => node.alias\n    },\n    intersections: {\n        alias: (l, r, ctx) => ctx.$.lazilyResolve(() => neverIfDisjoint(intersectNodes(l.resolution, r.resolution, ctx)), `${l.alias}${ctx.pipe ? \"|>\" : \"&\"}${r.alias}`),\n        ...defineRightwardIntersections(\"alias\", (l, r, ctx) => ctx.$.lazilyResolve(() => neverIfDisjoint(intersectNodes(l.resolution, r, ctx)), `${l.alias}${ctx.pipe ? \"|>\" : \"&\"}${r.alias}`))\n    }\n});\nconst neverIfDisjoint = (result) => result instanceof Disjoint ? $ark.intrinsic.never : result;\n", "import { compileErrorContext } from \"../shared/implement.js\";\nimport { BaseRoot } from \"./root.js\";\nexport class RawBasis extends BaseRoot {\n    rawKeyOf() {\n        return this.$.units(this.literalKeys);\n    }\n    traverseApply = (data, ctx) => {\n        if (!this.traverseAllows(data, ctx))\n            ctx.error(this.errorContext);\n    };\n    get errorContext() {\n        return { code: this.kind, description: this.description, ...this.inner };\n    }\n    get compiledErrorContext() {\n        return compileErrorContext(this.errorContext);\n    }\n    compile(js) {\n        if (js.traversalKind === \"Allows\")\n            js.return(this.compiledCondition);\n        else {\n            js.if(this.compiledNegation, () => js.line(`${js.ctx}.error(${this.compiledErrorContext})`));\n        }\n    }\n}\n", "import { domainDescriptions, domainOf, getBaseDomainKeys } from \"@ark/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { RawBasis } from \"./basis.js\";\nexport class DomainNode extends RawBasis {\n    traverseAllows = data => domainOf(data) === this.domain;\n    compiledCondition = this.domain === \"object\" ?\n        `((typeof data === \"object\" && data !== null) || typeof data === \"function\")`\n        : `typeof data === \"${this.domain}\"`;\n    compiledNegation = this.domain === \"object\" ?\n        `((typeof data !== \"object\" || data === null) && typeof data !== \"function\")`\n        : `typeof data !== \"${this.domain}\"`;\n    expression = this.domain;\n    literalKeys = getBaseDomainKeys(this.domain);\n    get shortDescription() {\n        return domainDescriptions[this.domain];\n    }\n}\nexport const domainImplementation = implementNode({\n    kind: \"domain\",\n    hasAssociatedError: true,\n    collapsibleKey: \"domain\",\n    keys: {\n        domain: {}\n    },\n    normalize: schema => typeof schema === \"string\" ? { domain: schema } : schema,\n    defaults: {\n        description: node => domainDescriptions[node.domain],\n        actual: data => (typeof data === \"boolean\" ? `${data}` : domainOf(data))\n    },\n    intersections: {\n        domain: (l, r) => Disjoint.init(\"domain\", l, r)\n    }\n});\n", "export const metaKeys = { description: 1 };\n", "import { flatMorph, hasDomain, isEmptyObject, isKeyOf, omit, pick, throwParseError } from \"@ark/util\";\nimport { constraintKeyParser, flattenConstraints, intersectConstraints } from \"../constraint.js\";\nimport { metaKeys } from \"../shared/declare.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode, structureKeys } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nimport { hasArkKind, isNode } from \"../shared/utils.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nexport class IntersectionNode extends BaseRoot {\n    basis = this.domain ?? this.proto ?? null;\n    refinements = this.children.filter(node => node.isRefinement());\n    expression = this.structure?.expression ||\n        `${this.basis ? this.basis.nestableExpression + \" \" : \"\"}${this.refinements.join(\" & \")}` ||\n        \"unknown\";\n    get shortDescription() {\n        return this.basis?.shortDescription ?? \"present\";\n    }\n    traverseAllows = (data, ctx) => this.children.every(child => child.traverseAllows(data, ctx));\n    traverseApply = (data, ctx) => {\n        const errorCount = ctx.currentErrorCount;\n        if (this.basis) {\n            this.basis.traverseApply(data, ctx);\n            if (ctx.currentErrorCount > errorCount)\n                return;\n        }\n        if (this.refinements.length) {\n            for (let i = 0; i < this.refinements.length - 1; i++) {\n                this.refinements[i].traverseApply(data, ctx);\n                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                    return;\n            }\n            this.refinements.at(-1).traverseApply(data, ctx);\n            if (ctx.currentErrorCount > errorCount)\n                return;\n        }\n        if (this.structure) {\n            this.structure.traverseApply(data, ctx);\n            if (ctx.currentErrorCount > errorCount)\n                return;\n        }\n        if (this.predicate) {\n            for (let i = 0; i < this.predicate.length - 1; i++) {\n                this.predicate[i].traverseApply(data, ctx);\n                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                    return;\n            }\n            this.predicate.at(-1).traverseApply(data, ctx);\n        }\n    };\n    compile(js) {\n        if (js.traversalKind === \"Allows\") {\n            this.children.forEach(child => js.check(child));\n            js.return(true);\n            return;\n        }\n        js.initializeErrorCount();\n        if (this.basis) {\n            js.check(this.basis);\n            // we only have to return conditionally if this is not the last check\n            if (this.children.length > 1)\n                js.returnIfFail();\n        }\n        if (this.refinements.length) {\n            for (let i = 0; i < this.refinements.length - 1; i++) {\n                js.check(this.refinements[i]);\n                js.returnIfFailFast();\n            }\n            js.check(this.refinements.at(-1));\n            if (this.structure || this.predicate)\n                js.returnIfFail();\n        }\n        if (this.structure) {\n            js.check(this.structure);\n            if (this.predicate)\n                js.returnIfFail();\n        }\n        if (this.predicate) {\n            for (let i = 0; i < this.predicate.length - 1; i++) {\n                js.check(this.predicate[i]);\n                // since predicates can be chained, we have to fail immediately\n                // if one fails\n                js.returnIfFail();\n            }\n            js.check(this.predicate.at(-1));\n        }\n    }\n    rawKeyOf() {\n        return (this.basis ?\n            this.structure ?\n                this.basis.rawKeyOf().or(this.structure.keyof())\n                : this.basis.rawKeyOf()\n            : this.structure?.keyof() ?? $ark.intrinsic.never);\n    }\n}\nconst intersectIntersections = (l, r, ctx) => {\n    // avoid treating adding instance keys as keys of lRoot, rRoot\n    if (hasArkKind(l, \"root\") && l.hasKind(\"intersection\"))\n        return intersectIntersections(l.inner, r, ctx);\n    if (hasArkKind(r, \"root\") && r.hasKind(\"intersection\"))\n        return intersectIntersections(l, r.inner, ctx);\n    const baseInner = isEmptyObject(l) ? pick(r, metaKeys) : {};\n    const lBasis = l.proto ?? l.domain;\n    const rBasis = r.proto ?? r.domain;\n    const basisResult = lBasis ?\n        rBasis ?\n            intersectNodes(lBasis, rBasis, ctx)\n            : lBasis\n        : rBasis;\n    if (basisResult instanceof Disjoint)\n        return basisResult;\n    if (basisResult)\n        baseInner[basisResult.kind] = basisResult;\n    return intersectConstraints({\n        kind: \"intersection\",\n        baseInner,\n        l: flattenConstraints(l),\n        r: flattenConstraints(r),\n        roots: [],\n        ctx\n    });\n};\nexport const intersectionImplementation = implementNode({\n    kind: \"intersection\",\n    hasAssociatedError: true,\n    normalize: rawSchema => {\n        if (isNode(rawSchema))\n            return rawSchema;\n        const { structure, ...schema } = rawSchema;\n        const hasRootStructureKey = !!structure;\n        const normalizedStructure = structure ?? {};\n        const normalized = flatMorph(schema, (k, v) => {\n            if (isKeyOf(k, structureKeys)) {\n                if (hasRootStructureKey) {\n                    throwParseError(`Flattened structure key ${k} cannot be specified alongside a root 'structure' key.`);\n                }\n                normalizedStructure[k] = v;\n                return [];\n            }\n            return [k, v];\n        });\n        if (hasArkKind(normalizedStructure, \"constraint\") ||\n            !isEmptyObject(normalizedStructure))\n            normalized.structure = normalizedStructure;\n        return normalized;\n    },\n    finalizeJson: ({ structure, ...rest }) => hasDomain(structure, \"object\") ? { ...structure, ...rest } : rest,\n    keys: {\n        domain: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(\"domain\", schema)\n        },\n        proto: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(\"proto\", schema)\n        },\n        structure: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(\"structure\", schema),\n            serialize: node => {\n                if (!node.sequence?.minLength)\n                    return node.collapsibleJson;\n                const { sequence, ...structureJson } = node.collapsibleJson;\n                const { minVariadicLength, ...sequenceJson } = sequence;\n                const collapsibleSequenceJson = sequenceJson.variadic && Object.keys(sequenceJson).length === 1 ?\n                    sequenceJson.variadic\n                    : sequenceJson;\n                return { ...structureJson, sequence: collapsibleSequenceJson };\n            }\n        },\n        divisor: {\n            child: true,\n            parse: constraintKeyParser(\"divisor\")\n        },\n        max: {\n            child: true,\n            parse: constraintKeyParser(\"max\")\n        },\n        min: {\n            child: true,\n            parse: constraintKeyParser(\"min\")\n        },\n        maxLength: {\n            child: true,\n            parse: constraintKeyParser(\"maxLength\")\n        },\n        minLength: {\n            child: true,\n            parse: constraintKeyParser(\"minLength\")\n        },\n        exactLength: {\n            child: true,\n            parse: constraintKeyParser(\"exactLength\")\n        },\n        before: {\n            child: true,\n            parse: constraintKeyParser(\"before\")\n        },\n        after: {\n            child: true,\n            parse: constraintKeyParser(\"after\")\n        },\n        pattern: {\n            child: true,\n            parse: constraintKeyParser(\"pattern\")\n        },\n        predicate: {\n            child: true,\n            parse: constraintKeyParser(\"predicate\")\n        }\n    },\n    // leverage reduction logic from intersection and identity to ensure initial\n    // parse result is reduced\n    reduce: (inner, $) => \n    // we cast union out of the result here since that only occurs when intersecting two sequences\n    // that cannot occur when reducing a single intersection schema using unknown\n    intersectIntersections({}, inner, {\n        $,\n        invert: false,\n        pipe: false\n    }),\n    defaults: {\n        description: node => node.children.length === 0 ?\n            \"unknown\"\n            : node.structure?.description ??\n                node.children.map(child => child.description).join(\" and \"),\n        expected: source => `  • ${source.errors.map(e => e.expected).join(\"\\n  • \")}`,\n        problem: ctx => `(${ctx.actual}) must be...\\n${ctx.expected}`\n    },\n    intersections: {\n        intersection: (l, r, ctx) => intersectIntersections(l, r, ctx),\n        ...defineRightwardIntersections(\"intersection\", (l, r, ctx) => {\n            // if l is unknown, return r\n            if (l.children.length === 0)\n                return r;\n            const basis = l.basis ? intersectNodes(l.basis, r, ctx) : r;\n            return (basis instanceof Disjoint ? basis\n                : l?.basis?.equals(basis) ?\n                    // if the basis doesn't change, return the original intesection\n                    l\n                    // given we've already precluded l being unknown, the result must\n                    // be an intersection with the new basis result integrated\n                    : l.$.node(\"intersection\", Object.assign(omit(l.inner, metaKeys), {\n                        [basis.kind]: basis\n                    }), { prereduced: true }));\n        })\n    }\n});\n", "import { arrayEquals, arrayFrom, registeredReference, throwParseError } from \"@ark/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nimport { hasArkKind } from \"../shared/utils.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nconst morphChildKinds = [\n    \"alias\",\n    \"intersection\",\n    \"unit\",\n    \"domain\",\n    \"proto\"\n];\nexport const morphImplementation = implementNode({\n    kind: \"morph\",\n    hasAssociatedError: false,\n    keys: {\n        in: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(morphChildKinds, schema)\n        },\n        morphs: {\n            parse: arrayFrom,\n            serialize: morphs => morphs.map(m => hasArkKind(m, \"root\") ? m.json : registeredReference(m))\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `a morph from ${node.in.description} to ${node.out?.description ?? \"unknown\"}`\n    },\n    intersections: {\n        morph: (l, r, ctx) => {\n            if (!l.hasEqualMorphs(r)) {\n                return throwParseError(writeMorphIntersectionMessage(l.expression, r.expression));\n            }\n            const inTersection = intersectNodes(l.in, r.in, ctx);\n            if (inTersection instanceof Disjoint)\n                return inTersection;\n            // in case from is a union, we need to distribute the branches\n            // to can be a union as any schema is allowed\n            return ctx.$.schema(inTersection.branches.map(inBranch => ctx.$.node(\"morph\", {\n                morphs: l.morphs,\n                in: inBranch\n            })));\n        },\n        ...defineRightwardIntersections(\"morph\", (l, r, ctx) => {\n            const inTersection = intersectNodes(l.in, r, ctx);\n            return (inTersection instanceof Disjoint ? inTersection\n                : inTersection.kind === \"union\" ?\n                    ctx.$.node(\"union\", inTersection.branches.map(branch => ({\n                        ...l.inner,\n                        in: branch\n                    })))\n                    : ctx.$.node(\"morph\", {\n                        ...l.inner,\n                        in: inTersection\n                    }));\n        })\n    }\n});\nexport class MorphNode extends BaseRoot {\n    serializedMorphs = this.morphs.map(registeredReference);\n    compiledMorphs = `[${this.serializedMorphs}]`;\n    structure = this.in.structure;\n    traverseAllows = (data, ctx) => this.in.traverseAllows(data, ctx);\n    traverseApply = (data, ctx) => {\n        this.in.traverseApply(data, ctx);\n        ctx.queueMorphs(this.morphs);\n    };\n    expression = `(In: ${this.in.expression}) => Out<${this.out?.expression ?? \"unknown\"}>`;\n    get shortDescription() {\n        return this.in.shortDescription;\n    }\n    compile(js) {\n        if (js.traversalKind === \"Allows\") {\n            js.return(js.invoke(this.in));\n            return;\n        }\n        js.line(js.invoke(this.in));\n        js.line(`ctx.queueMorphs(${this.compiledMorphs})`);\n    }\n    get in() {\n        return this.inner.in;\n    }\n    get out() {\n        return this.validatedOut ?? $ark.intrinsic.unknown;\n    }\n    /** Check if the morphs of r are equal to those of this node */\n    hasEqualMorphs(r) {\n        return arrayEquals(this.morphs, r.morphs, {\n            isEqual: (lMorph, rMorph) => lMorph === rMorph ||\n                (hasArkKind(lMorph, \"root\") &&\n                    hasArkKind(rMorph, \"root\") &&\n                    lMorph.equals(rMorph))\n        });\n    }\n    lastMorph = this.inner.morphs.at(-1);\n    validatedOut = hasArkKind(this.lastMorph, \"root\") ?\n        Object.assign(this.referencesById, this.lastMorph.out.referencesById) &&\n            this.lastMorph.out\n        : undefined;\n    rawKeyOf() {\n        return this.in.rawKeyOf();\n    }\n}\nexport const writeMorphIntersectionMessage = (lDescription, rDescription) => `The intersection of distinct morphs at a single path is indeterminate:\nLeft: ${lDescription}\nRight: ${rDescription}`;\n", "import { builtinConstructors, constructorExtends, getExactBuiltinConstructorName, objectKindDescriptions, objectKindOrDomainOf, prototypeKeysOf } from \"@ark/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { defaultValueSerializer, implementNode } from \"../shared/implement.js\";\nimport { RawBasis } from \"./basis.js\";\nexport const protoImplementation = implementNode({\n    kind: \"proto\",\n    hasAssociatedError: true,\n    collapsibleKey: \"proto\",\n    keys: {\n        proto: {\n            serialize: ctor => getExactBuiltinConstructorName(ctor) ?? defaultValueSerializer(ctor)\n        }\n    },\n    normalize: schema => typeof schema === \"string\" ? { proto: builtinConstructors[schema] }\n        : typeof schema === \"function\" ? { proto: schema }\n            : typeof schema.proto === \"string\" ?\n                { ...schema, proto: builtinConstructors[schema.proto] }\n                : schema,\n    defaults: {\n        description: node => node.builtinName ?\n            objectKindDescriptions[node.builtinName]\n            : `an instance of ${node.proto.name}`,\n        actual: data => objectKindOrDomainOf(data)\n    },\n    intersections: {\n        proto: (l, r) => constructorExtends(l.proto, r.proto) ? l\n            : constructorExtends(r.proto, l.proto) ? r\n                : Disjoint.init(\"proto\", l, r),\n        domain: (proto, domain) => domain.domain === \"object\" ?\n            proto\n            : Disjoint.init(\"domain\", $ark.intrinsic.object.internal, domain)\n    }\n});\nexport class ProtoNode extends RawBasis {\n    builtinName = getExactBuiltinConstructorName(this.proto);\n    serializedConstructor = this.json.proto;\n    compiledCondition = `data instanceof ${this.serializedConstructor}`;\n    compiledNegation = `!(${this.compiledCondition})`;\n    literalKeys = prototypeKeysOf(this.proto.prototype);\n    traverseAllows = data => data instanceof this.proto;\n    expression = this.proto.name;\n    domain = \"object\";\n    get shortDescription() {\n        return this.description;\n    }\n}\n", "var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { appendUnique, arrayEquals, cached, compileLiteralPropAccess, compileSerializedValue, domainDescriptions, flatMorph, groupBy, isArray, isKeyOf, printable, registeredReference, throwInternalError, throwParseError } from \"@ark/util\";\nimport { typePathToPropString } from \"../node.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode, schemaKindsRightOf } from \"../shared/implement.js\";\nimport { intersectNodes, intersectNodesRoot } from \"../shared/intersections.js\";\nimport { pathToPropString } from \"../shared/utils.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nconst unionChildKinds = [\n    ...schemaKindsRightOf(\"union\"),\n    \"alias\"\n];\nexport const unionImplementation = implementNode({\n    kind: \"union\",\n    hasAssociatedError: true,\n    collapsibleKey: \"branches\",\n    keys: {\n        ordered: {},\n        branches: {\n            child: true,\n            parse: (schema, ctx) => {\n                const branches = schema.map(branch => ctx.$.node(unionChildKinds, branch));\n                if (!ctx.schema.ordered)\n                    branches.sort((l, r) => (l.innerHash < r.innerHash ? -1 : 1));\n                return branches;\n            }\n        }\n    },\n    normalize: schema => (isArray(schema) ? { branches: schema } : schema),\n    reduce: (inner, $) => {\n        const reducedBranches = reduceBranches(inner);\n        if (reducedBranches.length === 1)\n            return reducedBranches[0];\n        if (reducedBranches.length === inner.branches.length)\n            return;\n        return $.node(\"union\", {\n            ...inner,\n            branches: reducedBranches\n        }, { prereduced: true });\n    },\n    defaults: {\n        description: node => describeBranches(node.branches.map(branch => branch.description)),\n        expected: ctx => {\n            const byPath = groupBy(ctx.errors, \"propString\");\n            const pathDescriptions = Object.entries(byPath).map(([path, errors]) => {\n                const branchesAtPath = [];\n                errors.forEach(errorAtPath => \n                // avoid duplicate messages when multiple branches\n                // are invalid due to the same error\n                appendUnique(branchesAtPath, errorAtPath.expected));\n                const expected = describeBranches(branchesAtPath);\n                // if there are multiple actual descriptions that differ,\n                // just fall back to printable, which is the most specific\n                const actual = errors.every(e => e.actual === errors[0].actual) ?\n                    errors[0].actual\n                    : printable(errors[0].data);\n                return `${path && `${path} `}must be ${expected}${actual && ` (was ${actual})`}`;\n            });\n            return describeBranches(pathDescriptions);\n        },\n        problem: ctx => ctx.expected,\n        message: ctx => ctx.problem\n    },\n    intersections: {\n        union: (l, r, ctx) => {\n            if (l.isNever !== r.isNever) {\n                // if exactly one operand is never, we can use it to discriminate based on presence\n                return Disjoint.init(\"presence\", l, r);\n            }\n            let resultBranches;\n            if (l.ordered) {\n                if (r.ordered) {\n                    throwParseError(writeOrderedIntersectionMessage(l.expression, r.expression));\n                }\n                resultBranches = intersectBranches(r.branches, l.branches, ctx);\n                if (resultBranches instanceof Disjoint)\n                    resultBranches.invert();\n            }\n            else\n                resultBranches = intersectBranches(l.branches, r.branches, ctx);\n            if (resultBranches instanceof Disjoint)\n                return resultBranches;\n            return ctx.$.schema(l.ordered || r.ordered ?\n                {\n                    branches: resultBranches,\n                    ordered: true\n                }\n                : { branches: resultBranches });\n        },\n        ...defineRightwardIntersections(\"union\", (l, r, ctx) => {\n            const branches = intersectBranches(l.branches, [r], ctx);\n            if (branches instanceof Disjoint)\n                return branches;\n            if (branches.length === 1)\n                return branches[0];\n            return ctx.$.schema(l.ordered ? { branches, ordered: true } : { branches });\n        })\n    }\n});\nlet UnionNode = (() => {\n    let _classSuper = BaseRoot;\n    let _instanceExtraInitializers = [];\n    let _discriminate_decorators;\n    return class UnionNode extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _discriminate_decorators = [cached];\n            __esDecorate(this, null, _discriminate_decorators, { kind: \"method\", name: \"discriminate\", static: false, private: false, access: { has: obj => \"discriminate\" in obj, get: obj => obj.discriminate }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        isNever = (__runInitializers(this, _instanceExtraInitializers), this.branches.length === 0);\n        isBoolean = this.branches.length === 2 &&\n            this.branches[0].hasUnit(false) &&\n            this.branches[1].hasUnit(true);\n        unitBranches = this.branches.filter((n) => n.in.hasKind(\"unit\"));\n        discriminant = this.discriminate();\n        discriminantJson = this.discriminant ? discriminantToJson(this.discriminant) : null;\n        expression = expressBranches(this.branches.map(n => n.nestableExpression));\n        get shortDescription() {\n            return describeBranches(this.branches.map(branch => branch.shortDescription));\n        }\n        traverseAllows = (data, ctx) => this.branches.some(b => b.traverseAllows(data, ctx));\n        traverseApply = (data, ctx) => {\n            const errors = [];\n            for (let i = 0; i < this.branches.length; i++) {\n                ctx.pushBranch();\n                this.branches[i].traverseApply(data, ctx);\n                if (!ctx.hasError())\n                    return ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs);\n                errors.push(ctx.popBranch().error);\n            }\n            ctx.error({ code: \"union\", errors });\n        };\n        compile(js) {\n            if (!this.discriminant ||\n                // if we have a union of two units like `boolean`, the\n                // undiscriminated compilation will be just as fast\n                (this.unitBranches.length === this.branches.length &&\n                    this.branches.length === 2))\n                return this.compileIndiscriminable(js);\n            // we need to access the path as optional so we don't throw if it isn't present\n            const condition = this.discriminant.path.reduce((acc, k) => acc + compileLiteralPropAccess(k, true), this.discriminant.kind === \"domain\" ? \"typeof data\" : \"data\");\n            const cases = this.discriminant.cases;\n            const caseKeys = Object.keys(cases);\n            js.block(`switch(${condition})`, () => {\n                for (const k in cases) {\n                    const v = cases[k];\n                    const caseCondition = k === \"default\" ? k : `case ${k}`;\n                    js.line(`${caseCondition}: return ${v === true ? v : js.invoke(v)}`);\n                }\n                return js;\n            });\n            if (js.traversalKind === \"Allows\") {\n                js.return(false);\n                return;\n            }\n            const expected = describeBranches(this.discriminant.kind === \"domain\" ?\n                caseKeys.map(k => domainDescriptions[k.slice(1, -1)])\n                : caseKeys);\n            const serializedPathSegments = this.discriminant.path.map(k => typeof k === \"string\" ? JSON.stringify(k) : registeredReference(k));\n            js.line(`ctx.error({\n\texpected: ${JSON.stringify(expected)},\n\tactual: ${condition},\n\trelativePath: [${serializedPathSegments}]\n})`);\n        }\n        compileIndiscriminable(js) {\n            if (js.traversalKind === \"Apply\") {\n                js.const(\"errors\", \"[]\");\n                this.branches.forEach(branch => js\n                    .line(\"ctx.pushBranch()\")\n                    .line(js.invoke(branch))\n                    .if(\"!ctx.hasError()\", () => js.return(\"ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs)\"))\n                    .line(\"errors.push(ctx.popBranch().error)\"));\n                js.line(`ctx.error({ code: \"union\", errors })`);\n            }\n            else {\n                this.branches.forEach(branch => js.if(`${js.invoke(branch)}`, () => js.return(true)));\n                js.return(false);\n            }\n        }\n        rawKeyOf() {\n            return this.branches.reduce((result, branch) => result.and(branch.rawKeyOf()), $ark.intrinsic.unknown);\n        }\n        get nestableExpression() {\n            // avoid adding unnecessary parentheses around boolean since it's\n            // already collapsed to a single keyword\n            return this.isBoolean ? \"boolean\" : super.nestableExpression;\n        }\n        discriminate() {\n            if (this.branches.length < 2)\n                return null;\n            if (this.unitBranches.length === this.branches.length) {\n                const cases = flatMorph(this.unitBranches, (i, n) => [\n                    `${n.in.serializedValue}`,\n                    n.hasKind(\"morph\") ? n : true\n                ]);\n                return {\n                    kind: \"unit\",\n                    path: [],\n                    propString: \"\",\n                    cases\n                };\n            }\n            const candidates = [];\n            for (let lIndex = 0; lIndex < this.branches.length - 1; lIndex++) {\n                const l = this.branches[lIndex];\n                for (let rIndex = lIndex + 1; rIndex < this.branches.length; rIndex++) {\n                    const r = this.branches[rIndex];\n                    const result = intersectNodesRoot(l.in, r.in, l.$);\n                    if (!(result instanceof Disjoint))\n                        continue;\n                    for (const entry of result) {\n                        if (!isKeyOf(entry.kind, discriminantKinds) || entry.optional)\n                            continue;\n                        let lSerialized;\n                        let rSerialized;\n                        if (entry.kind === \"domain\") {\n                            lSerialized = `\"${entry.l.domain}\"`;\n                            rSerialized = `\"${entry.r.domain}\"`;\n                        }\n                        else if (entry.kind === \"unit\") {\n                            lSerialized = entry.l.serializedValue;\n                            rSerialized = entry.r.serializedValue;\n                        }\n                        else {\n                            return throwInternalError(`Unexpected attempt to discriminate disjoint kind '${entry.kind}'`);\n                        }\n                        const matching = candidates.find(d => arrayEquals(d.path, entry.path) && d.kind === entry.kind);\n                        if (!matching) {\n                            candidates.push({\n                                kind: entry.kind,\n                                cases: {\n                                    [lSerialized]: [l],\n                                    [rSerialized]: [r]\n                                },\n                                path: entry.path\n                            });\n                            continue;\n                        }\n                        matching.cases[lSerialized] = appendUnique(matching.cases[lSerialized], l);\n                        matching.cases[rSerialized] = appendUnique(matching.cases[rSerialized], r);\n                    }\n                }\n            }\n            const best = candidates\n                .sort((l, r) => Object.keys(l.cases).length - Object.keys(r.cases).length)\n                .at(-1);\n            if (!best)\n                return null;\n            let defaultBranches = [...this.branches];\n            const bestCtx = {\n                kind: best.kind,\n                path: best.path,\n                propString: pathToPropString(best.path)\n            };\n            const cases = flatMorph(best.cases, (k, caseBranches) => {\n                const prunedBranches = [];\n                defaultBranches = defaultBranches.filter(n => !caseBranches.includes(n));\n                for (const branch of caseBranches) {\n                    const pruned = pruneDiscriminant(branch, bestCtx);\n                    // if any branch of the union has no constraints (i.e. is unknown)\n                    // return it right away\n                    if (pruned === null)\n                        return [k, true];\n                    prunedBranches.push(pruned);\n                }\n                const caseNode = prunedBranches.length === 1 ?\n                    prunedBranches[0]\n                    : this.$.node(\"union\", prunedBranches);\n                Object.assign(this.referencesById, caseNode.referencesById);\n                return [k, caseNode];\n            });\n            if (defaultBranches.length) {\n                cases.default = this.$.node(\"union\", defaultBranches, {\n                    prereduced: true\n                });\n                Object.assign(this.referencesById, cases.default.referencesById);\n            }\n            return {\n                kind: best.kind,\n                path: best.path,\n                propString: pathToPropString(best.path),\n                cases\n            };\n        }\n    };\n})();\nexport { UnionNode };\nconst discriminantToJson = (discriminant) => ({\n    kind: discriminant.kind,\n    path: discriminant.path.map(k => typeof k === \"string\" ? k : compileSerializedValue(k)),\n    cases: flatMorph(discriminant.cases, (k, node) => [\n        k,\n        node === true ? node\n            : node.hasKind(\"union\") && node.discriminantJson ? node.discriminantJson\n                : node.json\n    ])\n});\nconst describeExpressionOptions = {\n    delimiter: \" | \",\n    finalDelimiter: \" | \"\n};\nconst expressBranches = (expressions) => describeBranches(expressions, describeExpressionOptions);\nconst describeBranches = (descriptions, opts) => {\n    const delimiter = opts?.delimiter ?? \", \";\n    const finalDelimiter = opts?.finalDelimiter ?? \" or \";\n    if (descriptions.length === 0)\n        return \"never\";\n    if (descriptions.length === 1)\n        return descriptions[0];\n    if ((descriptions.length === 2 &&\n        descriptions[0] === \"false\" &&\n        descriptions[1] === \"true\") ||\n        (descriptions[0] === \"true\" && descriptions[1] === \"false\"))\n        return \"boolean\";\n    let description = \"\";\n    // keep track of seen descriptions to avoid duplication\n    const seen = {};\n    for (let i = 0; i < descriptions.length - 1; i++) {\n        if (seen[descriptions[i]])\n            continue;\n        seen[descriptions[i]] = true;\n        description += descriptions[i];\n        if (i < descriptions.length - 2)\n            description += delimiter;\n    }\n    const lastDescription = descriptions.at(-1);\n    if (!seen[lastDescription])\n        description += `${finalDelimiter}${descriptions[descriptions.length - 1]}`;\n    return description;\n};\nexport const intersectBranches = (l, r, ctx) => {\n    // If the corresponding r branch is identified as a subtype of an l branch, the\n    // value at rIndex is set to null so we can avoid including previous/future\n    // inersections in the reduced result.\n    const batchesByR = r.map(() => []);\n    for (let lIndex = 0; lIndex < l.length; lIndex++) {\n        let candidatesByR = {};\n        for (let rIndex = 0; rIndex < r.length; rIndex++) {\n            if (batchesByR[rIndex] === null) {\n                // rBranch is a subtype of an lBranch and\n                // will not yield any distinct intersection\n                continue;\n            }\n            if (l[lIndex].equals(r[rIndex])) {\n                // Combination of subtype and supertype cases\n                batchesByR[rIndex] = null;\n                candidatesByR = {};\n                break;\n            }\n            const branchIntersection = intersectNodes(l[lIndex], r[rIndex], ctx);\n            if (branchIntersection instanceof Disjoint) {\n                // Doesn't tell us anything useful about their relationships\n                // with other branches\n                continue;\n            }\n            if (branchIntersection.equals(l[lIndex])) {\n                // If the current l branch is a subtype of r, intersections\n                // with previous and remaining branches of r won't lead to\n                // distinct intersections.\n                batchesByR[rIndex].push(l[lIndex]);\n                candidatesByR = {};\n                break;\n            }\n            if (branchIntersection.equals(r[rIndex])) {\n                // If the current r branch is a subtype of l, set its batch to\n                // null, removing any previous intersections and preventing any\n                // of its remaining intersections from being computed.\n                batchesByR[rIndex] = null;\n            }\n            else {\n                // If neither l nor r is a subtype of the other, add their\n                // intersection as a candidate (could still be removed if it is\n                // determined l or r is a subtype of a remaining branch).\n                candidatesByR[rIndex] = branchIntersection;\n            }\n        }\n        for (const rIndex in candidatesByR) {\n            // batchesByR at rIndex should never be null if it is in candidatesByR\n            batchesByR[rIndex][lIndex] = candidatesByR[rIndex];\n        }\n    }\n    // Compile the reduced intersection result, including:\n    // \t\t1. Remaining candidates resulting from distinct intersections or strict subtypes of r\n    // \t\t2. Original r branches corresponding to indices with a null batch (subtypes of l)\n    const resultBranches = batchesByR.flatMap(\n    // ensure unions returned from branchable intersections like sequence are flattened\n    (batch, i) => batch?.flatMap(branch => branch.branches) ?? r[i]);\n    return resultBranches.length === 0 ?\n        Disjoint.init(\"union\", l, r)\n        : resultBranches;\n};\nexport const reduceBranches = ({ branches, ordered }) => {\n    if (branches.length < 2)\n        return branches;\n    const uniquenessByIndex = branches.map(() => true);\n    for (let i = 0; i < branches.length; i++) {\n        for (let j = i + 1; j < branches.length && uniquenessByIndex[i] && uniquenessByIndex[j]; j++) {\n            if (branches[i].equals(branches[j])) {\n                // if the two branches are equal, only \"j\" is marked as\n                // redundant so at least one copy could still be included in\n                // the final set of branches.\n                uniquenessByIndex[j] = false;\n                continue;\n            }\n            const intersection = intersectNodesRoot(branches[i].in, branches[j].in, branches[0].$);\n            if (intersection instanceof Disjoint)\n                continue;\n            if (!ordered &&\n                (branches[i].includesMorph || branches[j].includesMorph) &&\n                (!arrayEquals(branches[i].shallowMorphs, branches[j].shallowMorphs, {\n                    isEqual: (l, r) => l.hasEqualMorphs(r)\n                }) ||\n                    !arrayEquals(branches[i].flatMorphs, branches[j].flatMorphs, {\n                        isEqual: (l, r) => l.propString === r.propString && l.node.hasEqualMorphs(r.node)\n                    }))) {\n                throwParseError(writeIndiscriminableMorphMessage(branches[i].expression, branches[j].expression));\n            }\n            if (intersection.equals(branches[i].in)) {\n                // preserve ordered branches that are a subtype of a subsequent branch\n                uniquenessByIndex[i] = !!ordered;\n            }\n            else if (intersection.equals(branches[j].in))\n                uniquenessByIndex[j] = false;\n        }\n    }\n    return branches.filter((_, i) => uniquenessByIndex[i]);\n};\nconst discriminantKinds = {\n    domain: 1,\n    unit: 1\n};\nexport const pruneDiscriminant = (discriminantBranch, discriminantCtx) => discriminantBranch.transform((nodeKind, inner, ctx) => {\n    // if we've already checked a path at least as long as the current one,\n    // we don't need to revalidate that we're in an object\n    if (nodeKind === \"domain\" &&\n        inner.domain === \"object\" &&\n        discriminantCtx.path.length >= ctx.path.length)\n        return null;\n    // if the discriminant has already checked the domain at the current path\n    // (or a unit literal, implying a domain), we don't need to recheck it\n    if ((nodeKind === \"domain\" || discriminantCtx.kind === \"unit\") &&\n        typePathToPropString(ctx.path) === discriminantCtx.propString)\n        return null;\n    return inner;\n}, {\n    shouldTransform: node => \n    // we don't need to recurse into index nodes as they will never\n    // have a required path therefore can't be used to discriminate\n    (node.children.length !== 0 && node.kind !== \"index\") ||\n        node.kind === \"domain\" ||\n        node.kind === \"unit\"\n});\nexport const writeIndiscriminableMorphMessage = (lDescription, rDescription) => `An unordered union of a type including a morph and a type with overlapping input is indeterminate:\nLeft: ${lDescription}\nRight: ${rDescription}`;\nexport const writeOrderedIntersectionMessage = (lDescription, rDescription) => `The intersection of two ordered unions is indeterminate:\nLeft: ${lDescription}\nRight: ${rDescription}`;\n", "import { domainDescriptions, domainOf, printable, prototypeKeysOf } from \"@ark/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { defaultValueSerializer, implementNode } from \"../shared/implement.js\";\nimport { RawBasis } from \"./basis.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nexport const unitImplementation = implementNode({\n    kind: \"unit\",\n    hasAssociatedError: true,\n    keys: {\n        unit: {\n            preserveUndefined: true,\n            serialize: schema => schema instanceof Date ?\n                schema.toISOString()\n                : defaultValueSerializer(schema)\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => printable(node.unit),\n        problem: ({ expected, actual }) => `${expected === actual ? `must be reference equal to ${expected} (serialized to the same value)` : `must be ${expected} (was ${actual})`}`\n    },\n    intersections: {\n        unit: (l, r) => Disjoint.init(\"unit\", l, r),\n        ...defineRightwardIntersections(\"unit\", (l, r) => r.allows(l.unit) ? l : (Disjoint.init(\"assignability\", l, r.hasKind(\"intersection\") ?\n            r.children.find(rConstraint => !rConstraint.allows(l.unit))\n            : r)))\n    }\n});\nexport class UnitNode extends RawBasis {\n    compiledValue = this.json.unit;\n    serializedValue = typeof this.unit === \"string\" || this.unit instanceof Date ?\n        JSON.stringify(this.compiledValue)\n        : this.compiledValue;\n    literalKeys = prototypeKeysOf(this.unit);\n    compiledCondition = compileEqualityCheck(this.unit, this.serializedValue);\n    compiledNegation = compileEqualityCheck(this.unit, this.serializedValue, \"negated\");\n    expression = printable(this.unit);\n    domain = domainOf(this.unit);\n    get shortDescription() {\n        return this.domain === \"object\" ?\n            domainDescriptions.object\n            : this.description;\n    }\n    traverseAllows = this.unit instanceof Date ?\n        data => data instanceof Date && data.toISOString() === this.compiledValue\n        : data => data === this.unit;\n}\nconst compileEqualityCheck = (unit, serializedValue, negated) => {\n    if (unit instanceof Date) {\n        const condition = `data instanceof Date && data.toISOString() === ${serializedValue}`;\n        return negated ? `!(${condition})` : condition;\n    }\n    return `data ${negated ? \"!\" : \"=\"}== ${serializedValue}`;\n};\n", "import { append, printable, stringAndSymbolicEntriesOf, throwParseError } from \"@ark/util\";\nimport { BaseConstraint } from \"../constraint.js\";\nimport { flatRef } from \"../node.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nexport const indexImplementation = implementNode({\n    kind: \"index\",\n    hasAssociatedError: false,\n    intersectionIsOpen: true,\n    keys: {\n        signature: {\n            child: true,\n            parse: (schema, ctx) => {\n                const key = ctx.$.schema(schema);\n                if (!key.extends($ark.intrinsic.propertyKey)) {\n                    return throwParseError(writeInvalidPropertyKeyMessage(key.expression));\n                }\n                const enumerableBranches = key.branches.filter(b => b.hasKind(\"unit\"));\n                if (enumerableBranches.length) {\n                    return throwParseError(writeEnumerableIndexBranches(enumerableBranches.map(b => printable(b.unit))));\n                }\n                return key;\n            }\n        },\n        value: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.schema(schema)\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `[${node.signature.expression}]: ${node.value.description}`\n    },\n    intersections: {\n        index: (l, r, ctx) => {\n            if (l.signature.equals(r.signature)) {\n                const valueIntersection = intersectNodes(l.value, r.value, ctx);\n                const value = valueIntersection instanceof Disjoint ?\n                    $ark.intrinsic.never.internal\n                    : valueIntersection;\n                return ctx.$.node(\"index\", { signature: l.signature, value });\n            }\n            // if r constrains all of l's keys to a subtype of l's value, r is a subtype of l\n            if (l.signature.extends(r.signature) && l.value.subsumes(r.value))\n                return r;\n            // if l constrains all of r's keys to a subtype of r's value, l is a subtype of r\n            if (r.signature.extends(l.signature) && r.value.subsumes(l.value))\n                return l;\n            // other relationships between index signatures can't be generally reduced\n            return null;\n        }\n    }\n});\nexport class IndexNode extends BaseConstraint {\n    impliedBasis = $ark.intrinsic.object;\n    expression = `[${this.signature.expression}]: ${this.value.expression}`;\n    traverseAllows = (data, ctx) => stringAndSymbolicEntriesOf(data).every(entry => {\n        if (this.signature.traverseAllows(entry[0], ctx)) {\n            // ctx will be undefined if this node isn't context-dependent\n            ctx?.path.push(entry[0]);\n            const allowed = this.value.traverseAllows(entry[1], ctx);\n            ctx?.path.pop();\n            return allowed;\n        }\n        return true;\n    });\n    traverseApply = (data, ctx) => stringAndSymbolicEntriesOf(data).forEach(entry => {\n        if (this.signature.traverseAllows(entry[0], ctx)) {\n            ctx.path.push(entry[0]);\n            this.value.traverseApply(entry[1], ctx);\n            ctx.path.pop();\n        }\n    });\n    _transform(mapper, ctx) {\n        ctx.path.push(this.signature);\n        const result = super._transform(mapper, ctx);\n        ctx.path.pop();\n        return result;\n    }\n    get flatRefs() {\n        return append(this.value.flatRefs.map(ref => flatRef([this.signature, ...ref.path], ref.node)), flatRef([this.signature], this.value));\n    }\n    compile() {\n        // this is currently handled by StructureNode\n    }\n}\nexport const writeEnumerableIndexBranches = (keys) => `Index keys ${keys.join(\", \")} should be specified as named props.`;\nexport const writeInvalidPropertyKeyMessage = (indexSchema) => `Indexed key definition '${indexSchema}' must be a string, number or symbol`;\n", "import { append, compileSerializedValue, printable, registeredReference, throwParseError, unset } from \"@ark/util\";\nimport { BaseConstraint } from \"../constraint.js\";\nimport { flatRef } from \"../node.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nexport const intersectProps = (l, r, ctx) => {\n    if (l.key !== r.key)\n        return null;\n    const key = l.key;\n    let value = intersectNodes(l.value, r.value, ctx);\n    const kind = l.required || r.required ? \"required\" : \"optional\";\n    if (value instanceof Disjoint) {\n        if (kind === \"optional\")\n            value = $ark.intrinsic.never.internal;\n        else {\n            // if either operand was optional, the Disjoint has to be treated as optional\n            return value.withPrefixKey(l.key, l.required && r.required ? \"required\" : \"optional\");\n        }\n    }\n    if (kind === \"required\") {\n        return ctx.$.node(\"required\", {\n            key,\n            value\n        });\n    }\n    const defaultIntersection = l.hasDefault() ?\n        r.hasDefault() ?\n            l.default === r.default ?\n                l.default\n                : throwParseError(`Invalid intersection of default values ${printable(l.default)} & ${printable(r.default)}`)\n            : l.default\n        : r.hasDefault() ? r.default\n            : unset;\n    return ctx.$.node(\"optional\", {\n        key,\n        value,\n        // unset is stripped during parsing\n        default: defaultIntersection\n    });\n};\nexport class BaseProp extends BaseConstraint {\n    required = this.kind === \"required\";\n    optional = this.kind === \"optional\";\n    impliedBasis = $ark.intrinsic.object;\n    serializedKey = compileSerializedValue(this.key);\n    compiledKey = typeof this.key === \"string\" ? this.key : this.serializedKey;\n    get flatRefs() {\n        return append(this.value.flatRefs.map(ref => flatRef([this.key, ...ref.path], ref.node)), flatRef([this.key], this.value));\n    }\n    _transform(mapper, ctx) {\n        ctx.path.push(this.key);\n        const result = super._transform(mapper, ctx);\n        ctx.path.pop();\n        return result;\n    }\n    defaultValueMorphs = [\n        data => {\n            data[this.key] = this.default;\n            return data;\n        }\n    ];\n    defaultValueMorphsReference = registeredReference(this.defaultValueMorphs);\n    hasDefault() {\n        return \"default\" in this;\n    }\n    traverseAllows = (data, ctx) => {\n        if (this.key in data) {\n            // ctx will be undefined if this node isn't context-dependent\n            ctx?.path.push(this.key);\n            const allowed = this.value.traverseAllows(data[this.key], ctx);\n            ctx?.path.pop();\n            return allowed;\n        }\n        return this.optional;\n    };\n    traverseApply = (data, ctx) => {\n        if (this.key in data) {\n            ctx.path.push(this.key);\n            this.value.traverseApply(data[this.key], ctx);\n            ctx.path.pop();\n        }\n        else if (this.hasKind(\"required\"))\n            ctx.error(this.errorContext);\n        else if (this.hasKind(\"optional\") && this.hasDefault())\n            ctx.queueMorphs(this.defaultValueMorphs);\n    };\n    compile(js) {\n        js.if(`${this.serializedKey} in data`, () => js.traverseKey(this.serializedKey, `data${js.prop(this.key)}`, this.value));\n        if (this.hasKind(\"required\")) {\n            js.else(() => {\n                if (js.traversalKind === \"Apply\")\n                    return js.line(`ctx.error(${this.compiledErrorContext})`);\n                else\n                    return js.return(false);\n            });\n        }\n        else if (js.traversalKind === \"Apply\" && \"default\" in this) {\n            js.else(() => js.line(`ctx.queueMorphs(${this.defaultValueMorphsReference})`));\n        }\n        if (js.traversalKind === \"Allows\")\n            js.return(true);\n    }\n}\n", "import { implementNode } from \"../shared/implement.js\";\nimport { BaseProp, intersectProps } from \"./prop.js\";\nexport const optionalImplementation = implementNode({\n    kind: \"optional\",\n    hasAssociatedError: false,\n    intersectionIsOpen: true,\n    keys: {\n        key: {},\n        value: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.schema(schema)\n        },\n        default: {\n            preserveUndefined: true\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `${node.compiledKey}?: ${node.value.description}`\n    },\n    intersections: {\n        optional: intersectProps\n    }\n});\nexport class OptionalNode extends BaseProp {\n    expression = `${this.compiledKey}?: ${this.value.expression}`;\n}\n", "import { compileErrorContext, implementNode } from \"../shared/implement.js\";\nimport { BaseProp, intersectProps } from \"./prop.js\";\nexport class RequiredNode extends BaseProp {\n    expression = `${this.compiledKey}: ${this.value.expression}`;\n    errorContext = Object.freeze({\n        code: \"required\",\n        missingValueDescription: this.value.shortDescription,\n        relativePath: [this.key]\n    });\n    compiledErrorContext = compileErrorContext(this.errorContext);\n}\nexport const requiredImplementation = implementNode({\n    kind: \"required\",\n    hasAssociatedError: true,\n    intersectionIsOpen: true,\n    keys: {\n        key: {},\n        value: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.schema(schema)\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `${node.compiledKey}: ${node.value.description}`,\n        expected: ctx => ctx.missingValueDescription,\n        actual: () => \"missing\"\n    },\n    intersections: {\n        required: intersectProps,\n        optional: intersectProps\n    }\n});\n", "var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { append, cached, throwInternalError, throwParseError } from \"@ark/util\";\nimport { BaseConstraint } from \"../constraint.js\";\nimport { appendUniqueFlatRefs, flatRef } from \"../node.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nconst fixedSequenceKeySchemaDefinition = {\n    child: true,\n    parse: (schema, ctx) => schema.length === 0 ?\n        // empty affixes are omitted. an empty array should therefore\n        // be specified as `{ proto: Array, length: 0 }`\n        undefined\n        : schema.map(element => ctx.$.schema(element))\n};\nexport const sequenceImplementation = implementNode({\n    kind: \"sequence\",\n    hasAssociatedError: false,\n    collapsibleKey: \"variadic\",\n    keys: {\n        prefix: fixedSequenceKeySchemaDefinition,\n        optionals: fixedSequenceKeySchemaDefinition,\n        variadic: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.schema(schema, ctx)\n        },\n        minVariadicLength: {\n            // minVariadicLength is reflected in the id of this node,\n            // but not its IntersectionNode parent since it is superceded by the minLength\n            // node it implies\n            parse: min => (min === 0 ? undefined : min)\n        },\n        postfix: fixedSequenceKeySchemaDefinition\n    },\n    normalize: schema => {\n        if (typeof schema === \"string\")\n            return { variadic: schema };\n        if (\"variadic\" in schema ||\n            \"prefix\" in schema ||\n            \"optionals\" in schema ||\n            \"postfix\" in schema ||\n            \"minVariadicLength\" in schema) {\n            if (schema.postfix?.length) {\n                if (!schema.variadic)\n                    return throwParseError(postfixWithoutVariadicMessage);\n                if (schema.optionals?.length)\n                    return throwParseError(postfixFollowingOptionalMessage);\n            }\n            if (schema.minVariadicLength && !schema.variadic) {\n                return throwParseError(\"minVariadicLength may not be specified without a variadic element\");\n            }\n            return schema;\n        }\n        return { variadic: schema };\n    },\n    reduce: (raw, $) => {\n        let minVariadicLength = raw.minVariadicLength ?? 0;\n        const prefix = raw.prefix?.slice() ?? [];\n        const optional = raw.optionals?.slice() ?? [];\n        const postfix = raw.postfix?.slice() ?? [];\n        if (raw.variadic) {\n            // optional elements equivalent to the variadic parameter are redundant\n            while (optional.at(-1)?.equals(raw.variadic))\n                optional.pop();\n            if (optional.length === 0) {\n                // If there are no optional, normalize prefix\n                // elements adjacent and equivalent to variadic:\n                // \t\t{ variadic: number, prefix: [string, number] }\n                // reduces to:\n                // \t\t{ variadic: number, prefix: [string], minVariadicLength: 1 }\n                while (prefix.at(-1)?.equals(raw.variadic)) {\n                    prefix.pop();\n                    minVariadicLength++;\n                }\n            }\n            // Normalize postfix elements adjacent and equivalent to variadic:\n            // \t\t{ variadic: number, postfix: [number, number, 5] }\n            // reduces to:\n            // \t\t{ variadic: number, postfix: [5], minVariadicLength: 2 }\n            while (postfix[0]?.equals(raw.variadic)) {\n                postfix.shift();\n                minVariadicLength++;\n            }\n        }\n        else if (optional.length === 0) {\n            // if there's no variadic or optional parameters,\n            // postfix can just be appended to prefix\n            prefix.push(...postfix.splice(0));\n        }\n        if (\n        // if any variadic adjacent elements were moved to minVariadicLength\n        minVariadicLength !== raw.minVariadicLength ||\n            // or any postfix elements were moved to prefix\n            (raw.prefix && raw.prefix.length !== prefix.length)) {\n            // reparse the reduced def\n            return $.node(\"sequence\", {\n                ...raw,\n                // empty lists will be omitted during parsing\n                prefix,\n                postfix,\n                optionals: optional,\n                minVariadicLength\n            }, { prereduced: true });\n        }\n    },\n    defaults: {\n        description: node => {\n            if (node.isVariadicOnly)\n                return `${node.variadic.nestableExpression}[]`;\n            const innerDescription = node.tuple\n                .map(element => element.kind === \"optionals\" ? `${element.node.nestableExpression}?`\n                : element.kind === \"variadic\" ?\n                    `...${element.node.nestableExpression}[]`\n                    : element.node.expression)\n                .join(\", \");\n            return `[${innerDescription}]`;\n        }\n    },\n    intersections: {\n        sequence: (l, r, ctx) => {\n            const rootState = _intersectSequences({\n                l: l.tuple,\n                r: r.tuple,\n                disjoint: new Disjoint(),\n                result: [],\n                fixedVariants: [],\n                ctx\n            });\n            const viableBranches = rootState.disjoint.length === 0 ?\n                [rootState, ...rootState.fixedVariants]\n                : rootState.fixedVariants;\n            return (viableBranches.length === 0 ? rootState.disjoint\n                : viableBranches.length === 1 ?\n                    ctx.$.node(\"sequence\", sequenceTupleToInner(viableBranches[0].result))\n                    : ctx.$.node(\"union\", viableBranches.map(state => ({\n                        proto: Array,\n                        sequence: sequenceTupleToInner(state.result)\n                    }))));\n        }\n        // exactLength, minLength, and maxLength don't need to be defined\n        // here since impliedSiblings guarantees they will be added\n        // directly to the IntersectionNode parent of the SequenceNode\n        // they exist on\n    }\n});\nlet SequenceNode = (() => {\n    let _classSuper = BaseConstraint;\n    let _instanceExtraInitializers = [];\n    let _get_element_decorators;\n    return class SequenceNode extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _get_element_decorators = [cached];\n            __esDecorate(this, null, _get_element_decorators, { kind: \"getter\", name: \"element\", static: false, private: false, access: { has: obj => \"element\" in obj, get: obj => obj.element }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        impliedBasis = (__runInitializers(this, _instanceExtraInitializers), $ark.intrinsic.Array);\n        prefix = this.inner.prefix ?? [];\n        optionals = this.inner.optionals ?? [];\n        prevariadic = [...this.prefix, ...this.optionals];\n        postfix = this.inner.postfix ?? [];\n        variadicOrPostfix = this.variadic ? [this.variadic, ...this.postfix] : this.postfix;\n        isVariadicOnly = this.prevariadic.length + this.postfix.length === 0;\n        minVariadicLength = this.inner.minVariadicLength ?? 0;\n        minLength = this.prefix.length + this.minVariadicLength + this.postfix.length;\n        minLengthNode = this.minLength === 0 ? null : this.$.node(\"minLength\", this.minLength);\n        maxLength = this.variadic ? null : this.minLength + this.optionals.length;\n        maxLengthNode = this.maxLength === null ? null : this.$.node(\"maxLength\", this.maxLength);\n        impliedSiblings = this.minLengthNode ?\n            this.maxLengthNode ?\n                [this.minLengthNode, this.maxLengthNode]\n                : [this.minLengthNode]\n            : this.maxLengthNode ? [this.maxLengthNode]\n                : [];\n        childAtIndex(data, index) {\n            if (index < this.prevariadic.length)\n                return this.prevariadic[index];\n            const firstPostfixIndex = data.length - this.postfix.length;\n            if (index >= firstPostfixIndex)\n                return this.postfix[index - firstPostfixIndex];\n            return (this.variadic ??\n                throwInternalError(`Unexpected attempt to access index ${index} on ${this}`));\n        }\n        // minLength/maxLength should be checked by Intersection before either traversal\n        traverseAllows = (data, ctx) => {\n            for (let i = 0; i < data.length; i++)\n                if (!this.childAtIndex(data, i).traverseAllows(data[i], ctx))\n                    return false;\n            return true;\n        };\n        traverseApply = (data, ctx) => {\n            for (let i = 0; i < data.length; i++) {\n                ctx.path.push(i);\n                this.childAtIndex(data, i).traverseApply(data[i], ctx);\n                ctx.path.pop();\n            }\n        };\n        get flatRefs() {\n            const refs = [];\n            appendUniqueFlatRefs(refs, this.prevariadic.flatMap((element, i) => append(element.flatRefs.map(ref => flatRef([`${i}`, ...ref.path], ref.node)), flatRef([`${i}`], element))));\n            appendUniqueFlatRefs(refs, this.variadicOrPostfix.flatMap(element => \n            // a postfix index can't be directly represented as a type\n            // key, so we just use the same matcher for variadic\n            append(element.flatRefs.map(ref => flatRef([$ark.intrinsic.nonNegativeIntegerString, ...ref.path], ref.node)), flatRef([$ark.intrinsic.nonNegativeIntegerString], element))));\n            return refs;\n        }\n        get element() {\n            return this.$.node(\"union\", this.children);\n        }\n        // minLength/maxLength compilation should be handled by Intersection\n        compile(js) {\n            this.prefix.forEach((node, i) => js.traverseKey(`${i}`, `data[${i}]`, node));\n            this.optionals.forEach((node, i) => {\n                const dataIndex = `${i + this.prefix.length}`;\n                js.if(`${dataIndex} >= ${js.data}.length`, () => js.traversalKind === \"Allows\" ? js.return(true) : js.return());\n                js.traverseKey(dataIndex, `data[${dataIndex}]`, node);\n            });\n            if (this.variadic) {\n                if (this.postfix.length) {\n                    js.const(\"firstPostfixIndex\", `${js.data}.length${this.postfix.length ? `- ${this.postfix.length}` : \"\"}`);\n                }\n                js.for(`i < ${this.postfix.length ? \"firstPostfixIndex\" : \"data.length\"}`, () => js.traverseKey(\"i\", \"data[i]\", this.variadic), this.prevariadic.length);\n                this.postfix.forEach((node, i) => {\n                    const keyExpression = `firstPostfixIndex + ${i}`;\n                    js.traverseKey(keyExpression, `data[${keyExpression}]`, node);\n                });\n            }\n            if (js.traversalKind === \"Allows\")\n                js.return(true);\n        }\n        _transform(mapper, ctx) {\n            ctx.path.push($ark.intrinsic.nonNegativeIntegerString);\n            const result = super._transform(mapper, ctx);\n            ctx.path.pop();\n            return result;\n        }\n        tuple = sequenceInnerToTuple(this.inner);\n        // this depends on tuple so needs to come after it\n        expression = this.description;\n    };\n})();\nexport { SequenceNode };\nconst sequenceInnerToTuple = (inner) => {\n    const tuple = [];\n    inner.prefix?.forEach(node => tuple.push({ kind: \"prefix\", node }));\n    inner.optionals?.forEach(node => tuple.push({ kind: \"optionals\", node }));\n    if (inner.variadic)\n        tuple.push({ kind: \"variadic\", node: inner.variadic });\n    inner.postfix?.forEach(node => tuple.push({ kind: \"postfix\", node }));\n    return tuple;\n};\nconst sequenceTupleToInner = (tuple) => tuple.reduce((result, node) => {\n    if (node.kind === \"variadic\")\n        result.variadic = node.node;\n    else\n        result[node.kind] = append(result[node.kind], node.node);\n    return result;\n}, {});\nexport const postfixFollowingOptionalMessage = \"A postfix required element cannot follow an optional element\";\nexport const postfixWithoutVariadicMessage = \"A postfix element requires a variadic element\";\nconst _intersectSequences = (s) => {\n    const [lHead, ...lTail] = s.l;\n    const [rHead, ...rTail] = s.r;\n    if (!lHead || !rHead)\n        return s;\n    const lHasPostfix = lTail.at(-1)?.kind === \"postfix\";\n    const rHasPostfix = rTail.at(-1)?.kind === \"postfix\";\n    const kind = lHead.kind === \"prefix\" || rHead.kind === \"prefix\" ? \"prefix\"\n        : lHead.kind === \"optionals\" || rHead.kind === \"optionals\" ?\n            // if either operand has postfix elements, the full-length\n            // intersection can't include optional elements (though they may\n            // exist in some of the fixed length variants)\n            lHasPostfix || rHasPostfix ?\n                \"prefix\"\n                : \"optionals\"\n            : lHead.kind === \"postfix\" || rHead.kind === \"postfix\" ? \"postfix\"\n                : \"variadic\";\n    if (lHead.kind === \"prefix\" && rHead.kind === \"variadic\" && rHasPostfix) {\n        const postfixBranchResult = _intersectSequences({\n            ...s,\n            fixedVariants: [],\n            r: rTail.map(element => ({ ...element, kind: \"prefix\" }))\n        });\n        if (postfixBranchResult.disjoint.length === 0)\n            s.fixedVariants.push(postfixBranchResult);\n    }\n    else if (rHead.kind === \"prefix\" &&\n        lHead.kind === \"variadic\" &&\n        lHasPostfix) {\n        const postfixBranchResult = _intersectSequences({\n            ...s,\n            fixedVariants: [],\n            l: lTail.map(element => ({ ...element, kind: \"prefix\" }))\n        });\n        if (postfixBranchResult.disjoint.length === 0)\n            s.fixedVariants.push(postfixBranchResult);\n    }\n    const result = intersectNodes(lHead.node, rHead.node, s.ctx);\n    if (result instanceof Disjoint) {\n        if (kind === \"prefix\" || kind === \"postfix\") {\n            s.disjoint.push(...result.withPrefixKey(\n            // TODO: more precise path handling for Disjoints\n            kind === \"prefix\" ? `${s.result.length}` : `-${lTail.length + 1}`, \"required\"));\n            s.result = [...s.result, { kind, node: $ark.intrinsic.never.internal }];\n        }\n        else if (kind === \"optionals\") {\n            // if the element result is optional and unsatisfiable, the\n            // intersection can still be satisfied as long as the tuple\n            // ends before the disjoint element would occur\n            return s;\n        }\n        else {\n            // if the element is variadic and unsatisfiable, the intersection\n            // can be satisfied with a fixed length variant including zero\n            // variadic elements\n            return _intersectSequences({\n                ...s,\n                fixedVariants: [],\n                // if there were any optional elements, there will be no postfix elements\n                // so this mapping will never occur (which would be illegal otherwise)\n                l: lTail.map(element => ({ ...element, kind: \"prefix\" })),\n                r: lTail.map(element => ({ ...element, kind: \"prefix\" }))\n            });\n        }\n    }\n    else\n        s.result = [...s.result, { kind, node: result }];\n    const lRemaining = s.l.length;\n    const rRemaining = s.r.length;\n    if (lHead.kind !== \"variadic\" ||\n        (lRemaining >= rRemaining &&\n            (rHead.kind === \"variadic\" || rRemaining === 1)))\n        s.l = lTail;\n    if (rHead.kind !== \"variadic\" ||\n        (rRemaining >= lRemaining &&\n            (lHead.kind === \"variadic\" || lRemaining === 1)))\n        s.r = rTail;\n    return _intersectSequences(s);\n};\n", "import { registeredReference } from \"@ark/util\";\nexport const arrayIndexSource = `^(?:0|[1-9]\\\\d*)$`;\nexport const arrayIndexMatcher = new RegExp(arrayIndexSource);\nexport const arrayIndexMatcherReference = registeredReference(arrayIndexMatcher);\n", "var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { append, cached, flatMorph, printable, registeredReference, spliterate, throwParseError } from \"@ark/util\";\nimport { BaseConstraint, constraintKeyParser, flattenConstraints, intersectConstraints } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodesRoot } from \"../shared/intersections.js\";\nimport { hasArkKind, makeRootAndArrayPropertiesMutable } from \"../shared/utils.js\";\nimport { arrayIndexMatcherReference } from \"./shared.js\";\nlet StructureNode = (() => {\n    let _classSuper = BaseConstraint;\n    let _instanceExtraInitializers = [];\n    let _keyof_decorators;\n    return class StructureNode extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _keyof_decorators = [cached];\n            __esDecorate(this, null, _keyof_decorators, { kind: \"method\", name: \"keyof\", static: false, private: false, access: { has: obj => \"keyof\" in obj, get: obj => obj.keyof }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        impliedBasis = (__runInitializers(this, _instanceExtraInitializers), $ark.intrinsic.object);\n        impliedSiblings = this.children.flatMap(n => n.impliedSiblings ?? []);\n        props = this.required ?\n            this.optional ?\n                [...this.required, ...this.optional]\n                : this.required\n            : this.optional ?? [];\n        propsByKey = flatMorph(this.props, (i, node) => [node.key, node]);\n        propsByKeyReference = registeredReference(this.propsByKey);\n        expression = structuralExpression(this);\n        requiredLiteralKeys = this.required?.map(node => node.key) ?? [];\n        optionalLiteralKeys = this.optional?.map(node => node.key) ?? [];\n        literalKeys = [\n            ...this.requiredLiteralKeys,\n            ...this.optionalLiteralKeys\n        ];\n        keyof() {\n            let branches = this.$.units(this.literalKeys).branches;\n            this.index?.forEach(({ signature }) => {\n                branches = branches.concat(signature.branches);\n            });\n            return this.$.node(\"union\", branches);\n        }\n        get(key, ...tail) {\n            let value;\n            let required = false;\n            if (hasArkKind(key, \"root\") && key.hasKind(\"unit\"))\n                key = key.unit;\n            if ((typeof key === \"string\" || typeof key === \"symbol\") &&\n                this.propsByKey[key]) {\n                value = this.propsByKey[key].value;\n                required = this.propsByKey[key].required;\n            }\n            this.index?.forEach(n => {\n                if (n.signature.includes(key))\n                    value = value?.and(n.value) ?? n.value;\n            });\n            if (this.sequence &&\n                $ark.intrinsic.nonNegativeIntegerString.includes(key)) {\n                if (hasArkKind(key, \"root\")) {\n                    if (this.sequence.variadic)\n                        // if there is a variadic element and we're accessing an index, return a union\n                        // of all possible elements. If there is no variadic expression, we're in a tuple\n                        // so this access wouldn't be safe based on the array indices\n                        value = value?.and(this.sequence.element) ?? this.sequence.element;\n                }\n                else {\n                    const index = Number.parseInt(key);\n                    if (index < this.sequence.prevariadic.length) {\n                        const fixedElement = this.sequence.prevariadic[index];\n                        value = value?.and(fixedElement) ?? fixedElement;\n                        required ||= index < this.sequence.prefix.length;\n                    }\n                    else if (this.sequence.variadic) {\n                        // ideally we could return something more specific for postfix\n                        // but there is no way to represent it using an index alone\n                        const nonFixedElement = this.$.node(\"union\", this.sequence.variadicOrPostfix);\n                        value = value?.and(nonFixedElement) ?? nonFixedElement;\n                    }\n                }\n            }\n            if (!value) {\n                if (this.sequence?.variadic &&\n                    hasArkKind(key, \"root\") &&\n                    key.extends($ark.intrinsic.number)) {\n                    return throwParseError(writeRawNumberIndexMessage(key.expression, this.sequence.expression));\n                }\n                return throwParseError(writeBadKeyAccessMessage(key, this.expression));\n            }\n            const result = value.get(...tail);\n            return required ? result : result.or($ark.intrinsic.undefined);\n        }\n        exhaustive = this.undeclared !== undefined || this.index !== undefined;\n        omit(...keys) {\n            return this.$.node(\"structure\", omitFromInner(this.inner, keys));\n        }\n        merge(r) {\n            const inner = makeRootAndArrayPropertiesMutable(omitFromInner(this.inner, [r.keyof()]));\n            if (r.required)\n                inner.required = append(inner.required, r.required);\n            if (r.optional)\n                inner.optional = append(inner.optional, r.optional);\n            if (r.index)\n                inner.index = append(inner.index, r.index);\n            if (r.sequence)\n                inner.sequence = r.sequence;\n            if (r.undeclared)\n                inner.undeclared = r.undeclared;\n            else\n                delete inner.undeclared;\n            return this.$.node(\"structure\", inner);\n        }\n        traverseAllows = (data, ctx) => this._traverse(\"Allows\", data, ctx);\n        traverseApply = (data, ctx) => this._traverse(\"Apply\", data, ctx);\n        _traverse = (traversalKind, data, ctx) => {\n            const errorCount = ctx?.currentErrorCount ?? 0;\n            for (let i = 0; i < this.props.length; i++) {\n                if (traversalKind === \"Allows\") {\n                    if (!this.props[i].traverseAllows(data, ctx))\n                        return false;\n                }\n                else {\n                    this.props[i].traverseApply(data, ctx);\n                    if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                        return false;\n                }\n            }\n            if (this.sequence) {\n                if (traversalKind === \"Allows\") {\n                    if (!this.sequence.traverseAllows(data, ctx))\n                        return false;\n                }\n                else {\n                    this.sequence.traverseApply(data, ctx);\n                    if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                        return false;\n                }\n            }\n            if (!this.exhaustive)\n                return true;\n            const keys = Object.keys(data);\n            keys.push(...Object.getOwnPropertySymbols(data));\n            for (let i = 0; i < keys.length; i++) {\n                const k = keys[i];\n                let matched = false;\n                if (this.index) {\n                    for (const node of this.index) {\n                        if (node.signature.traverseAllows(k, ctx)) {\n                            if (traversalKind === \"Allows\") {\n                                ctx?.path.push(k);\n                                const result = node.value.traverseAllows(data[k], ctx);\n                                ctx?.path.pop();\n                                if (!result)\n                                    return false;\n                            }\n                            else {\n                                ctx.path.push(k);\n                                node.value.traverseApply(data[k], ctx);\n                                ctx.path.pop();\n                                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                                    return false;\n                            }\n                            matched = true;\n                        }\n                    }\n                }\n                if (this.undeclared) {\n                    matched ||= k in this.propsByKey;\n                    matched ||=\n                        this.sequence !== undefined &&\n                            typeof k === \"string\" &&\n                            $ark.intrinsic.nonNegativeIntegerString.allows(k);\n                    if (!matched) {\n                        if (traversalKind === \"Allows\")\n                            return false;\n                        if (this.undeclared === \"reject\")\n                            ctx.error({ expected: \"removed\", actual: null, relativePath: [k] });\n                        else {\n                            ctx.queueMorphs([\n                                data => {\n                                    delete data[k];\n                                    return data;\n                                }\n                            ]);\n                        }\n                        if (ctx.failFast)\n                            return false;\n                    }\n                }\n                ctx?.path.pop();\n            }\n            return true;\n        };\n        compile(js) {\n            if (js.traversalKind === \"Apply\")\n                js.initializeErrorCount();\n            this.props.forEach(prop => {\n                js.check(prop);\n                if (js.traversalKind === \"Apply\")\n                    js.returnIfFailFast();\n            });\n            if (this.sequence) {\n                js.check(this.sequence);\n                if (js.traversalKind === \"Apply\")\n                    js.returnIfFailFast();\n            }\n            if (this.exhaustive) {\n                js.const(\"keys\", \"Object.keys(data)\");\n                js.line(\"keys.push(...Object.getOwnPropertySymbols(data))\");\n                js.for(\"i < keys.length\", () => this.compileExhaustiveEntry(js));\n            }\n            if (js.traversalKind === \"Allows\")\n                js.return(true);\n        }\n        compileExhaustiveEntry(js) {\n            js.const(\"k\", \"keys[i]\");\n            if (this.undeclared)\n                js.let(\"matched\", false);\n            this.index?.forEach(node => {\n                js.if(`${js.invoke(node.signature, { arg: \"k\", kind: \"Allows\" })}`, () => {\n                    js.traverseKey(\"k\", \"data[k]\", node.value);\n                    if (this.undeclared)\n                        js.set(\"matched\", true);\n                    return js;\n                });\n            });\n            if (this.undeclared) {\n                if (this.props?.length !== 0)\n                    js.line(`matched ||= k in ${this.propsByKeyReference}`);\n                if (this.sequence) {\n                    js.line(`matched ||= typeof k === \"string\" && ${arrayIndexMatcherReference}.test(k)`);\n                }\n                js.if(\"!matched\", () => {\n                    if (js.traversalKind === \"Allows\")\n                        return js.return(false);\n                    return this.undeclared === \"reject\" ?\n                        js\n                            .line(`ctx.error({ expected: \"removed\", actual: null, relativePath: [k] })`)\n                            .if(\"ctx.failFast\", () => js.return())\n                        : js.line(`ctx.queueMorphs([data => { delete data[k]; return data }])`);\n                });\n            }\n            return js;\n        }\n    };\n})();\nexport { StructureNode };\nconst omitFromInner = (inner, keys) => {\n    const result = { ...inner };\n    keys.forEach(k => {\n        if (result.required) {\n            result.required = result.required.filter(b => hasArkKind(k, \"root\") ? !k.allows(b.key) : k !== b.key);\n        }\n        if (result.optional) {\n            result.optional = result.optional.filter(b => hasArkKind(k, \"root\") ? !k.allows(b.key) : k !== b.key);\n        }\n        if (result.index && hasArkKind(k, \"root\")) {\n            // we only have to filter index nodes if the input was a node, as\n            // literal keys should never subsume an index\n            result.index = result.index.filter(n => !n.signature.extends(k));\n        }\n    });\n    return result;\n};\nconst createStructuralWriter = (childStringProp) => (node) => {\n    if (node.props.length || node.index) {\n        const parts = node.index?.map(String) ?? [];\n        node.props.forEach(node => parts.push(node[childStringProp]));\n        if (node.undeclared)\n            parts.push(`+ (undeclared): ${node.undeclared}`);\n        const objectLiteralDescription = `{ ${parts.join(\", \")} }`;\n        return node.sequence ?\n            `${objectLiteralDescription} & ${node.sequence.description}`\n            : objectLiteralDescription;\n    }\n    return node.sequence?.description ?? \"{}\";\n};\nconst structuralDescription = createStructuralWriter(\"description\");\nconst structuralExpression = createStructuralWriter(\"expression\");\nexport const structureImplementation = implementNode({\n    kind: \"structure\",\n    hasAssociatedError: false,\n    normalize: schema => schema,\n    keys: {\n        required: {\n            child: true,\n            parse: constraintKeyParser(\"required\")\n        },\n        optional: {\n            child: true,\n            parse: constraintKeyParser(\"optional\")\n        },\n        index: {\n            child: true,\n            parse: constraintKeyParser(\"index\")\n        },\n        sequence: {\n            child: true,\n            parse: constraintKeyParser(\"sequence\")\n        },\n        undeclared: {\n            parse: behavior => (behavior === \"ignore\" ? undefined : behavior)\n        }\n    },\n    defaults: {\n        description: structuralDescription\n    },\n    intersections: {\n        structure: (l, r, ctx) => {\n            const lInner = { ...l.inner };\n            const rInner = { ...r.inner };\n            if (l.undeclared) {\n                const lKey = l.keyof();\n                const disjointRKeys = r.requiredLiteralKeys.filter(k => !lKey.allows(k));\n                if (disjointRKeys.length) {\n                    return new Disjoint(...disjointRKeys.map(k => ({\n                        kind: \"presence\",\n                        l: $ark.intrinsic.never.internal,\n                        r: r.propsByKey[k].value,\n                        path: [k],\n                        optional: false\n                    })));\n                }\n                if (rInner.optional)\n                    rInner.optional = rInner.optional.filter(n => lKey.allows(n.key));\n                if (rInner.index) {\n                    rInner.index = rInner.index.flatMap(n => {\n                        if (n.signature.extends(lKey))\n                            return n;\n                        const indexOverlap = intersectNodesRoot(lKey, n.signature, ctx.$);\n                        if (indexOverlap instanceof Disjoint)\n                            return [];\n                        const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);\n                        if (normalized.required) {\n                            rInner.required =\n                                rInner.required ?\n                                    [...rInner.required, ...normalized.required]\n                                    : normalized.required;\n                        }\n                        return normalized.index ?? [];\n                    });\n                }\n            }\n            if (r.undeclared) {\n                const rKey = r.keyof();\n                const disjointLKeys = l.requiredLiteralKeys.filter(k => !rKey.allows(k));\n                if (disjointLKeys.length) {\n                    return new Disjoint(...disjointLKeys.map(k => ({\n                        kind: \"presence\",\n                        l: l.propsByKey[k].value,\n                        r: $ark.intrinsic.never.internal,\n                        path: [k],\n                        optional: false\n                    })));\n                }\n                if (lInner.optional)\n                    lInner.optional = lInner.optional.filter(n => rKey.allows(n.key));\n                if (lInner.index) {\n                    lInner.index = lInner.index.flatMap(n => {\n                        if (n.signature.extends(rKey))\n                            return n;\n                        const indexOverlap = intersectNodesRoot(rKey, n.signature, ctx.$);\n                        if (indexOverlap instanceof Disjoint)\n                            return [];\n                        const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);\n                        if (normalized.required) {\n                            lInner.required =\n                                lInner.required ?\n                                    [...lInner.required, ...normalized.required]\n                                    : normalized.required;\n                        }\n                        return normalized.index ?? [];\n                    });\n                }\n            }\n            const baseInner = {};\n            if (l.undeclared || r.undeclared) {\n                baseInner.undeclared =\n                    l.undeclared === \"reject\" || r.undeclared === \"reject\" ?\n                        \"reject\"\n                        : \"delete\";\n            }\n            return intersectConstraints({\n                kind: \"structure\",\n                baseInner,\n                l: flattenConstraints(lInner),\n                r: flattenConstraints(rInner),\n                roots: [],\n                ctx\n            });\n        }\n    }\n});\nexport const writeRawNumberIndexMessage = (indexExpression, sequenceExpression) => `${indexExpression} is not allowed as an array index on ${sequenceExpression}. Use the 'nonNegativeIntegerString' keyword instead.`;\nexport const writeBadKeyAccessMessage = (key, structuralExpression) => `${printable(key)} does not exist on ${structuralExpression}`;\n/** extract enumerable named props from an index signature */\nexport const normalizeIndex = (signature, value, $) => {\n    const [enumerableBranches, nonEnumerableBranches] = spliterate(signature.branches, k => k.hasKind(\"unit\"));\n    if (!enumerableBranches.length)\n        return { index: $.node(\"index\", { signature, value }) };\n    const normalized = {};\n    normalized.required = enumerableBranches.map(n => $.node(\"required\", { key: n.unit, value }));\n    if (nonEnumerableBranches.length) {\n        normalized.index = $.node(\"index\", {\n            signature: nonEnumerableBranches,\n            value\n        });\n    }\n    return normalized;\n};\n", "import { envHasCsp, flatMorph } from \"@ark/util\";\nimport { PredicateNode, predicateImplementation } from \"./predicate.js\";\nimport { DivisorNode, divisorImplementation } from \"./refinements/divisor.js\";\nimport { boundClassesByKind, boundImplementationsByKind } from \"./refinements/kinds.js\";\nimport { PatternNode, patternImplementation } from \"./refinements/pattern.js\";\nimport { AliasNode, aliasImplementation } from \"./roots/alias.js\";\nimport { DomainNode, domainImplementation } from \"./roots/domain.js\";\nimport { IntersectionNode, intersectionImplementation } from \"./roots/intersection.js\";\nimport { MorphNode, morphImplementation } from \"./roots/morph.js\";\nimport { ProtoNode, protoImplementation } from \"./roots/proto.js\";\nimport { UnionNode, unionImplementation } from \"./roots/union.js\";\nimport { UnitNode, unitImplementation } from \"./roots/unit.js\";\nimport { IndexNode, indexImplementation } from \"./structure/indexed.js\";\nimport { OptionalNode, optionalImplementation } from \"./structure/optional.js\";\nimport { RequiredNode, requiredImplementation } from \"./structure/required.js\";\nimport { SequenceNode, sequenceImplementation } from \"./structure/sequence.js\";\nimport { StructureNode, structureImplementation } from \"./structure/structure.js\";\nexport const nodeImplementationsByKind = {\n    ...boundImplementationsByKind,\n    alias: aliasImplementation,\n    domain: domainImplementation,\n    unit: unitImplementation,\n    proto: protoImplementation,\n    union: unionImplementation,\n    morph: morphImplementation,\n    intersection: intersectionImplementation,\n    divisor: divisorImplementation,\n    pattern: patternImplementation,\n    predicate: predicateImplementation,\n    required: requiredImplementation,\n    optional: optionalImplementation,\n    index: indexImplementation,\n    sequence: sequenceImplementation,\n    structure: structureImplementation\n};\n$ark.defaultConfig = Object.assign(flatMorph(nodeImplementationsByKind, (kind, implementation) => [\n    kind,\n    implementation.defaults\n]), {\n    jitless: envHasCsp(),\n    intrinsic: false,\n    prereducedAliases: false\n});\nexport const nodeClassesByKind = {\n    ...boundClassesByKind,\n    alias: AliasNode,\n    domain: DomainNode,\n    unit: UnitNode,\n    proto: ProtoNode,\n    union: UnionNode,\n    morph: MorphNode,\n    intersection: IntersectionNode,\n    divisor: DivisorNode,\n    pattern: PatternNode,\n    predicate: PredicateNode,\n    required: RequiredNode,\n    optional: OptionalNode,\n    index: IndexNode,\n    sequence: SequenceNode,\n    structure: StructureNode\n};\n", "import { DynamicBase } from \"@ark/util\";\nimport { arkKind } from \"./shared/utils.js\";\nexport class RootModule extends DynamicBase {\n    // ensure `[arkKind]` is non-enumerable so it doesn't get spread on import/export\n    get [arkKind]() {\n        return \"module\";\n    }\n}\nexport const SchemaModule = RootModule;\n", "import { entriesOf, hasDomain, isArray, printable, throwParseError, unset } from \"@ark/util\";\nimport { nodeClassesByKind, nodeImplementationsByKind } from \"./kinds.js\";\nimport { Disjoint } from \"./shared/disjoint.js\";\nimport { constraintKeys, defaultValueSerializer, isNodeKind, precedenceOfKind } from \"./shared/implement.js\";\nimport { hasArkKind } from \"./shared/utils.js\";\nexport const schemaKindOf = (schema, allowedKinds) => {\n    const kind = discriminateRootKind(schema);\n    if (allowedKinds && !allowedKinds.includes(kind)) {\n        return throwParseError(`Root of kind ${kind} should be one of ${allowedKinds}`);\n    }\n    return kind;\n};\nconst discriminateRootKind = (schema) => {\n    if (hasArkKind(schema, \"root\"))\n        return schema.kind;\n    if (typeof schema === \"string\")\n        return schema[0] === \"$\" ? \"alias\" : \"domain\";\n    if (typeof schema === \"function\")\n        return \"proto\";\n    // throw at end of function\n    if (typeof schema !== \"object\" || schema === null)\n        return throwParseError(writeInvalidSchemaMessage(schema));\n    if (\"morphs\" in schema)\n        return \"morph\";\n    if (\"branches\" in schema || isArray(schema))\n        return \"union\";\n    if (\"unit\" in schema)\n        return \"unit\";\n    if (\"alias\" in schema)\n        return \"alias\";\n    const schemaKeys = Object.keys(schema);\n    if (schemaKeys.length === 0 || schemaKeys.some(k => k in constraintKeys))\n        return \"intersection\";\n    if (\"proto\" in schema)\n        return \"proto\";\n    if (\"domain\" in schema)\n        return \"domain\";\n    return throwParseError(writeInvalidSchemaMessage(schema));\n};\nexport const writeInvalidSchemaMessage = (schema) => `${printable(schema)} is not a valid type schema`;\nconst nodeCache = {};\nconst nodeCountsByPrefix = {};\nconst serializeListableChild = (listableNode) => isArray(listableNode) ?\n    listableNode.map(node => node.collapsibleJson)\n    : listableNode.collapsibleJson;\nexport const registerNodeId = (kind, opts) => {\n    const prefix = opts.alias ?? kind;\n    nodeCountsByPrefix[prefix] ??= 0;\n    return `${prefix}${++nodeCountsByPrefix[prefix]}`;\n};\nexport const parseNode = (id, kind, schema, $, opts) => {\n    const ctx = {\n        ...opts,\n        $,\n        args: opts.args ?? {},\n        schema,\n        id\n    };\n    return _parseNode(kind, ctx);\n};\nconst _parseNode = (kind, ctx) => {\n    const impl = nodeImplementationsByKind[kind];\n    const inner = {};\n    // ensure node entries are parsed in order of precedence, with non-children\n    // parsed first\n    const schemaEntries = entriesOf(ctx.schema).sort(([lKey], [rKey]) => isNodeKind(lKey) ?\n        isNodeKind(rKey) ? precedenceOfKind(lKey) - precedenceOfKind(rKey)\n            : 1\n        : isNodeKind(rKey) ? -1\n            : lKey < rKey ? -1\n                : 1);\n    const children = [];\n    for (const entry of schemaEntries) {\n        const k = entry[0];\n        const keyImpl = impl.keys[k];\n        if (!keyImpl)\n            return throwParseError(`Key ${k} is not valid on ${kind} schema`);\n        const v = keyImpl.parse ? keyImpl.parse(entry[1], ctx) : entry[1];\n        if (v !== unset && (v !== undefined || keyImpl.preserveUndefined))\n            inner[k] = v;\n    }\n    const entries = entriesOf(inner);\n    let json = {};\n    let typeJson = {};\n    entries.forEach(([k, v]) => {\n        const keyImpl = impl.keys[k];\n        const serialize = keyImpl.serialize ??\n            (keyImpl.child ? serializeListableChild : defaultValueSerializer);\n        json[k] = serialize(v);\n        if (keyImpl.child) {\n            const listableNode = v;\n            if (isArray(listableNode))\n                children.push(...listableNode);\n            else\n                children.push(listableNode);\n        }\n        if (!keyImpl.meta)\n            typeJson[k] = json[k];\n    });\n    if (impl.finalizeJson) {\n        json = impl.finalizeJson(json);\n        typeJson = impl.finalizeJson(typeJson);\n    }\n    let collapsibleJson = json;\n    const collapsibleKeys = Object.keys(collapsibleJson);\n    if (collapsibleKeys.length === 1 &&\n        collapsibleKeys[0] === impl.collapsibleKey) {\n        collapsibleJson = collapsibleJson[impl.collapsibleKey];\n        if (\n        // if the collapsibleJson is still an object\n        hasDomain(collapsibleJson, \"object\") &&\n            // and the JSON did not include any implied keys\n            Object.keys(json).length === 1) {\n            // we can replace it with its collapsed value\n            json = collapsibleJson;\n            typeJson = collapsibleJson;\n        }\n    }\n    const innerHash = JSON.stringify({ kind, ...json });\n    if (ctx.reduceTo) {\n        nodeCache[innerHash] = ctx.reduceTo;\n        return ctx.reduceTo;\n    }\n    const typeHash = JSON.stringify({ kind, ...typeJson });\n    if (impl.reduce && !ctx.prereduced) {\n        const reduced = impl.reduce(inner, ctx.$);\n        if (reduced) {\n            if (reduced instanceof Disjoint)\n                return reduced.throw();\n            // if we're defining the resolution of an alias and the result is\n            // reduced to another node, add the alias to that node if it doesn't\n            // already have one.\n            if (ctx.alias)\n                reduced.alias ??= ctx.alias;\n            // we can't cache this reduction for now in case the reduction involved\n            // impliedSiblings\n            return reduced;\n        }\n    }\n    // we have to wait until after reduction to return a cached entry,\n    // since reduction can add impliedSiblings\n    if (nodeCache[innerHash])\n        return nodeCache[innerHash];\n    const attachments = {\n        id: ctx.id,\n        kind,\n        impl,\n        inner,\n        entries,\n        json: json,\n        typeJson: typeJson,\n        collapsibleJson: collapsibleJson,\n        children,\n        innerHash,\n        typeHash\n    };\n    if (ctx.alias)\n        attachments.alias = ctx.alias;\n    for (const k in inner) {\n        if (k !== \"description\" && k !== \"in\" && k !== \"out\")\n            attachments[k] = inner[k];\n    }\n    const node = new nodeClassesByKind[kind](attachments, ctx.$);\n    return (nodeCache[innerHash] = node);\n};\n", "import { CompiledFunction } from \"@ark/util\";\nexport class NodeCompiler extends CompiledFunction {\n    traversalKind;\n    path = [];\n    discriminants = [];\n    constructor(traversalKind) {\n        super(\"data\", \"ctx\");\n        this.traversalKind = traversalKind;\n    }\n    invoke(node, opts) {\n        const arg = opts?.arg ?? this.data;\n        if (this.requiresContextFor(node))\n            return `${this.reference(node, opts)}(${arg}, ${this.ctx})`;\n        return `${this.reference(node, opts)}(${arg})`;\n    }\n    reference(node, opts) {\n        const invokedKind = opts?.kind ?? this.traversalKind;\n        const base = `this.${node.id}${invokedKind}`;\n        return opts?.bind ? `${base}.bind(${opts?.bind})` : base;\n    }\n    requiresContextFor(node) {\n        return this.traversalKind === \"Apply\" || node.allowsRequiresContext;\n    }\n    initializeErrorCount() {\n        return this.const(\"errorCount\", \"ctx.currentErrorCount\");\n    }\n    returnIfFail() {\n        return this.if(\"ctx.currentErrorCount > errorCount\", () => this.return());\n    }\n    returnIfFailFast() {\n        return this.if(\"ctx.failFast && ctx.currentErrorCount > errorCount\", () => this.return());\n    }\n    traverseKey(keyExpression, accessExpression, node) {\n        const requiresContext = this.requiresContextFor(node);\n        if (requiresContext)\n            this.line(`${this.ctx}.path.push(${keyExpression})`);\n        this.check(node, {\n            arg: accessExpression\n        });\n        if (requiresContext)\n            this.line(`${this.ctx}.path.pop()`);\n        return this;\n    }\n    check(node, opts) {\n        return this.traversalKind === \"Allows\" ?\n            this.if(`!${this.invoke(node, opts)}`, () => this.return(false))\n            : this.line(this.invoke(node, opts));\n    }\n    writeMethod(name) {\n        return `${name}(${this.argNames.join(\", \")}){\\n${this.body}    }\\n`;\n    }\n}\n", "var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { CompiledFunction, DynamicBase, ParseError, bound, flatMorph, hasDomain, isArray, printable, throwInternalError, throwParseError } from \"@ark/util\";\nimport { resolveConfig } from \"./config.js\";\nimport { LazyGenericRoot, parseGeneric } from \"./generic.js\";\nimport { nodeImplementationsByKind } from \"./kinds.js\";\nimport { RootModule } from \"./module.js\";\nimport { parseNode, registerNodeId, schemaKindOf } from \"./parse.js\";\nimport { normalizeAliasSchema } from \"./roots/alias.js\";\nimport { NodeCompiler } from \"./shared/compile.js\";\nimport { arkKind, hasArkKind, isNode } from \"./shared/utils.js\";\nconst schemaBranchesOf = (schema) => isArray(schema) ? schema\n    : \"branches\" in schema && isArray(schema.branches) ? schema.branches\n        : undefined;\nconst throwMismatchedNodeRootError = (expected, actual) => throwParseError(`Node of kind ${actual} is not valid as a ${expected} definition`);\nexport const writeDuplicateAliasError = (alias) => `#${alias} duplicates public alias ${alias}`;\nconst scopesById = {};\n$ark.intrinsic = {};\nlet RawRootScope = (() => {\n    let _instanceExtraInitializers = [];\n    let _schema_decorators;\n    let _defineRoot_decorators;\n    let _generic_decorators;\n    let _units_decorators;\n    let _node_decorators;\n    return class RawRootScope {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(null) : void 0;\n            _schema_decorators = [bound];\n            _defineRoot_decorators = [bound];\n            _generic_decorators = [bound];\n            _units_decorators = [bound];\n            _node_decorators = [bound];\n            __esDecorate(this, null, _schema_decorators, { kind: \"method\", name: \"schema\", static: false, private: false, access: { has: obj => \"schema\" in obj, get: obj => obj.schema }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _defineRoot_decorators, { kind: \"method\", name: \"defineRoot\", static: false, private: false, access: { has: obj => \"defineRoot\" in obj, get: obj => obj.defineRoot }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _generic_decorators, { kind: \"method\", name: \"generic\", static: false, private: false, access: { has: obj => \"generic\" in obj, get: obj => obj.generic }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _units_decorators, { kind: \"method\", name: \"units\", static: false, private: false, access: { has: obj => \"units\" in obj, get: obj => obj.units }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _node_decorators, { kind: \"method\", name: \"node\", static: false, private: false, access: { has: obj => \"node\" in obj, get: obj => obj.node }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        config = __runInitializers(this, _instanceExtraInitializers);\n        resolvedConfig;\n        id = `${Object.keys(scopesById).length}$`;\n        [arkKind] = \"scope\";\n        referencesById = {};\n        references = [];\n        resolutions = {};\n        json = {};\n        exportedNames = [];\n        aliases = {};\n        resolved = false;\n        constructor(\n        /** The set of names defined at the root-level of the scope mapped to their\n         * corresponding definitions.**/\n        def, config) {\n            this.config = config ?? {};\n            this.resolvedConfig = resolveConfig(config);\n            const aliasEntries = Object.entries(def).map(entry => this.preparseAlias(...entry));\n            aliasEntries.forEach(([k, v]) => {\n                if (k[0] === \"#\") {\n                    const name = k.slice(1);\n                    if (name in this.aliases)\n                        throwParseError(writeDuplicateAliasError(name));\n                    this.aliases[name] = v;\n                }\n                else {\n                    if (k in this.aliases)\n                        throwParseError(writeDuplicateAliasError(k));\n                    this.aliases[k] = v;\n                    this.exportedNames.push(k);\n                }\n            });\n            if ($ark.ambient) {\n                // ensure exportedResolutions is populated\n                $ark.ambient.export();\n                this.resolutions = {};\n            }\n            scopesById[this.id] = this;\n        }\n        get internal() {\n            return this;\n        }\n        schema(def, opts) {\n            return this.node(schemaKindOf(def), def, opts);\n        }\n        defineRoot(def) {\n            return def;\n        }\n        generic(params, def) {\n            if (def === undefined) {\n                return (def) => this.generic(params, new LazyGenericRoot(def));\n            }\n            return parseGeneric(params, def, this);\n        }\n        units(values, opts) {\n            const uniqueValues = [];\n            for (const value of values)\n                if (!uniqueValues.includes(value))\n                    uniqueValues.push(value);\n            const branches = uniqueValues.map(unit => this.node(\"unit\", { unit }, opts));\n            return this.node(\"union\", branches, {\n                ...opts,\n                prereduced: true\n            });\n        }\n        lazyResolutions = [];\n        lazilyResolve(resolve, syntheticAlias) {\n            const node = this.node(\"alias\", {\n                alias: syntheticAlias ?? \"synthetic\",\n                resolve\n            }, { prereduced: true });\n            if (!this.resolved)\n                this.lazyResolutions.push(node);\n            return node;\n        }\n        node(kinds, nodeSchema, opts = {}) {\n            let kind = typeof kinds === \"string\" ? kinds : schemaKindOf(nodeSchema, kinds);\n            let schema = nodeSchema;\n            if (isNode(schema) && schema.kind === kind)\n                return schema.bindScope(this);\n            if (kind === \"alias\" && !opts?.prereduced) {\n                const resolution = this.resolveRoot(normalizeAliasSchema(schema).alias);\n                schema = resolution;\n                kind = resolution.kind;\n            }\n            else if (kind === \"union\" && hasDomain(schema, \"object\")) {\n                const branches = schemaBranchesOf(schema);\n                if (branches?.length === 1) {\n                    schema = branches[0];\n                    kind = schemaKindOf(schema);\n                }\n            }\n            const impl = nodeImplementationsByKind[kind];\n            const normalizedSchema = impl.normalize?.(schema) ?? schema;\n            // check again after normalization in case a node is a valid collapsed\n            // schema for the kind (e.g. sequence can collapse to element accepting a Node)\n            if (isNode(normalizedSchema)) {\n                return normalizedSchema.kind === kind ?\n                    normalizedSchema.bindScope(this)\n                    : throwMismatchedNodeRootError(kind, normalizedSchema.kind);\n            }\n            const id = registerNodeId(kind, opts);\n            const node = parseNode(id, kind, normalizedSchema, this, opts ?? {}).bindScope(this);\n            if (this.resolved) {\n                // this node was not part of the original scope, so compile an anonymous scope\n                // including only its references\n                if (!this.resolvedConfig.jitless)\n                    bindCompiledScope(node.references);\n            }\n            else {\n                // we're still parsing the scope itself, so defer compilation but\n                // add the node as a reference\n                Object.assign(this.referencesById, node.referencesById);\n            }\n            return node;\n        }\n        finalizeRootArgs(opts, resolve) {\n            const isResolution = opts.alias && opts.alias in this.aliases;\n            // if the definition being parsed is not a scope alias and is not a\n            // generic instantiation (i.e. opts don't include args), add this as a resolution.\n            // TODO: this.lazilyResolve(resolve)\n            resolve;\n            if (!isResolution)\n                opts.args ??= { this: $ark.intrinsic.unknown };\n            return opts;\n        }\n        parseRoot(def, opts = {}) {\n            const node = this.schema(def, this.finalizeRootArgs(opts, () => node));\n            return node;\n        }\n        resolveRoot(name) {\n            return (this.maybeResolveRoot(name) ??\n                throwParseError(writeUnresolvableMessage(name)));\n        }\n        maybeResolveRoot(name) {\n            const result = this.maybeResolveGenericOrRoot(name);\n            if (hasArkKind(result, \"generic\"))\n                return;\n            return result;\n        }\n        maybeResolveGenericOrRoot(name) {\n            const resolution = this.maybeResolve(name);\n            if (hasArkKind(resolution, \"module\"))\n                return throwParseError(writeMissingSubmoduleAccessMessage(name));\n            return resolution;\n        }\n        preparseRoot(def) {\n            return def;\n        }\n        preparseAlias(k, v) {\n            return [k, v];\n        }\n        maybeResolve(name) {\n            const resolution = this.maybeShallowResolve(name);\n            return typeof resolution === \"string\" ?\n                this.node(\"alias\", { alias: resolution }, { prereduced: true })\n                : resolution;\n        }\n        maybeShallowResolve(name) {\n            const cached = this.resolutions[name];\n            if (cached)\n                return cached;\n            const def = this.aliases[name] ?? $ark.ambient?.resolutions[name];\n            if (!def)\n                return this.maybeResolveSubalias(name);\n            const preparsed = this.preparseRoot(def);\n            if (hasArkKind(preparsed, \"generic\")) {\n                return (this.resolutions[name] = preparsed\n                    .validateBaseInstantiation()\n                    ?.bindScope(this));\n            }\n            if (hasArkKind(preparsed, \"module\")) {\n                return (this.resolutions[name] = new RootModule(flatMorph(preparsed, (alias, node) => [\n                    alias,\n                    node.bindScope(this)\n                ])));\n            }\n            this.resolutions[name] = name;\n            return (this.resolutions[name] = this.parseRoot(preparsed, {\n                alias: name\n            }).bindScope(this));\n        }\n        /** If name is a valid reference to a submodule alias, return its resolution  */\n        maybeResolveSubalias(name) {\n            return maybeResolveSubalias(this.aliases, name);\n        }\n        import(...names) {\n            return new RootModule(flatMorph(this.export(...names), (alias, value) => [\n                `#${alias}`,\n                value\n            ]));\n        }\n        _exportedResolutions;\n        _exports;\n        export(...names) {\n            if (!this._exports) {\n                this._exports = {};\n                for (const name of this.exportedNames) {\n                    const resolution = this.maybeResolve(name);\n                    if (hasArkKind(resolution, \"root\")) {\n                        resolution.references\n                            .filter(node => node.hasKind(\"alias\"))\n                            .forEach(aliasNode => {\n                            Object.assign(aliasNode.referencesById, aliasNode.resolution.referencesById);\n                            resolution.references.forEach(ref => {\n                                if (aliasNode.id in ref.referencesById)\n                                    Object.assign(ref.referencesById, aliasNode.referencesById);\n                            });\n                        });\n                    }\n                    this._exports[name] = resolution;\n                }\n                this.lazyResolutions.forEach(node => node.resolution);\n                this._exportedResolutions = resolutionsOfModule(this, this._exports);\n                // TODO: add generic json\n                Object.assign(this.json, flatMorph(this._exportedResolutions, (k, v) => hasArkKind(v, \"root\") ? [k, v.json] : []));\n                Object.assign(this.resolutions, this._exportedResolutions);\n                if (this.config.intrinsic)\n                    Object.assign($ark.intrinsic, this._exportedResolutions);\n                this.references = Object.values(this.referencesById);\n                if (!this.resolvedConfig.jitless)\n                    bindCompiledScope(this.references);\n                this.resolved = true;\n            }\n            const namesToExport = names.length ? names : this.exportedNames;\n            return new RootModule(flatMorph(namesToExport, (_, name) => [\n                name,\n                this._exports[name]\n            ]));\n        }\n        resolve(name) {\n            return this.export()[name];\n        }\n    };\n})();\nexport { RawRootScope };\nconst maybeResolveSubalias = (base, name) => {\n    const dotIndex = name.indexOf(\".\");\n    if (dotIndex === -1)\n        return;\n    const dotPrefix = name.slice(0, dotIndex);\n    const prefixSchema = base[dotPrefix];\n    // if the name includes \".\", but the prefix is not an alias, it\n    // might be something like a decimal literal, so just fall through to return\n    if (prefixSchema === undefined)\n        return;\n    if (!hasArkKind(prefixSchema, \"module\"))\n        return throwParseError(writeNonSubmoduleDotMessage(dotPrefix));\n    const subalias = name.slice(dotIndex + 1);\n    const resolution = prefixSchema[subalias];\n    if (resolution === undefined)\n        return;\n    if (hasArkKind(resolution, \"module\"))\n        return maybeResolveSubalias(resolution, subalias);\n    if (hasArkKind(resolution, \"root\") || hasArkKind(resolution, \"generic\"))\n        return resolution;\n    throwInternalError(`Unexpected resolution for alias '${name}': ${printable(resolution)}`);\n};\nexport const schemaScope = (aliases, config) => new RootScope(aliases, config);\nexport const RootScope = RawRootScope;\nexport const root = new RootScope({});\nexport const schema = root.schema;\nexport const node = root.node;\nexport const defineRoot = root.defineRoot;\nexport const units = root.units;\nexport const generic = root.generic;\nexport const internalSchema = root.internal.schema;\nexport const internalNode = root.internal.node;\nexport const defineInternalRoot = root.internal.defineRoot;\nexport const internalUnits = root.internal.units;\nexport const internalGeneric = root.internal.generic;\nexport const parseAsSchema = (def, opts) => {\n    try {\n        return schema(def, opts);\n    }\n    catch (e) {\n        if (e instanceof ParseError)\n            return e;\n        throw e;\n    }\n};\nexport class RawRootModule extends DynamicBase {\n}\nconst resolutionsOfModule = ($, typeSet) => {\n    const result = {};\n    for (const k in typeSet) {\n        const v = typeSet[k];\n        if (hasArkKind(v, \"module\")) {\n            const innerResolutions = resolutionsOfModule($, v);\n            const prefixedResolutions = flatMorph(innerResolutions, (innerK, innerV) => [`${k}.${innerK}`, innerV]);\n            Object.assign(result, prefixedResolutions);\n        }\n        else if (hasArkKind(v, \"generic\"))\n            result[k] = v;\n        else if (hasArkKind(v, \"root\"))\n            result[k] = v;\n        else\n            throwInternalError(`Unexpected scope resolution ${printable(v)}`);\n    }\n    return result;\n};\nexport const writeUnresolvableMessage = (token) => `'${token}' is unresolvable`;\nexport const writeNonSubmoduleDotMessage = (name) => `'${name}' must reference a module to be accessed using dot syntax`;\nexport const writeMissingSubmoduleAccessMessage = (name) => `Reference to submodule '${name}' must specify an alias`;\nexport const bindCompiledScope = (references) => {\n    const compiledTraversals = compileScope(references);\n    for (const node of references) {\n        if (node.jit) {\n            // if node has already been bound to another scope or anonymous type, don't rebind it\n            continue;\n        }\n        node.jit = true;\n        node.traverseAllows =\n            compiledTraversals[`${node.id}Allows`].bind(compiledTraversals);\n        if (node.isRoot() && !node.allowsRequiresContext) {\n            // if the reference doesn't require context, we can assign over\n            // it directly to avoid having to initialize it\n            node.allows = node.traverseAllows;\n        }\n        node.traverseApply =\n            compiledTraversals[`${node.id}Apply`].bind(compiledTraversals);\n    }\n};\nconst compileScope = (references) => new CompiledFunction()\n    .block(\"return\", js => {\n    references.forEach(node => {\n        const allowsCompiler = new NodeCompiler(\"Allows\").indent();\n        node.compile(allowsCompiler);\n        const applyCompiler = new NodeCompiler(\"Apply\").indent();\n        node.compile(applyCompiler);\n        js.line(`${allowsCompiler.writeMethod(`${node.id}Allows`)},`).line(`${applyCompiler.writeMethod(`${node.id}Apply`)},`);\n    });\n    return js;\n})\n    .compile()();\n", "import { schemaScope } from \"../scope.js\";\nexport const tsKeywords = schemaScope({\n    any: {},\n    bigint: \"bigint\",\n    // since we know this won't be reduced, it can be safely cast to a union\n    boolean: [{ unit: false }, { unit: true }],\n    false: { unit: false },\n    never: [],\n    null: { unit: null },\n    number: \"number\",\n    object: \"object\",\n    string: \"string\",\n    symbol: \"symbol\",\n    true: { unit: true },\n    unknown: {},\n    void: { unit: undefined },\n    undefined: { unit: undefined }\n}, { prereducedAliases: true, intrinsic: true }).export();\n", "import { root, schemaScope } from \"../scope.js\";\n// these are needed to create some internal types\nimport { arrayIndexSource } from \"../structure/shared.js\";\nimport \"./tsKeywords.js\";\nexport const internal = schemaScope({\n    lengthBoundable: [\"string\", Array],\n    propertyKey: [\"string\", \"symbol\"],\n    nonNegativeIntegerString: { domain: \"string\", pattern: arrayIndexSource }\n}, {\n    prereducedAliases: true,\n    intrinsic: true\n}).export();\n// reduce union of all possible values reduces to unknown\nroot.node(\"union\", {\n    branches: [\n        \"string\",\n        \"number\",\n        \"object\",\n        \"bigint\",\n        \"symbol\",\n        { unit: true },\n        { unit: false },\n        { unit: null },\n        { unit: undefined }\n    ]\n}, { reduceTo: root.node(\"intersection\", {}, { prereduced: true }) });\n", "import { schemaScope } from \"../scope.js\";\nexport const jsObjects = schemaScope({\n    Array,\n    Function,\n    Date,\n    Error,\n    Map,\n    RegExp,\n    Set,\n    WeakMap,\n    WeakSet,\n    Promise\n}, { prereducedAliases: true, intrinsic: true }).export();\n", "import { defineRoot, schemaScope } from \"../scope.js\";\nconst trim = defineRoot({\n    in: \"string\",\n    morphs: (s) => s.trim()\n});\nconst uppercase = defineRoot({\n    in: \"string\",\n    morphs: (s) => s.toUpperCase()\n});\nconst lowercase = defineRoot({\n    in: \"string\",\n    morphs: (s) => s.toLowerCase()\n});\nexport const formatting = schemaScope({\n    trim,\n    uppercase,\n    lowercase\n}).export();\n", "const dayDelimiterMatcher = /^[./-]$/;\n// ISO 8601 date/time modernized from https://github.com/validatorjs/validator.js/blob/master/src/lib/isISO8601.js\n// Based on https://tc39.es/ecma262/#sec-date-time-string-format, the T\n// delimiter for date/time is mandatory. Regex from validator.js strict matcher:\nconst iso8601Matcher = /^([+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([.,]\\d+(?!:))?)?(\\17[0-5]\\d([.,]\\d+)?)?([zZ]|([+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\nconst isValidDateInstance = (date) => !Number.isNaN(+date);\nconst writeFormattedExpected = (format) => `a ${format}-formatted date`;\nexport const tryParseDatePattern = (data, opts) => {\n    if (!opts?.format) {\n        const result = new Date(data);\n        return isValidDateInstance(result) ? result : \"a valid date\";\n    }\n    if (opts.format === \"iso8601\") {\n        return iso8601Matcher.test(data) ?\n            new Date(data)\n            : writeFormattedExpected(\"iso8601\");\n    }\n    const dataParts = data.split(dayDelimiterMatcher);\n    // will be the first delimiter matched, if there is one\n    const delimiter = data[dataParts[0].length];\n    const formatParts = delimiter ? opts.format.split(delimiter) : [opts.format];\n    if (dataParts.length !== formatParts.length)\n        return writeFormattedExpected(opts.format);\n    const parsedParts = {};\n    for (let i = 0; i < formatParts.length; i++) {\n        if (dataParts[i].length !== formatParts[i].length &&\n            // if format is \"m\" or \"d\", data is allowed to be 1 or 2 characters\n            !(formatParts[i].length === 1 && dataParts[i].length === 2))\n            return writeFormattedExpected(opts.format);\n        parsedParts[formatParts[i][0]] = dataParts[i];\n    }\n    const date = new Date(`${parsedParts.m}/${parsedParts.d}/${parsedParts.y}`);\n    if (`${date.getDate()}` === parsedParts.d)\n        return date;\n    return writeFormattedExpected(opts.format);\n};\n", "import { defineRoot } from \"../../scope.js\";\nexport const defineRegex = (regex, description) => defineRoot({\n    domain: \"string\",\n    pattern: {\n        rule: regex.source,\n        flags: regex.flags,\n        description\n    }\n});\n", "import { isWellFormedInteger, wellFormedIntegerMatcher, wellFormedNumberMatcher } from \"@ark/util\";\nimport { defineRoot, schemaScope } from \"../scope.js\";\nimport { tryParseDatePattern } from \"./utils/date.js\";\nimport { defineRegex } from \"./utils/regex.js\";\nconst number = defineRoot({\n    in: defineRegex(wellFormedNumberMatcher, \"a well-formed numeric string\"),\n    morphs: (s) => Number.parseFloat(s)\n});\nconst integer = defineRoot({\n    in: defineRegex(wellFormedIntegerMatcher, \"a well-formed integer string\"),\n    morphs: (s, ctx) => {\n        if (!isWellFormedInteger(s))\n            return ctx.error(\"a well-formed integer string\");\n        const parsed = Number.parseInt(s);\n        return Number.isSafeInteger(parsed) ? parsed : (ctx.error(\"an integer in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER\"));\n    }\n});\nconst url = defineRoot({\n    in: \"string\",\n    morphs: (s, ctx) => {\n        try {\n            return new URL(s);\n        }\n        catch {\n            return ctx.error(\"a valid URL\");\n        }\n    }\n});\nconst json = defineRoot({\n    in: \"string\",\n    morphs: (s, ctx) => {\n        try {\n            return JSON.parse(s);\n        }\n        catch {\n            return ctx.error(\"a valid JSON string\");\n        }\n    }\n});\nconst date = defineRoot({\n    in: \"string\",\n    morphs: (s, ctx) => {\n        const result = tryParseDatePattern(s);\n        return typeof result === \"string\" ? ctx.error(result) : result;\n    }\n});\nexport const parsing = schemaScope({\n    url,\n    number,\n    integer,\n    date,\n    json\n}).export();\n", "import { generic, schemaScope } from \"../scope.js\";\nconst $ = schemaScope({\n    Record: generic([[\"K\", $ark.intrinsic.propertyKey], \"V\"])(args => ({\n        domain: \"object\",\n        index: {\n            signature: args.K,\n            value: args.V\n        }\n    }))\n});\nexport const tsGenerics = $.export();\n", "// https://github.com/validatorjs/validator.js/blob/master/src/lib/isLuhnNumber.js\nexport const isLuhnValid = (creditCardInput) => {\n    const sanitized = creditCardInput.replace(/[- ]+/g, \"\");\n    let sum = 0;\n    let digit;\n    let tmpNum;\n    let shouldDouble = false;\n    for (let i = sanitized.length - 1; i >= 0; i--) {\n        digit = sanitized.substring(i, i + 1);\n        tmpNum = Number.parseInt(digit, 10);\n        if (shouldDouble) {\n            tmpNum *= 2;\n            if (tmpNum >= 10)\n                sum += (tmpNum % 10) + 1;\n            else\n                sum += tmpNum;\n        }\n        else\n            sum += tmpNum;\n        shouldDouble = !shouldDouble;\n    }\n    return !!(sum % 10 === 0 ? sanitized : false);\n};\n// https://github.com/validatorjs/validator.js/blob/master/src/lib/isCreditCard.js\nexport const creditCardMatcher = /^(?:4[0-9]{12}(?:[0-9]{3,6})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12,15}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11}|6[27][0-9]{14}|^(81[0-9]{14,17}))$/;\n", "import { defineRoot } from \"../../scope.js\";\nimport { defineRegex } from \"./regex.js\";\n// Based on https://github.com/validatorjs/validator.js/blob/master/src/lib/isIP.js\nconst ipv4Segment = \"(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\";\nconst ipv4Address = `(${ipv4Segment}[.]){3}${ipv4Segment}`;\nconst ipv4Matcher = new RegExp(`^${ipv4Address}$`);\nexport const ipv4 = defineRegex(ipv4Matcher, \"a valid IPv4 address\");\nconst ipv6Segment = \"(?:[0-9a-fA-F]{1,4})\";\nconst ipv6Matcher = new RegExp(\"^(\" +\n    `(?:${ipv6Segment}:){7}(?:${ipv6Segment}|:)|` +\n    `(?:${ipv6Segment}:){6}(?:${ipv4Address}|:${ipv6Segment}|:)|` +\n    `(?:${ipv6Segment}:){5}(?::${ipv4Address}|(:${ipv6Segment}){1,2}|:)|` +\n    `(?:${ipv6Segment}:){4}(?:(:${ipv6Segment}){0,1}:${ipv4Address}|(:${ipv6Segment}){1,3}|:)|` +\n    `(?:${ipv6Segment}:){3}(?:(:${ipv6Segment}){0,2}:${ipv4Address}|(:${ipv6Segment}){1,4}|:)|` +\n    `(?:${ipv6Segment}:){2}(?:(:${ipv6Segment}){0,3}:${ipv4Address}|(:${ipv6Segment}){1,5}|:)|` +\n    `(?:${ipv6Segment}:){1}(?:(:${ipv6Segment}){0,4}:${ipv4Address}|(:${ipv6Segment}){1,6}|:)|` +\n    `(?::((?::${ipv6Segment}){0,5}:${ipv4Address}|(?::${ipv6Segment}){1,7}|:))` +\n    \")(%[0-9a-zA-Z-.:]{1,})?$\");\nexport const ipv6 = defineRegex(ipv6Matcher, \"a valid IPv6 address\");\nexport const ip = defineRoot([ipv4, ipv6]);\n", "import { defineRoot, schemaScope } from \"../scope.js\";\nimport { creditCardMatcher, isLuhnValid } from \"./utils/creditCard.js\";\nimport { ip } from \"./utils/ip.js\";\nimport { defineRegex } from \"./utils/regex.js\";\n// Non-trivial expressions should have an explanation or attribution\nconst url = defineRoot({\n    domain: \"string\",\n    predicate: {\n        predicate: (s) => {\n            try {\n                new URL(s);\n            }\n            catch {\n                return false;\n            }\n            return true;\n        },\n        description: \"a valid URL\"\n    }\n});\n// https://www.regular-expressions.info/email.html\nconst emailMatcher = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$/;\nconst email = defineRegex(emailMatcher, \"a valid email\");\nconst uuidMatcher = /^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$/;\n// https://github.com/validatorjs/validator.js/blob/master/src/lib/isUUID.js\nconst uuid = defineRegex(uuidMatcher, \"a valid UUID\");\nconst semverMatcher = /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n// https://semver.org/\nconst semver = defineRegex(semverMatcher, \"a valid semantic version (see https://semver.org/)\");\nconst creditCard = defineRoot({\n    domain: \"string\",\n    pattern: {\n        rule: creditCardMatcher.source,\n        description: \"a valid credit card number\"\n    },\n    predicate: {\n        predicate: isLuhnValid,\n        description: \"a valid credit card number\"\n    }\n});\nexport const validation = schemaScope({\n    alpha: defineRegex(/^[A-Za-z]*$/, \"only letters\"),\n    alphanumeric: defineRegex(/^[A-Za-z\\d]*$/, \"only letters and digits 0-9\"),\n    digits: defineRegex(/^\\d*$/, \"only digits 0-9\"),\n    lowercase: defineRegex(/^[a-z]*$/, \"only lowercase letters\"),\n    uppercase: defineRegex(/^[A-Z]*$/, \"only uppercase letters\"),\n    creditCard,\n    email,\n    uuid,\n    url,\n    semver,\n    ip,\n    integer: {\n        domain: \"number\",\n        divisor: 1\n    }\n}, { prereducedAliases: true }).export();\n", "import { schemaScope } from \"../scope.js\";\n// the import ordering here is important so builtin keywords can be resolved\n// and used to bootstrap nodes with constraints\nimport { tsKeywords } from \"./tsKeywords.js\";\nimport { formatting } from \"./format.js\";\nimport { internal } from \"./internal.js\";\nimport { jsObjects } from \"./jsObjects.js\";\nimport { parsing } from \"./parsing.js\";\nimport { tsGenerics } from \"./tsGenerics.js\";\nimport { validation } from \"./validation.js\";\nexport const ambientRootScope = schemaScope({\n    ...tsKeywords,\n    ...jsObjects,\n    ...validation,\n    ...internal,\n    ...tsGenerics,\n    parse: parsing,\n    format: formatting\n    // TODO: remove cast\n});\n$ark.ambient = ambientRootScope.internal;\nexport const keywordNodes = ambientRootScope.export();\n", "import { throwParseError, tryParseNumber } from \"@ark/util\";\nexport const isDateLiteral = (value) => typeof value === \"string\" &&\n    value[0] === \"d\" &&\n    (value[1] === \"'\" || value[1] === '\"') &&\n    value.at(-1) === value[1];\nexport const isValidDate = (d) => d.toString() !== \"Invalid Date\";\nexport const extractDateLiteralSource = (literal) => literal.slice(2, -1);\nexport const writeInvalidDateMessage = (source) => `'${source}' could not be parsed by the Date constructor`;\nexport const tryParseDate = (source, errorOnFail) => maybeParseDate(source, errorOnFail);\nconst maybeParseDate = (source, errorOnFail) => {\n    const stringParsedDate = new Date(source);\n    if (isValidDate(stringParsedDate))\n        return stringParsedDate;\n    const epochMillis = tryParseNumber(source);\n    if (epochMillis !== undefined) {\n        const numberParsedDate = new Date(epochMillis);\n        if (isValidDate(numberParsedDate))\n            return numberParsedDate;\n    }\n    return errorOnFail ?\n        throwParseError(errorOnFail === true ? writeInvalidDateMessage(source) : errorOnFail)\n        : undefined;\n};\n", "import { isKeyOf } from \"@ark/util\";\nimport { tryParseDate, writeInvalidDateMessage } from \"./date.js\";\nexport const parseEnclosed = (s, enclosing) => {\n    const enclosed = s.scanner.shiftUntil(untilLookaheadIsClosing[enclosingTokens[enclosing]]);\n    if (s.scanner.lookahead === \"\")\n        return s.error(writeUnterminatedEnclosedMessage(enclosed, enclosing));\n    // Shift the scanner one additional time for the second enclosing token\n    s.scanner.shift();\n    if (enclosing === \"/\") {\n        // fail parsing if the regex is invalid\n        new RegExp(enclosed);\n        s.root = s.ctx.$.node(\"intersection\", {\n            domain: \"string\",\n            pattern: enclosed\n        }, { prereduced: true });\n    }\n    else if (isKeyOf(enclosing, enclosingQuote))\n        s.root = s.ctx.$.node(\"unit\", { unit: enclosed });\n    else {\n        const date = tryParseDate(enclosed, writeInvalidDateMessage(enclosed));\n        s.root = s.ctx.$.node(\"unit\", { unit: date, description: enclosed });\n    }\n};\nexport const enclosingQuote = {\n    \"'\": 1,\n    '\"': 1\n};\nexport const enclosingChar = {\n    \"/\": 1,\n    \"'\": 1,\n    '\"': 1\n};\nexport const enclosingTokens = {\n    \"d'\": \"'\",\n    'd\"': '\"',\n    \"'\": \"'\",\n    '\"': '\"',\n    \"/\": \"/\"\n};\nexport const untilLookaheadIsClosing = {\n    \"'\": scanner => scanner.lookahead === `'`,\n    '\"': scanner => scanner.lookahead === `\"`,\n    \"/\": scanner => scanner.lookahead === `/`\n};\nconst enclosingCharDescriptions = {\n    '\"': \"double-quote\",\n    \"'\": \"single-quote\",\n    \"/\": \"forward slash\"\n};\nexport const writeUnterminatedEnclosedMessage = (fragment, enclosingStart) => `${enclosingStart}${fragment} requires a closing ${enclosingCharDescriptions[enclosingTokens[enclosingStart]]}`;\n", "export const writeUnsatisfiableExpressionError = (expression) => `${expression} results in an unsatisfiable type`;\nexport const writePrefixedPrivateReferenceMessage = (def) => `Private type references should not include '#'. Use '${def.slice(1)}' instead.`;\n", "export const minComparators = {\n    \">\": true,\n    \">=\": true\n};\nexport const maxComparators = {\n    \"<\": true,\n    \"<=\": true\n};\nexport const comparators = {\n    \">\": true,\n    \">=\": true,\n    \"<\": true,\n    \"<=\": true,\n    \"==\": true\n};\nexport const invertedComparators = {\n    \"<\": \">\",\n    \">\": \"<\",\n    \"<=\": \">=\",\n    \">=\": \"<=\",\n    \"==\": \"==\"\n};\nexport const writeUnmatchedGroupCloseMessage = (unscanned) => `Unmatched )${(unscanned === \"\" ? \"\" : ` before ${unscanned}`)}`;\nexport const writeUnclosedGroupMessage = (missingChar) => `Missing ${missingChar}`;\nexport const writeOpenRangeMessage = (min, comparator) => `Left bounds are only valid when paired with right bounds (try ...${comparator}${min})`;\nexport const writeUnpairableComparatorMessage = (comparator) => `Left-bounded expressions must specify their limits using < or <= (was ${comparator})`;\nexport const writeMultipleLeftBoundsMessage = (openLimit, openComparator, limit, comparator) => `An expression may have at most one left bound (parsed ${openLimit}${invertedComparators[openComparator]}, ${limit}${invertedComparators[comparator]})`;\n", "import { writeUnclosedGroupMessage } from \"../../reduce/shared.js\";\nexport const parseGenericArgs = (name, g, s) => _parseGenericArgs(name, g, s, []);\nconst _parseGenericArgs = (name, g, s, argNodes) => {\n    const argState = s.parseUntilFinalizer();\n    argNodes.push(argState.root);\n    if (argState.finalizer === \">\") {\n        if (argNodes.length !== g.params.length) {\n            return s.error(writeInvalidGenericArgCountMessage(name, g.names, argNodes.map(arg => arg.expression)));\n        }\n        return argNodes;\n    }\n    if (argState.finalizer === \",\")\n        return _parseGenericArgs(name, g, s, argNodes);\n    return argState.error(writeUnclosedGroupMessage(\">\"));\n};\nexport const writeInvalidGenericArgCountMessage = (name, params, argDefs) => `${name}<${params.join(\", \")}> requires exactly ${params.length} args (got ${argDefs.length}${argDefs.length === 0 ? \"\" : `: ${argDefs.join(\", \")}`})`;\n", "import { BaseRoot, hasArkKind, writeUnresolvableMessage } from \"@ark/schema\";\nimport { printable, throwParseError, tryParseWellFormedBigint, tryParseWellFormedNumber } from \"@ark/util\";\nimport { writePrefixedPrivateReferenceMessage } from \"../../../semantic/validate.js\";\nimport { parseGenericArgs, writeInvalidGenericArgCountMessage } from \"./genericArgs.js\";\nexport const parseUnenclosed = (s) => {\n    const token = s.scanner.shiftUntilNextTerminator();\n    if (token === \"keyof\")\n        s.addPrefix(\"keyof\");\n    else\n        s.root = unenclosedToNode(s, token);\n};\nexport const parseGenericInstantiation = (name, g, s) => {\n    s.scanner.shiftUntilNonWhitespace();\n    const lookahead = s.scanner.shift();\n    if (lookahead !== \"<\")\n        return s.error(writeInvalidGenericArgCountMessage(name, g.names, []));\n    const parsedArgs = parseGenericArgs(name, g, s);\n    return g(...parsedArgs);\n};\nconst unenclosedToNode = (s, token) => maybeParseReference(s, token) ??\n    maybeParseUnenclosedLiteral(s, token) ??\n    s.error(token === \"\" ? writeMissingOperandMessage(s)\n        : token[0] === \"#\" ?\n            writePrefixedPrivateReferenceMessage(token)\n            : writeUnresolvableMessage(token));\nconst maybeParseReference = (s, token) => {\n    if (s.ctx.args?.[token])\n        return s.ctx.args[token].internal;\n    const resolution = s.ctx.$.maybeResolve(token);\n    if (resolution instanceof BaseRoot)\n        return resolution;\n    if (resolution === undefined)\n        return;\n    if (hasArkKind(resolution, \"generic\"))\n        return parseGenericInstantiation(token, resolution, s);\n    return throwParseError(`Unexpected resolution ${printable(resolution)}`);\n};\nconst maybeParseUnenclosedLiteral = (s, token) => {\n    const maybeNumber = tryParseWellFormedNumber(token);\n    if (maybeNumber !== undefined)\n        return s.ctx.$.node(\"unit\", { unit: maybeNumber });\n    const maybeBigint = tryParseWellFormedBigint(token);\n    if (maybeBigint !== undefined)\n        return s.ctx.$.node(\"unit\", { unit: maybeBigint });\n};\nexport const writeMissingOperandMessage = (s) => {\n    const operator = s.previousOperator();\n    return operator ?\n        writeMissingRightOperandMessage(operator, s.scanner.unscanned)\n        : writeExpressionExpectedMessage(s.scanner.unscanned);\n};\nexport const writeMissingRightOperandMessage = (token, unscanned = \"\") => `Token '${token}' requires a right operand${unscanned ? ` before '${unscanned}'` : \"\"}`;\nexport const writeExpressionExpectedMessage = (unscanned) => `Expected an expression${unscanned ? ` before '${unscanned}'` : \"\"}`;\n", "import { whiteSpaceTokens } from \"@ark/util\";\nimport { enclosingChar, enclosingQuote, parseEnclosed } from \"./enclosed.js\";\nimport { parseUnenclosed, writeMissingOperandMessage } from \"./unenclosed.js\";\nexport const parseOperand = (s) => s.scanner.lookahead === \"\" ? s.error(writeMissingOperandMessage(s))\n    : s.scanner.lookahead === \"(\" ? s.shiftedByOne().reduceGroupOpen()\n        : s.scanner.lookaheadIsIn(enclosingChar) ? parseEnclosed(s, s.scanner.shift())\n            : s.scanner.lookaheadIsIn(whiteSpaceTokens) ? parseOperand(s.shiftedByOne())\n                : s.scanner.lookahead === \"d\" ?\n                    s.scanner.nextLookahead in enclosingQuote ?\n                        parseEnclosed(s, `${s.scanner.shift()}${s.scanner.shift()}`)\n                        : parseUnenclosed(s)\n                    : parseUnenclosed(s);\n", "import { escapeToken, isKeyOf, whiteSpaceTokens } from \"@ark/util\";\nexport class Scanner {\n    chars;\n    i;\n    constructor(def) {\n        this.chars = [...def];\n        this.i = 0;\n    }\n    /** Get lookahead and advance scanner by one */\n    shift() {\n        return (this.chars[this.i++] ?? \"\");\n    }\n    get lookahead() {\n        return (this.chars[this.i] ?? \"\");\n    }\n    get nextLookahead() {\n        return this.chars[this.i + 1] ?? \"\";\n    }\n    get length() {\n        return this.chars.length;\n    }\n    shiftUntil(condition) {\n        let shifted = \"\";\n        while (this.lookahead) {\n            if (condition(this, shifted)) {\n                if (shifted[shifted.length - 1] === escapeToken)\n                    shifted = shifted.slice(0, -1);\n                else\n                    break;\n            }\n            shifted += this.shift();\n        }\n        return shifted;\n    }\n    shiftUntilNextTerminator() {\n        this.shiftUntilNonWhitespace();\n        return this.shiftUntil(Scanner.lookaheadIsTerminator);\n    }\n    shiftUntilNonWhitespace() {\n        return this.shiftUntil(Scanner.lookaheadIsNotWhitespace);\n    }\n    jumpToIndex(i) {\n        this.i = i < 0 ? this.length + i : i;\n    }\n    jumpForward(count) {\n        this.i += count;\n    }\n    get location() {\n        return this.i;\n    }\n    get unscanned() {\n        return this.chars.slice(this.i, this.length).join(\"\");\n    }\n    get scanned() {\n        return this.chars.slice(0, this.i).join(\"\");\n    }\n    sliceChars(start, end) {\n        return this.chars.slice(start, end).join(\"\");\n    }\n    lookaheadIs(char) {\n        return this.lookahead === char;\n    }\n    lookaheadIsIn(tokens) {\n        return this.lookahead in tokens;\n    }\n}\n(function (Scanner) {\n    Scanner.lookaheadIsTerminator = (scanner) => scanner.lookahead in Scanner.terminatingChars;\n    Scanner.lookaheadIsNotWhitespace = (scanner) => !(scanner.lookahead in whiteSpaceTokens);\n    Scanner.terminatingChars = {\n        \"<\": true,\n        \">\": true,\n        \"=\": true,\n        \"|\": true,\n        \"&\": true,\n        \")\": true,\n        \"[\": true,\n        \"%\": true,\n        \" \": true,\n        \",\": true,\n        \":\": true\n    };\n    Scanner.finalizingLookaheads = {\n        \">\": true,\n        \",\": true,\n        \"\": true,\n        \"=\": true\n    };\n    Scanner.lookaheadIsFinalizing = (lookahead, unscanned) => lookahead === \">\" ?\n        unscanned[0] === \"=\" ?\n            // >== would only occur in an expression like Array<number>==5\n            // otherwise, >= would only occur as part of a bound like number>=5\n            unscanned[1] === \"=\"\n            // if > is the end of a generic instantiation, the next token will be an operator or the end of the string\n            : unscanned.trimStart() === \"\" ||\n                isKeyOf(unscanned.trimStart()[0], Scanner.terminatingChars)\n        // \"=\" is a finalizer on its own (representing a default value),\n        // but not with a second \"=\" (an equality comparator)\n        : lookahead === \"=\" ? unscanned[0] !== \"=\"\n            // \",\"\" is unambiguously a finalizer\n            : lookahead === \",\";\n})(Scanner || (Scanner = {}));\n", "import { internal, jsObjects, tsKeywords, writeUnboundableMessage } from \"@ark/schema\";\nimport { isKeyOf, throwParseError } from \"@ark/util\";\nimport { invertedComparators, maxComparators, writeUnpairableComparatorMessage } from \"../../reduce/shared.js\";\nimport { extractDateLiteralSource, isDateLiteral } from \"../operand/date.js\";\nexport const parseBound = (s, start) => {\n    const comparator = shiftComparator(s, start);\n    if (s.root.hasKind(\"unit\")) {\n        if (typeof s.root.unit === \"number\") {\n            s.reduceLeftBound(s.root.unit, comparator);\n            s.unsetRoot();\n            return;\n        }\n        if (s.root.unit instanceof Date) {\n            const literal = `d'${s.root.description ?? s.root.unit.toISOString()}'`;\n            s.unsetRoot();\n            s.reduceLeftBound(literal, comparator);\n            return;\n        }\n    }\n    return parseRightBound(s, comparator);\n};\nconst oneCharComparators = {\n    \"<\": true,\n    \">\": true\n};\nexport const comparatorStartChars = {\n    \"<\": 1,\n    \">\": 1,\n    \"=\": 1\n};\nconst shiftComparator = (s, start) => s.scanner.lookaheadIs(\"=\") ?\n    `${start}${s.scanner.shift()}`\n    : start;\nexport const writeIncompatibleRangeMessage = (l, r) => `Bound kinds ${l} and ${r} are incompatible`;\nexport const getBoundKinds = (comparator, limit, root, boundKind) => {\n    if (root.extends(tsKeywords.number)) {\n        if (typeof limit !== \"number\") {\n            return throwParseError(writeInvalidLimitMessage(comparator, limit, boundKind));\n        }\n        return (comparator === \"==\" ? [\"min\", \"max\"]\n            : comparator[0] === \">\" ? [\"min\"]\n                : [\"max\"]);\n    }\n    if (root.extends(internal.lengthBoundable)) {\n        if (typeof limit !== \"number\") {\n            return throwParseError(writeInvalidLimitMessage(comparator, limit, boundKind));\n        }\n        return (comparator === \"==\" ? [\"minLength\", \"maxLength\"]\n            : comparator[0] === \">\" ? [\"minLength\"]\n                : [\"maxLength\"]);\n    }\n    if (root.extends(jsObjects.Date)) {\n        // allow either numeric or date limits\n        return (comparator === \"==\" ? [\"after\", \"before\"]\n            : comparator[0] === \">\" ? [\"after\"]\n                : [\"before\"]);\n    }\n    return throwParseError(writeUnboundableMessage(root.expression));\n};\nconst openLeftBoundToRoot = (leftBound) => ({\n    rule: isDateLiteral(leftBound.limit) ?\n        extractDateLiteralSource(leftBound.limit)\n        : leftBound.limit,\n    exclusive: leftBound.comparator.length === 1\n});\nexport const parseRightBound = (s, comparator) => {\n    // store the node that will be bounded\n    const previousRoot = s.unsetRoot();\n    const previousScannerIndex = s.scanner.location;\n    s.parseOperand();\n    const limitNode = s.unsetRoot();\n    // after parsing the next operand, use the locations to get the\n    // token from which it was parsed\n    const limitToken = s.scanner.sliceChars(previousScannerIndex, s.scanner.location);\n    s.root = previousRoot;\n    if (!limitNode.hasKind(\"unit\") ||\n        (typeof limitNode.unit !== \"number\" && !(limitNode.unit instanceof Date)))\n        return s.error(writeInvalidLimitMessage(comparator, limitToken, \"right\"));\n    const limit = limitNode.unit;\n    // apply the newly-parsed right bound\n    const exclusive = comparator.length === 1;\n    // if the comparator is ==, both the min and max of that pair will be applied\n    for (const kind of getBoundKinds(comparator, typeof limit === \"number\" ? limit : limitToken, previousRoot, \"right\"))\n        s.constrainRoot(kind, { rule: limit, exclusive });\n    if (!s.branches.leftBound)\n        return;\n    // if there's an open left bound, perform additional validation and apply it\n    if (!isKeyOf(comparator, maxComparators))\n        return s.error(writeUnpairableComparatorMessage(comparator));\n    const lowerBoundKind = getBoundKinds(s.branches.leftBound.comparator, s.branches.leftBound.limit, previousRoot, \"left\");\n    s.constrainRoot(lowerBoundKind[0], openLeftBoundToRoot(s.branches.leftBound));\n    s.branches.leftBound = null;\n};\nexport const writeInvalidLimitMessage = (comparator, limit, boundKind) => `Comparator ${boundKind === \"left\" ? invertedComparators[comparator] : comparator} must be ${boundKind === \"left\" ? \"preceded\" : \"followed\"} by a corresponding literal (was ${limit})`;\n", "import { tryParseInteger } from \"@ark/util\";\nexport const parseDivisor = (s) => {\n    const divisorToken = s.scanner.shiftUntilNextTerminator();\n    const divisor = tryParseInteger(divisorToken, {\n        errorOnFail: writeInvalidDivisorMessage(divisorToken)\n    });\n    if (divisor === 0)\n        s.error(writeInvalidDivisorMessage(0));\n    s.root = s.root.constrain(\"divisor\", divisor);\n};\nexport const writeInvalidDivisorMessage = (divisor) => `% operator must be followed by a non-zero integer literal (was ${divisor})`;\n", "import { isKeyOf } from \"@ark/util\";\nimport { Scanner } from \"../scanner.js\";\nimport { comparatorStartChars, parseBound } from \"./bounds.js\";\nimport { parseDivisor } from \"./divisor.js\";\nexport const parseOperator = (s) => {\n    const lookahead = s.scanner.shift();\n    return (lookahead === \"\" ? s.finalize(\"\")\n        : lookahead === \"[\" ?\n            s.scanner.shift() === \"]\" ?\n                s.setRoot(s.root.array())\n                : s.error(incompleteArrayTokenMessage)\n            : lookahead === \"|\" || lookahead === \"&\" ? s.pushRootToBranch(lookahead)\n                : lookahead === \")\" ? s.finalizeGroup()\n                    : Scanner.lookaheadIsFinalizing(lookahead, s.scanner.unscanned) ?\n                        s.finalize(lookahead)\n                        : isKeyOf(lookahead, comparatorStartChars) ? parseBound(s, lookahead)\n                            : lookahead === \"%\" ? parseDivisor(s)\n                                : lookahead === \" \" ? parseOperator(s)\n                                    : s.error(writeUnexpectedCharacterMessage(lookahead)));\n};\nexport const writeUnexpectedCharacterMessage = (char, shouldBe = \"\") => `'${char}' is not allowed here${shouldBe && ` (should be ${shouldBe})`}`;\nexport const incompleteArrayTokenMessage = `Missing expected ']'`;\n", "import { throwParseError } from \"@ark/util\";\nconst unitLiteralKeywords = {\n    null: null,\n    undefined,\n    true: true,\n    false: false\n};\nexport const parseDefault = (s) => {\n    if (!s.defaultable)\n        return throwParseError(shallowDefaultMessage);\n    // store the node that will be bounded\n    const baseNode = s.unsetRoot();\n    s.parseOperand();\n    const defaultNode = s.unsetRoot();\n    // after parsing the next operand, use the locations to get the\n    // token from which it was parsed\n    if (!defaultNode.hasKind(\"unit\"))\n        return s.error(writeNonLiteralDefaultMessage(defaultNode.expression));\n    // assignability is checked in parseEntries\n    return [baseNode, \"=\", defaultNode.unit];\n};\nexport const writeNonLiteralDefaultMessage = (defaultDef) => `Default value '${defaultDef}' must a literal value`;\nexport const shallowDefaultMessage = `Default values must be specified on objects like { isAdmin: 'boolean = false' }`;\n", "import { throwInternalError, throwParseError } from \"@ark/util\";\nimport { parseDefault } from \"./shift/operator/default.js\";\nimport { writeUnexpectedCharacterMessage } from \"./shift/operator/operator.js\";\nexport const fullStringParse = (s) => {\n    s.parseOperand();\n    let result = parseUntilFinalizer(s).root;\n    if (!result) {\n        return throwInternalError(`Root was unexpectedly unset after parsing string '${s.scanner.scanned}'`);\n    }\n    if (s.finalizer === \"=\")\n        result = parseDefault(s);\n    s.scanner.shiftUntilNonWhitespace();\n    if (s.scanner.lookahead) {\n        // throw a parse error if non-whitespace characters made it here without being parsed\n        throwParseError(writeUnexpectedCharacterMessage(s.scanner.lookahead));\n    }\n    return result;\n};\nexport const parseUntilFinalizer = (s) => {\n    while (s.finalizer === undefined)\n        next(s);\n    return s;\n};\nconst next = (s) => s.hasRoot() ? s.parseOperator() : s.parseOperand();\n", "import { isKeyOf, throwInternalError, throwParseError } from \"@ark/util\";\nimport { parseOperand } from \"../shift/operand/operand.js\";\nimport { parseOperator } from \"../shift/operator/operator.js\";\nimport { parseUntilFinalizer } from \"../string.js\";\nimport { invertedComparators, minComparators, writeMultipleLeftBoundsMessage, writeOpenRangeMessage, writeUnclosedGroupMessage, writeUnmatchedGroupCloseMessage, writeUnpairableComparatorMessage } from \"./shared.js\";\nexport class DynamicState {\n    scanner;\n    ctx;\n    defaultable;\n    // set root type to `any` so that all constraints can be applied\n    root;\n    branches = {\n        prefixes: [],\n        leftBound: null,\n        intersection: null,\n        union: null\n    };\n    finalizer;\n    groups = [];\n    constructor(scanner, ctx, defaultable) {\n        this.scanner = scanner;\n        this.ctx = ctx;\n        this.defaultable = defaultable;\n    }\n    error(message) {\n        return throwParseError(message);\n    }\n    hasRoot() {\n        return this.root !== undefined;\n    }\n    setRoot(root) {\n        this.root = root;\n    }\n    unsetRoot() {\n        const value = this.root;\n        this.root = undefined;\n        return value;\n    }\n    constrainRoot(...args) {\n        this.root = this.root.constrain(args[0], args[1]);\n    }\n    finalize(finalizer) {\n        if (this.groups.length)\n            return this.error(writeUnclosedGroupMessage(\")\"));\n        this.finalizeBranches();\n        this.finalizer = finalizer;\n    }\n    reduceLeftBound(limit, comparator) {\n        const invertedComparator = invertedComparators[comparator];\n        if (!isKeyOf(invertedComparator, minComparators))\n            return this.error(writeUnpairableComparatorMessage(comparator));\n        if (this.branches.leftBound) {\n            return this.error(writeMultipleLeftBoundsMessage(this.branches.leftBound.limit, this.branches.leftBound.comparator, limit, invertedComparator));\n        }\n        this.branches.leftBound = {\n            comparator: invertedComparator,\n            limit\n        };\n    }\n    finalizeBranches() {\n        this.assertRangeUnset();\n        if (this.branches.union) {\n            this.pushRootToBranch(\"|\");\n            this.root = this.branches.union;\n        }\n        else if (this.branches.intersection) {\n            this.pushRootToBranch(\"&\");\n            this.root = this.branches.intersection;\n        }\n        else\n            this.applyPrefixes();\n    }\n    finalizeGroup() {\n        this.finalizeBranches();\n        const topBranchState = this.groups.pop();\n        if (!topBranchState)\n            return this.error(writeUnmatchedGroupCloseMessage(this.scanner.unscanned));\n        this.branches = topBranchState;\n    }\n    addPrefix(prefix) {\n        this.branches.prefixes.push(prefix);\n    }\n    applyPrefixes() {\n        while (this.branches.prefixes.length) {\n            const lastPrefix = this.branches.prefixes.pop();\n            this.root =\n                lastPrefix === \"keyof\" ?\n                    this.root.keyof()\n                    : throwInternalError(`Unexpected prefix '${lastPrefix}'`);\n        }\n    }\n    pushRootToBranch(token) {\n        this.assertRangeUnset();\n        this.applyPrefixes();\n        const root = this.root;\n        this.branches.intersection = this.branches.intersection?.and(root) ?? root;\n        if (token === \"|\") {\n            this.branches.union =\n                this.branches.union?.or(this.branches.intersection) ??\n                    this.branches.intersection;\n            this.branches.intersection = null;\n        }\n        this.root = undefined;\n    }\n    parseUntilFinalizer() {\n        return parseUntilFinalizer(new DynamicState(this.scanner, this.ctx, false));\n    }\n    parseOperator() {\n        return parseOperator(this);\n    }\n    parseOperand() {\n        return parseOperand(this);\n    }\n    assertRangeUnset() {\n        if (this.branches.leftBound) {\n            return this.error(writeOpenRangeMessage(this.branches.leftBound.limit, this.branches.leftBound.comparator));\n        }\n    }\n    reduceGroupOpen() {\n        this.groups.push(this.branches);\n        this.branches = {\n            prefixes: [],\n            leftBound: null,\n            union: null,\n            intersection: null\n        };\n    }\n    previousOperator() {\n        return (this.branches.leftBound?.comparator ??\n            this.branches.prefixes.at(-1) ??\n            (this.branches.intersection ? \"&\"\n                : this.branches.union ? \"|\"\n                    : undefined));\n    }\n    shiftedByOne() {\n        this.scanner.shift();\n        return this;\n    }\n}\n", "import { throwParseError, whiteSpaceTokens } from \"@ark/util\";\nimport { DynamicState } from \"./parser/string/reduce/dynamic.js\";\nimport { Scanner } from \"./parser/string/shift/scanner.js\";\nimport { parseUntilFinalizer } from \"./parser/string/string.js\";\nexport const emptyGenericParameterMessage = \"An empty string is not a valid generic parameter name\";\nexport const parseGenericParams = (def, ctx) => parseName(new Scanner(def), [], ctx);\nconst paramsTerminators = { ...whiteSpaceTokens, \",\": true, \":\": true };\nconst parseName = (scanner, result, ctx) => {\n    scanner.shiftUntilNonWhitespace();\n    const name = scanner.shiftUntilNextTerminator();\n    if (name === \"\") {\n        // if we've reached the end of the string and have parsed at least one\n        // param, return the valid result\n        if (scanner.lookahead === \"\" && result.length)\n            return result;\n        return throwParseError(emptyGenericParameterMessage);\n    }\n    scanner.shiftUntilNonWhitespace();\n    return _parseOptionalConstraint(scanner, name, result, ctx);\n};\nconst extendsToken = \"extends \";\nconst _parseOptionalConstraint = (scanner, name, result, ctx) => {\n    scanner.shiftUntilNonWhitespace();\n    if (scanner.lookahead === \":\")\n        scanner.shift();\n    else if (scanner.unscanned.startsWith(extendsToken))\n        scanner.jumpForward(extendsToken.length);\n    else {\n        // if we don't have a contraining token here, return now so we can\n        // assume in the rest of the function body we do have a constraint\n        if (scanner.lookahead === \",\")\n            scanner.shift();\n        result.push(name);\n        return parseName(scanner, result, ctx);\n    }\n    const s = parseUntilFinalizer(new DynamicState(scanner, ctx, false));\n    result.push([name, s.root]);\n    return parseName(scanner, result, ctx);\n};\n", "export const createMatchParser = ($) => (() => { }).bind($);\n// const matchParser = (isRestricted: boolean) => {\n// \tconst handledCases: { when: RawRoot; then: Morph }[] = []\n// \tlet defaultCase: ((x: unknown) => unknown) | null = null\n// \tconst parser = {\n// \t\twhen: (when: unknown, then: Morph) => {\n// \t\t\thandledCases.push({ when: $.parseRoot(when, {}), then })\n// \t\t\treturn parser\n// \t\t},\n// \t\tfinalize: () => {\n// \t\t\t// TODO: exhaustiveness checking\n// \t\t\tconst branches = handledCases.flatMap(({ when, then }) => {\n// \t\t\t\tif (when.kind === \"union\") {\n// \t\t\t\t\treturn when.branches.map((branch) => ({\n// \t\t\t\t\t\tin: branch,\n// \t\t\t\t\t\tmorph: then\n// \t\t\t\t\t}))\n// \t\t\t\t}\n// \t\t\t\tif (when.kind === \"morph\") {\n// \t\t\t\t\treturn [{ in: when, morph: [when.morph, then] }]\n// \t\t\t\t}\n// \t\t\t\treturn [{ in: when, morph: then }]\n// \t\t\t})\n// \t\t\tif (defaultCase) {\n// \t\t\t\tbranches.push({ in: keywordNodes.unknown, morph: defaultCase })\n// \t\t\t}\n// \t\t\tconst matchers = $.node(\"union\", {\n// \t\t\t\tbranches,\n// \t\t\t\tordered: true\n// \t\t\t})\n// \t\t\treturn matchers.assert\n// \t\t},\n// \t\torThrow: () => {\n// \t\t\t// implicitly finalize, we don't need to do anything else because we throw either way\n// \t\t\treturn parser.finalize()\n// \t\t},\n// \t\tdefault: (x: unknown) => {\n// \t\t\tif (x instanceof Function) {\n// \t\t\t\tdefaultCase = x as never\n// \t\t\t} else {\n// \t\t\t\tdefaultCase = () => x\n// \t\t\t}\n// \t\t\treturn parser.finalize()\n// \t\t}\n// \t}\n// \treturn parser\n// }\n// return Object.assign(() => matchParser(false), {\n// \tonly: () => matchParser(true)\n// }) as never\n", "export const writeUnassignableDefaultValueMessage = (key, message) => `Default value at ${key} ${message}`;\n", "import { ArkErrors, normalizeIndex } from \"@ark/schema\";\nimport { append, escapeToken, isArray, printable, stringAndSymbolicEntriesOf, throwParseError } from \"@ark/util\";\nimport { writeUnassignableDefaultValueMessage } from \"./semantic/default.js\";\nexport const parseObjectLiteral = (def, ctx) => {\n    let spread;\n    const structure = {};\n    // We only allow a spread operator to be used as the first key in an object\n    // because to match JS behavior any keys before the spread are overwritten\n    // by the values in the target object, so there'd be no useful purpose in having it\n    // anywhere except for the beginning.\n    const parsedEntries = stringAndSymbolicEntriesOf(def).flatMap(entry => parseEntry(entry[0], entry[1], ctx));\n    if (parsedEntries[0]?.kind === \"spread\") {\n        // remove the spread entry so we can iterate over the remaining entries\n        // expecting non-spread entries\n        const spreadEntry = parsedEntries.shift();\n        if (!spreadEntry.node.hasKind(\"intersection\") ||\n            !spreadEntry.node.structure) {\n            return throwParseError(writeInvalidSpreadTypeMessage(typeof spreadEntry.node.expression));\n        }\n        spread = spreadEntry.node.structure;\n    }\n    for (const entry of parsedEntries) {\n        if (entry.kind === \"spread\")\n            return throwParseError(nonLeadingSpreadError);\n        if (entry.kind === \"undeclared\") {\n            structure.undeclared = entry.behavior;\n            continue;\n        }\n        structure[entry.kind] = append(structure[entry.kind], entry);\n    }\n    const structureNode = ctx.$.node(\"structure\", structure);\n    return ctx.$.schema({\n        domain: \"object\",\n        structure: spread?.merge(structureNode) ?? structureNode\n    });\n};\nexport const writeInvalidUndeclaredBehaviorMessage = (actual) => `Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${printable(actual)})`;\nexport const nonLeadingSpreadError = \"Spread operator may only be used as the first key in an object\";\nexport const parseEntry = (key, value, ctx) => {\n    const parsedKey = parseKey(key);\n    if (parsedKey.kind === \"+\") {\n        if (value !== \"reject\" && value !== \"delete\" && value !== \"ignore\")\n            throwParseError(writeInvalidUndeclaredBehaviorMessage(value));\n        return { kind: \"undeclared\", behavior: value };\n    }\n    if (parsedKey.kind === \"...\")\n        return { kind: \"spread\", node: ctx.$.parse(value, ctx) };\n    const parsedValue = isArray(value) && value[1] === \"=\" ?\n        [ctx.$.parse(value[0], ctx), \"=\", value[2]]\n        : ctx.$.parse(value, ctx, true);\n    if (isArray(parsedValue)) {\n        if (parsedKey.kind !== \"required\")\n            throwParseError(invalidDefaultKeyKindMessage);\n        const out = parsedValue[0].traverse(parsedValue[2]);\n        if (out instanceof ArkErrors) {\n            throwParseError(writeUnassignableDefaultValueMessage(printable(parsedKey.key), out.message));\n        }\n        return ctx.$.node(\"optional\", {\n            key: parsedKey.key,\n            value: parsedValue[0],\n            default: parsedValue[2]\n        });\n    }\n    if (parsedKey.kind === \"index\") {\n        const signature = ctx.$.parse(parsedKey.key, ctx);\n        const normalized = normalizeIndex(signature, parsedValue, ctx.$);\n        return (normalized.index ?\n            normalized.required ?\n                [normalized.index, ...normalized.required]\n                : normalized.index\n            : normalized.required ?? []);\n    }\n    return ctx.$.node(parsedKey.kind, {\n        key: parsedKey.key,\n        value: parsedValue\n    });\n};\n// single quote use here is better for TypeScript's inlined error to avoid escapes\nexport const invalidDefaultKeyKindMessage = `Only required keys may specify default values, e.g. { value: 'number = 0' }`;\nconst parseKey = (key) => typeof key === \"symbol\" ? { kind: \"required\", key }\n    : key.at(-1) === \"?\" ?\n        key.at(-2) === escapeToken ?\n            { kind: \"required\", key: `${key.slice(0, -2)}?` }\n            : {\n                kind: \"optional\",\n                key: key.slice(0, -1)\n            }\n        : key[0] === \"[\" && key.at(-1) === \"]\" ?\n            { kind: \"index\", key: key.slice(1, -1) }\n            : key[0] === escapeToken && key[1] === \"[\" && key.at(-1) === \"]\" ?\n                { kind: \"required\", key: key.slice(1) }\n                : key === \"...\" ? { kind: key, key }\n                    : key === \"+\" ? { kind: key, key }\n                        : {\n                            kind: \"required\",\n                            key: key === \"\\\\...\" ? \"...\"\n                                : key === \"\\\\+\" ? \"+\"\n                                    : key\n                        };\nexport const writeInvalidSpreadTypeMessage = (def) => `Spread operand must resolve to an object literal type (was ${def})`;\n", "import { jsObjects, makeRootAndArrayPropertiesMutable, tsKeywords } from \"@ark/schema\";\nimport { append, objectKindOrDomainOf, throwParseError } from \"@ark/util\";\nimport { writeMissingRightOperandMessage } from \"./string/shift/operand/unenclosed.js\";\nexport const parseTuple = (def, ctx) => maybeParseTupleExpression(def, ctx) ?? parseTupleLiteral(def, ctx);\nexport const parseTupleLiteral = (def, ctx) => {\n    let sequences = [{}];\n    let i = 0;\n    while (i < def.length) {\n        let spread = false;\n        let optional = false;\n        if (def[i] === \"...\" && i < def.length - 1) {\n            spread = true;\n            i++;\n        }\n        const element = ctx.$.parse(def[i], ctx);\n        i++;\n        if (def[i] === \"?\") {\n            if (spread)\n                return throwParseError(spreadOptionalMessage);\n            optional = true;\n            i++;\n        }\n        if (spread) {\n            if (!element.extends(jsObjects.Array))\n                return throwParseError(writeNonArraySpreadMessage(element.expression));\n            // a spread must be distributed over branches e.g.:\n            // def: [string, ...(number[] | [true, false])]\n            // nodes: [string, ...number[]] | [string, true, false]\n            sequences = sequences.flatMap(base => \n            // since appendElement mutates base, we have to shallow-ish clone it for each branch\n            element.branches.map(branch => appendSpreadBranch(makeRootAndArrayPropertiesMutable(base), branch)));\n        }\n        else {\n            sequences = sequences.map(base => appendElement(base, optional ? \"optional\" : \"required\", element));\n        }\n    }\n    return ctx.$.internal.schema(sequences.map(sequence => ({\n        proto: Array,\n        sequence\n    })));\n};\nconst appendElement = (base, kind, element) => {\n    switch (kind) {\n        case \"required\":\n            if (base.optionals)\n                // e.g. [string?, number]\n                return throwParseError(requiredPostOptionalMessage);\n            if (base.variadic) {\n                // e.g. [...string[], number]\n                base.postfix = append(base.postfix, element);\n            }\n            else {\n                // e.g. [string, number]\n                base.prefix = append(base.prefix, element);\n            }\n            return base;\n        case \"optional\":\n            if (base.variadic)\n                // e.g. [...string[], number?]\n                return throwParseError(optionalPostVariadicMessage);\n            // e.g. [string, number?]\n            base.optionals = append(base.optionals, element);\n            return base;\n        case \"variadic\":\n            // e.g. [...string[], number, ...string[]]\n            if (base.postfix)\n                throwParseError(multipleVariadicMesage);\n            if (base.variadic) {\n                if (!base.variadic.equals(element)) {\n                    // e.g. [...string[], ...number[]]\n                    throwParseError(multipleVariadicMesage);\n                }\n                // e.g. [...string[], ...string[]]\n                // do nothing, second spread doesn't change the type\n            }\n            else {\n                // e.g. [string, ...number[]]\n                base.variadic = element.internal;\n            }\n            return base;\n    }\n};\nconst appendSpreadBranch = (base, branch) => {\n    const spread = branch.firstReferenceOfKind(\"sequence\");\n    if (!spread) {\n        // the only array with no sequence reference is unknown[]\n        return appendElement(base, \"variadic\", tsKeywords.unknown.internal);\n    }\n    spread.prefix.forEach(node => appendElement(base, \"required\", node));\n    spread.optionals.forEach(node => appendElement(base, \"optional\", node));\n    spread.variadic && appendElement(base, \"variadic\", spread.variadic);\n    spread.postfix.forEach(node => appendElement(base, \"required\", node));\n    return base;\n};\nconst maybeParseTupleExpression = (def, ctx) => {\n    const tupleExpressionResult = isIndexZeroExpression(def) ? prefixParsers[def[0]](def, ctx)\n        : isIndexOneExpression(def) ? indexOneParsers[def[1]](def, ctx)\n            : undefined;\n    return tupleExpressionResult;\n};\nexport const writeNonArraySpreadMessage = (operand) => `Spread element must be an array (was ${operand})`;\nexport const multipleVariadicMesage = \"A tuple may have at most one variadic element\";\nexport const requiredPostOptionalMessage = \"A required element may not follow an optional element\";\nexport const optionalPostVariadicMessage = \"An optional element may not follow a variadic element\";\nexport const spreadOptionalMessage = \"A spread element cannot be optional\";\nexport const parseKeyOfTuple = (def, ctx) => ctx.$.parse(def[1], ctx).keyof();\nconst parseBranchTuple = (def, ctx) => {\n    if (def[2] === undefined)\n        return throwParseError(writeMissingRightOperandMessage(def[1], \"\"));\n    const l = ctx.$.parse(def[0], ctx);\n    const r = ctx.$.parse(def[2], ctx);\n    return def[1] === \"&\" ? l.and(r) : l.or(r);\n};\nconst parseArrayTuple = (def, ctx) => ctx.$.parse(def[0], ctx).array();\nconst isIndexOneExpression = (def) => indexOneParsers[def[1]] !== undefined;\nexport const parseMorphTuple = (def, ctx) => {\n    if (typeof def[2] !== \"function\") {\n        return throwParseError(writeMalformedFunctionalExpressionMessage(\"=>\", def[2]));\n    }\n    // TODO: nested morphs?\n    return ctx.$.parse(def[0], ctx).pipe(def[2]);\n};\nexport const writeMalformedFunctionalExpressionMessage = (operator, value) => `${operator === \":\" ? \"Narrow\" : \"Morph\"} expression requires a function following '${operator}' (was ${typeof value})`;\nexport const parseNarrowTuple = (def, ctx) => {\n    if (typeof def[2] !== \"function\") {\n        return throwParseError(writeMalformedFunctionalExpressionMessage(\":\", def[2]));\n    }\n    return ctx.$.parse(def[0], ctx).constrain(\"predicate\", def[2]);\n};\nconst parseAttributeTuple = (def, ctx) => ctx.$.parse(def[0], ctx).configureShallowDescendants(def[2]);\nconst indexOneParsers = {\n    \"|\": parseBranchTuple,\n    \"&\": parseBranchTuple,\n    \"[]\": parseArrayTuple,\n    \":\": parseNarrowTuple,\n    \"=>\": parseMorphTuple,\n    \"@\": parseAttributeTuple\n};\nconst prefixParsers = {\n    keyof: parseKeyOfTuple,\n    instanceof: (def, ctx) => {\n        if (typeof def[1] !== \"function\") {\n            return throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(def[1])));\n        }\n        const branches = def\n            .slice(1)\n            .map(ctor => typeof ctor === \"function\" ?\n            ctx.$.node(\"proto\", { proto: ctor })\n            : throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(ctor))));\n        return branches.length === 1 ?\n            branches[0]\n            : ctx.$.node(\"union\", { branches });\n    },\n    \"===\": (def, ctx) => ctx.$.units(def.slice(1))\n};\nconst isIndexZeroExpression = (def) => prefixParsers[def[0]] !== undefined;\nexport const writeInvalidConstructorMessage = (actual) => `Expected a constructor following 'instanceof' operator (was ${actual})`;\n", "import { hasArkKind } from \"@ark/schema\";\nimport { isThunk, objectKindOf, printable, throwParseError } from \"@ark/util\";\nimport { parseObjectLiteral } from \"./objectLiteral.js\";\nimport { parseTuple } from \"./tuple.js\";\nexport const parseObject = (def, ctx) => {\n    const objectKind = objectKindOf(def);\n    switch (objectKind) {\n        case undefined:\n            if (hasArkKind(def, \"root\"))\n                return def;\n            return parseObjectLiteral(def, ctx);\n        case \"Array\":\n            return parseTuple(def, ctx);\n        case \"RegExp\":\n            return ctx.$.node(\"intersection\", {\n                domain: \"string\",\n                pattern: def\n            }, { prereduced: true });\n        case \"Function\": {\n            const resolvedDef = isThunk(def) ? def() : def;\n            if (hasArkKind(resolvedDef, \"root\"))\n                return resolvedDef;\n            return throwParseError(writeBadDefinitionTypeMessage(\"Function\"));\n        }\n        default:\n            return throwParseError(writeBadDefinitionTypeMessage(objectKind ?? printable(def)));\n    }\n};\nexport const writeBadDefinitionTypeMessage = (actual) => `Type definitions must be strings or objects (was ${actual})`;\n", "import { ArkErrors, BaseRoot } from \"@ark/schema\";\nimport { Callable } from \"@ark/util\";\nimport { parseGenericParams } from \"./generic.js\";\nexport class RawTypeParser extends Callable {\n    constructor($) {\n        super((...args) => {\n            if (args.length === 1) {\n                // treat as a simple definition\n                return $.parseRoot(args[0]);\n            }\n            if (args.length === 2 &&\n                typeof args[0] === \"string\" &&\n                args[0][0] === \"<\" &&\n                args[0].at(-1) === \">\") {\n                // if there are exactly two args, the first of which looks like <${string}>,\n                // treat as a generic\n                const params = parseGenericParams(args[0].slice(1, -1), {\n                    $,\n                    args: {}\n                });\n                const def = args[1];\n                return $.generic(params, def);\n            }\n            // otherwise, treat as a tuple expression. technically, this also allows\n            // non-expression tuple definitions to be parsed, but it's not a supported\n            // part of the API as specified by the associated types\n            return $.parseRoot(args);\n        }, {\n            bind: $,\n            attach: {\n                errors: ArkErrors,\n                raw: $.parseRoot\n            }\n        });\n    }\n}\nexport const Type = BaseRoot;\n", "var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { RawRootScope, hasArkKind, parseGeneric } from \"@ark/schema\";\nimport { bound, domainOf, hasDomain, isThunk, throwParseError } from \"@ark/util\";\nimport { parseGenericParams } from \"./generic.js\";\nimport { createMatchParser } from \"./match.js\";\nimport { parseObject, writeBadDefinitionTypeMessage } from \"./parser/definition.js\";\nimport { DynamicState } from \"./parser/string/reduce/dynamic.js\";\nimport { writeUnexpectedCharacterMessage } from \"./parser/string/shift/operator/operator.js\";\nimport { Scanner } from \"./parser/string/shift/scanner.js\";\nimport { fullStringParse } from \"./parser/string/string.js\";\nimport { RawTypeParser } from \"./type.js\";\nexport const scope = ((def, config = {}) => new RawScope(def, config));\nlet RawScope = (() => {\n    let _classSuper = RawRootScope;\n    let _instanceExtraInitializers = [];\n    let _parseRoot_decorators;\n    return class RawScope extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _parseRoot_decorators = [bound];\n            __esDecorate(this, null, _parseRoot_decorators, { kind: \"method\", name: \"parseRoot\", static: false, private: false, access: { has: obj => \"parseRoot\" in obj, get: obj => obj.parseRoot }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        parseCache = (__runInitializers(this, _instanceExtraInitializers), {});\n        constructor(def, config) {\n            super(def, config);\n        }\n        type = new RawTypeParser(this);\n        match = createMatchParser(this);\n        declare = (() => ({\n            type: this.type\n        })).bind(this);\n        define = ((def) => def).bind(this);\n        preparseAlias(k, v) {\n            const firstParamIndex = k.indexOf(\"<\");\n            if (firstParamIndex === -1)\n                return [k, v];\n            if (k.at(-1) !== \">\") {\n                throwParseError(`'>' must be the last character of a generic declaration in a scope`);\n            }\n            const name = k.slice(0, firstParamIndex);\n            const paramString = k.slice(firstParamIndex + 1, -1);\n            return [\n                name,\n                // use a thunk definition for the generic so that we can parse\n                // constraints within the current scope\n                () => {\n                    const params = parseGenericParams(paramString, {\n                        $: this,\n                        args: {}\n                    });\n                    const generic = parseGeneric(params, v, this);\n                    return generic;\n                }\n            ];\n        }\n        preparseRoot(def) {\n            if (isThunk(def) && !hasArkKind(def, \"generic\"))\n                return def();\n            return def;\n        }\n        parseRoot(def, opts = {}) {\n            const node = this.parse(def, Object.assign(this.finalizeRootArgs(opts, () => node), { $: this })).bindScope(this);\n            return node;\n        }\n        parse(def, ctx, defaultable = false) {\n            if (typeof def === \"string\") {\n                if (ctx.args && Object.keys(ctx.args).some(k => def.includes(k))) {\n                    // we can only rely on the cache if there are no contextual\n                    // resolutions like \"this\" or generic args\n                    return this.parseString(def, ctx, defaultable);\n                }\n                const contextKey = `${def}${defaultable}`;\n                return (this.parseCache[contextKey] ??= this.parseString(def, ctx, defaultable));\n            }\n            return hasDomain(def, \"object\") ?\n                parseObject(def, ctx)\n                : throwParseError(writeBadDefinitionTypeMessage(domainOf(def)));\n        }\n        parseString(def, ctx, defaultable) {\n            const aliasResolution = this.maybeResolveRoot(def);\n            if (aliasResolution)\n                return aliasResolution;\n            const aliasArrayResolution = def.endsWith(\"[]\") ?\n                this.maybeResolveRoot(def.slice(0, -2))?.array()\n                : undefined;\n            if (aliasArrayResolution)\n                return aliasArrayResolution;\n            const s = new DynamicState(new Scanner(def), ctx, defaultable);\n            const node = fullStringParse(s);\n            if (s.finalizer === \">\")\n                throwParseError(writeUnexpectedCharacterMessage(\">\"));\n            return node;\n        }\n    };\n})();\nexport { RawScope };\nexport const writeShallowCycleErrorMessage = (name, seen) => `Alias '${name}' has a shallow resolution cycle: ${[...seen, name].join(\":\")}`;\n", "import { keywordNodes } from \"@ark/schema\";\nimport { scope } from \"./scope.js\";\nexport const ambient = scope(keywordNodes);\nexport const ark = ambient.export();\nexport const type = ambient.type;\nexport const match = ambient.match;\nexport const define = ambient.define;\nexport const declare = ambient.declare;\n", "import { RootModule } from \"@ark/schema\";\nexport const Module = RootModule;\n"],
  "mappings": "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",
  "names": ["_a", "_a", "Hkt", "_a", "_b", "_a", "_b", "root", "_a", "_a", "$", "_b", "node", "transformed", "node", "$", "_a", "_b", "schema", "root", "node", "__runInitializers", "__esDecorate", "$", "_a", "_b", "schema", "node", "schema", "node", "greatestCommonDivisor", "root", "schema", "node", "schema", "node", "schema", "node", "schema", "node", "schema", "node", "schema", "node", "schema", "node", "schema", "node", "__runInitializers", "__esDecorate", "_a", "_b", "node", "schema", "schema", "kind", "__runInitializers", "__esDecorate", "_a", "schema", "node", "schema", "node", "_a", "node", "schema", "$", "schema", "node", "_a", "schema", "node", "__runInitializers", "__esDecorate", "schema", "$", "node", "_a", "cases", "node", "schema", "node", "schema", "node", "schema", "node", "schema", "node", "__runInitializers", "__esDecorate", "schema", "_a", "_b", "$", "node", "_a", "_b", "node", "__runInitializers", "__esDecorate", "_a", "_b", "node", "data", "node", "_a", "_b", "schema", "structuralExpression", "$", "schema", "node", "id", "$", "json", "node", "__runInitializers", "__esDecorate", "schema", "_a", "_b", "def", "node", "id", "cached", "$", "node", "date", "url", "date", "_a", "Scanner", "root", "root", "_a", "_b", "$", "_a", "node", "$", "__runInitializers", "__esDecorate", "_a", "generic", "node"]
}
